// this file was autogenerated by Arri. Do not modify directly.
// See details at https://github.com/modiimedia/arri
import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.plugins.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.http.*
import io.ktor.utils.io.*
import kotlinx.coroutines.*
import kotlinx.serialization.KSerializer
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.encodeToJsonElement
import kotlinx.serialization.json.jsonObject
import java.nio.ByteBuffer
import java.time.Instant

val JsonInstance = Json { ignoreUnknownKeys = true }

class TestClient(
    private val httpClient: HttpClient,
    private val baseUrl: String = "",
    private val headers: Map<String, String> = mutableMapOf(),
) {
    val tests = TestClientTestsService(httpClient, baseUrl, headers)
    val adapters = TestClientAdaptersService(httpClient, baseUrl, headers)
    val users = TestClientUsersService(httpClient, baseUrl, headers)

}

class TestClientTestsService(
    private val httpClient: HttpClient,
    private val baseUrl: String = "",
    private val headers: Map<String, String> = mutableMapOf(),
) {

    suspend fun emptyParamsGetRequest(): DefaultPayload {
        val response = prepareRequest(
            client = httpClient,
            url = "$baseUrl/rpcs/tests/empty-params-get-request",
            method = HttpMethod.Get,
            params = null,
            headers = headers,
        ).execute()
        if (response.status.value in 200..299) {
            return JsonInstance.decodeFromString<DefaultPayload>(response.body())
        }
        val err = JsonInstance.decodeFromString<TestClientError>(response.body())
        throw err
    }
    suspend fun emptyParamsPostRequest(): DefaultPayload {
        val response = prepareRequest(
            client = httpClient,
            url = "$baseUrl/rpcs/tests/empty-params-post-request",
            method = HttpMethod.Post,
            params = null,
            headers = headers,
        ).execute()
        if (response.status.value in 200..299) {
            return JsonInstance.decodeFromString<DefaultPayload>(response.body())
        }
        val err = JsonInstance.decodeFromString<TestClientError>(response.body())
        throw err
    }
    suspend fun emptyResponseGetRequest(params: DefaultPayload): Unit {
        val response = prepareRequest(
            client = httpClient,
            url = "$baseUrl/rpcs/tests/empty-response-get-request",
            method = HttpMethod.Get,
            params = JsonInstance.encodeToJsonElement<DefaultPayload>(params),
            headers = headers,
        ).execute()
        if (response.status.value in 200..299) {
            return
        }
        val err = JsonInstance.decodeFromString<TestClientError>(response.body())
        throw err
    }
    suspend fun emptyResponsePostRequest(params: DefaultPayload): Unit {
        val response = prepareRequest(
            client = httpClient,
            url = "$baseUrl/rpcs/tests/empty-response-post-request",
            method = HttpMethod.Post,
            params = JsonInstance.encodeToJsonElement<DefaultPayload>(params),
            headers = headers,
        ).execute()
        if (response.status.value in 200..299) {
            return
        }
        val err = JsonInstance.decodeFromString<TestClientError>(response.body())
        throw err
    }
    suspend fun deprecatedRpc(params: DeprecatedRpcParams): Unit {
        val response = prepareRequest(
            client = httpClient,
            url = "$baseUrl/rpcs/tests/deprecated-rpc",
            method = HttpMethod.Post,
            params = JsonInstance.encodeToJsonElement<DeprecatedRpcParams>(params),
            headers = headers,
        ).execute()
        if (response.status.value in 200..299) {
            return
        }
        val err = JsonInstance.decodeFromString<TestClientError>(response.body())
        throw err
    }
    suspend fun sendObject(params: ObjectWithEveryType): ObjectWithEveryType {
        val response = prepareRequest(
            client = httpClient,
            url = "$baseUrl/rpcs/tests/send-object",
            method = HttpMethod.Post,
            params = JsonInstance.encodeToJsonElement<ObjectWithEveryType>(params),
            headers = headers,
        ).execute()
        if (response.status.value in 200..299) {
            return JsonInstance.decodeFromString<ObjectWithEveryType>(response.body())
        }
        val err = JsonInstance.decodeFromString<TestClientError>(response.body())
        throw err
    }
    suspend fun sendObjectWithNullableFields(params: ObjectWithEveryNullableType): ObjectWithEveryNullableType {
        val response = prepareRequest(
            client = httpClient,
            url = "$baseUrl/rpcs/tests/send-object-with-nullable-fields",
            method = HttpMethod.Post,
            params = JsonInstance.encodeToJsonElement<ObjectWithEveryNullableType>(params),
            headers = headers,
        ).execute()
        if (response.status.value in 200..299) {
            return JsonInstance.decodeFromString<ObjectWithEveryNullableType>(response.body())
        }
        val err = JsonInstance.decodeFromString<TestClientError>(response.body())
        throw err
    }
    suspend fun sendPartialObject(params: ObjectWithEveryOptionalType): ObjectWithEveryOptionalType {
        val response = prepareRequest(
            client = httpClient,
            url = "$baseUrl/rpcs/tests/send-partial-object",
            method = HttpMethod.Post,
            params = JsonInstance.encodeToJsonElement<ObjectWithEveryOptionalType>(params),
            headers = headers,
        ).execute()
        if (response.status.value in 200..299) {
            return JsonInstance.decodeFromString<ObjectWithEveryOptionalType>(response.body())
        }
        val err = JsonInstance.decodeFromString<TestClientError>(response.body())
        throw err
    }
    suspend fun sendRecursiveObject(params: RecursiveObject): RecursiveObject {
        val response = prepareRequest(
            client = httpClient,
            url = "$baseUrl/rpcs/tests/send-recursive-object",
            method = HttpMethod.Post,
            params = JsonInstance.encodeToJsonElement<RecursiveObject>(params),
            headers = headers,
        ).execute()
        if (response.status.value in 200..299) {
            return JsonInstance.decodeFromString<RecursiveObject>(response.body())
        }
        val err = JsonInstance.decodeFromString<TestClientError>(response.body())
        throw err
    }
    suspend fun sendRecursiveUnion(params: RecursiveUnion): RecursiveUnion {
        val response = prepareRequest(
            client = httpClient,
            url = "$baseUrl/rpcs/tests/send-recursive-union",
            method = HttpMethod.Post,
            params = JsonInstance.encodeToJsonElement<RecursiveUnion>(params),
            headers = headers,
        ).execute()
        if (response.status.value in 200..299) {
            return JsonInstance.decodeFromString<RecursiveUnion>(response.body())
        }
        val err = JsonInstance.decodeFromString<TestClientError>(response.body())
        throw err
    }
    fun streamAutoReconnect(
        scope: CoroutineScope,
        params: AutoReconnectParams,
        lastEventId: String? = null,
        bufferCapacity: Int = 1024,
        onOpen: ((response: HttpResponse) -> Unit) = {},
        onClose: (() -> Unit) = {},
        onError: ((error: TestClientError) -> Unit) = {},
        onConnectionError: ((error: TestClientError) -> Unit) = {},
        onData: ((data: AutoReconnectResponse) -> Unit) = {},
    ): Job {
        val finalHeaders = mutableMapOf<String, String>()
        for (item in headers.entries) {
            finalHeaders[item.key] = item.value
        }
        finalHeaders["Accept"] = "application/json, text/event-stream"
        val job = scope.launch {
            handleSseRequest(
                scope = scope,
                httpClient = httpClient,
                url = "$baseUrl/rpcs/tests/stream-auto-reconnect",
                method = HttpMethod.Get,
                params = JsonInstance.encodeToJsonElement<AutoReconnectParams>(params),
                headers = finalHeaders,
                backoffTime = 0,
                maxBackoffTime = 32000,
                lastEventId = lastEventId,
                bufferCapacity = bufferCapacity,
                onOpen = onOpen,
                onClose = onClose,
                onError = onError,
                onConnectionError = onConnectionError,
                onData = { str -> 
                    val data = JsonInstance.decodeFromString<AutoReconnectResponse>(str)
                    onData(data)
                },
            )
        }
        return job
    }
    fun streamConnectionErrorTest(
        scope: CoroutineScope,
        params: StreamConnectionErrorTestParams,
        lastEventId: String? = null,
        bufferCapacity: Int = 1024,
        onOpen: ((response: HttpResponse) -> Unit) = {},
        onClose: (() -> Unit) = {},
        onError: ((error: TestClientError) -> Unit) = {},
        onConnectionError: ((error: TestClientError) -> Unit) = {},
        onData: ((data: StreamConnectionErrorTestResponse) -> Unit) = {},
    ): Job {
        val finalHeaders = mutableMapOf<String, String>()
        for (item in headers.entries) {
            finalHeaders[item.key] = item.value
        }
        finalHeaders["Accept"] = "application/json, text/event-stream"
        val job = scope.launch {
            handleSseRequest(
                scope = scope,
                httpClient = httpClient,
                url = "$baseUrl/rpcs/tests/stream-connection-error-test",
                method = HttpMethod.Get,
                params = JsonInstance.encodeToJsonElement<StreamConnectionErrorTestParams>(params),
                headers = finalHeaders,
                backoffTime = 0,
                maxBackoffTime = 32000,
                lastEventId = lastEventId,
                bufferCapacity = bufferCapacity,
                onOpen = onOpen,
                onClose = onClose,
                onError = onError,
                onConnectionError = onConnectionError,
                onData = { str -> 
                    val data = JsonInstance.decodeFromString<StreamConnectionErrorTestResponse>(str)
                    onData(data)
                },
            )
        }
        return job
    }
    fun streamLargeObjects(
        scope: CoroutineScope,
        lastEventId: String? = null,
        bufferCapacity: Int = 1024,
        onOpen: ((response: HttpResponse) -> Unit) = {},
        onClose: (() -> Unit) = {},
        onError: ((error: TestClientError) -> Unit) = {},
        onConnectionError: ((error: TestClientError) -> Unit) = {},
        onData: ((data: StreamLargeObjectsResponse) -> Unit) = {},
    ): Job {
        val finalHeaders = mutableMapOf<String, String>()
        for (item in headers.entries) {
            finalHeaders[item.key] = item.value
        }
        finalHeaders["Accept"] = "application/json, text/event-stream"
        val job = scope.launch {
            handleSseRequest(
                scope = scope,
                httpClient = httpClient,
                url = "$baseUrl/rpcs/tests/stream-large-objects",
                method = HttpMethod.Get,
                params = null,
                headers = finalHeaders,
                backoffTime = 0,
                maxBackoffTime = 32000,
                lastEventId = lastEventId,
                bufferCapacity = bufferCapacity,
                onOpen = onOpen,
                onClose = onClose,
                onError = onError,
                onConnectionError = onConnectionError,
                onData = { str -> 
                    val data = JsonInstance.decodeFromString<StreamLargeObjectsResponse>(str)
                    onData(data)
                },
            )
        }
        return job
    }
    fun streamMessages(
        scope: CoroutineScope,
        params: ChatMessageParams,
        lastEventId: String? = null,
        bufferCapacity: Int = 1024,
        onOpen: ((response: HttpResponse) -> Unit) = {},
        onClose: (() -> Unit) = {},
        onError: ((error: TestClientError) -> Unit) = {},
        onConnectionError: ((error: TestClientError) -> Unit) = {},
        onData: ((data: ChatMessage) -> Unit) = {},
    ): Job {
        val finalHeaders = mutableMapOf<String, String>()
        for (item in headers.entries) {
            finalHeaders[item.key] = item.value
        }
        finalHeaders["Accept"] = "application/json, text/event-stream"
        val job = scope.launch {
            handleSseRequest(
                scope = scope,
                httpClient = httpClient,
                url = "$baseUrl/rpcs/tests/stream-messages",
                method = HttpMethod.Get,
                params = JsonInstance.encodeToJsonElement<ChatMessageParams>(params),
                headers = finalHeaders,
                backoffTime = 0,
                maxBackoffTime = 32000,
                lastEventId = lastEventId,
                bufferCapacity = bufferCapacity,
                onOpen = onOpen,
                onClose = onClose,
                onError = onError,
                onConnectionError = onConnectionError,
                onData = { str -> 
                    val data = JsonInstance.decodeFromString<ChatMessage>(str)
                    onData(data)
                },
            )
        }
        return job
    }
    fun streamTenEventsThenEnd(
        scope: CoroutineScope,
        lastEventId: String? = null,
        bufferCapacity: Int = 1024,
        onOpen: ((response: HttpResponse) -> Unit) = {},
        onClose: (() -> Unit) = {},
        onError: ((error: TestClientError) -> Unit) = {},
        onConnectionError: ((error: TestClientError) -> Unit) = {},
        onData: ((data: ChatMessage) -> Unit) = {},
    ): Job {
        val finalHeaders = mutableMapOf<String, String>()
        for (item in headers.entries) {
            finalHeaders[item.key] = item.value
        }
        finalHeaders["Accept"] = "application/json, text/event-stream"
        val job = scope.launch {
            handleSseRequest(
                scope = scope,
                httpClient = httpClient,
                url = "$baseUrl/rpcs/tests/stream-ten-events-then-end",
                method = HttpMethod.Get,
                params = null,
                headers = finalHeaders,
                backoffTime = 0,
                maxBackoffTime = 32000,
                lastEventId = lastEventId,
                bufferCapacity = bufferCapacity,
                onOpen = onOpen,
                onClose = onClose,
                onError = onError,
                onConnectionError = onConnectionError,
                onData = { str -> 
                    val data = JsonInstance.decodeFromString<ChatMessage>(str)
                    onData(data)
                },
            )
        }
        return job
    }
    fun streamTenEventsThenError(
        scope: CoroutineScope,
        lastEventId: String? = null,
        bufferCapacity: Int = 1024,
        onOpen: ((response: HttpResponse) -> Unit) = {},
        onClose: (() -> Unit) = {},
        onError: ((error: TestClientError) -> Unit) = {},
        onConnectionError: ((error: TestClientError) -> Unit) = {},
        onData: ((data: ChatMessage) -> Unit) = {},
    ): Job {
        val finalHeaders = mutableMapOf<String, String>()
        for (item in headers.entries) {
            finalHeaders[item.key] = item.value
        }
        finalHeaders["Accept"] = "application/json, text/event-stream"
        val job = scope.launch {
            handleSseRequest(
                scope = scope,
                httpClient = httpClient,
                url = "$baseUrl/rpcs/tests/stream-ten-events-then-error",
                method = HttpMethod.Post,
                params = null,
                headers = finalHeaders,
                backoffTime = 0,
                maxBackoffTime = 32000,
                lastEventId = lastEventId,
                bufferCapacity = bufferCapacity,
                onOpen = onOpen,
                onClose = onClose,
                onError = onError,
                onConnectionError = onConnectionError,
                onData = { str -> 
                    val data = JsonInstance.decodeFromString<ChatMessage>(str)
                    onData(data)
                },
            )
        }
        return job
    }
}



class TestClientAdaptersService(
    private val httpClient: HttpClient,
    private val baseUrl: String = "",
    private val headers: Map<String, String> = mutableMapOf(),
) {

    suspend fun typebox(params: TypeBoxObject): TypeBoxObject {
        val response = prepareRequest(
            client = httpClient,
            url = "$baseUrl/rpcs/adapters/typebox",
            method = HttpMethod.Post,
            params = JsonInstance.encodeToJsonElement<TypeBoxObject>(params),
            headers = headers,
        ).execute()
        if (response.status.value in 200..299) {
            return JsonInstance.decodeFromString<TypeBoxObject>(response.body())
        }
        val err = JsonInstance.decodeFromString<TestClientError>(response.body())
        throw err
    }
}



class TestClientUsersService(
    private val httpClient: HttpClient,
    private val baseUrl: String = "",
    private val headers: Map<String, String> = mutableMapOf(),
) {

    fun watchUser(
        scope: CoroutineScope,
        params: UsersWatchUserParams,
        lastEventId: String? = null,
        bufferCapacity: Int = 1024,
        onOpen: ((response: HttpResponse) -> Unit) = {},
        onClose: (() -> Unit) = {},
        onError: ((error: TestClientError) -> Unit) = {},
        onConnectionError: ((error: TestClientError) -> Unit) = {},
        onData: ((data: UsersWatchUserResponse) -> Unit) = {},
    ): Job {
        val finalHeaders = mutableMapOf<String, String>()
        for (item in headers.entries) {
            finalHeaders[item.key] = item.value
        }
        finalHeaders["Accept"] = "application/json, text/event-stream"
        val job = scope.launch {
            handleSseRequest(
                scope = scope,
                httpClient = httpClient,
                url = "$baseUrl/rpcs/users/watch-user",
                method = HttpMethod.Get,
                params = JsonInstance.encodeToJsonElement<UsersWatchUserParams>(params),
                headers = finalHeaders,
                backoffTime = 0,
                maxBackoffTime = 32000,
                lastEventId = lastEventId,
                bufferCapacity = bufferCapacity,
                onOpen = onOpen,
                onClose = onClose,
                onError = onError,
                onConnectionError = onConnectionError,
                onData = { str -> 
                    val data = JsonInstance.decodeFromString<UsersWatchUserResponse>(str)
                    onData(data)
                },
            )
        }
        return job
    }
}



@Serializable
data class ManuallyAddedModel(
    val hello: String,
)


@Serializable
data class DefaultPayload(
    val message: String,
)


@Serializable
data class TypeBoxObject(
    val string: String,
    val boolean: Boolean,
    val integer: Int,
    val number: Double,
    val enumField: TypeBoxObjectEnumField,
    @SerialName("object")
    val _object: TypeBoxObjectObject,
    val array: List<Boolean>,
    val optionalString: String? = null,
)

enum class TypeBoxObjectEnumField() {
    @SerialName("A")
    A,
    @SerialName("B")
    B,
    @SerialName("C")
    C,
}
@Serializable
data class TypeBoxObjectObject(
    val string: String,
)


@Serializable
data class DeprecatedRpcParams(
    val deprecatedField: String,
)


@Serializable
data class ObjectWithEveryType(
    val any: JsonElement,
    val boolean: Boolean,
    val string: String,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant,
    val float32: Float,
    val float64: Double,
    val int8: Byte,
    val uint8: UByte,
    val int16: Short,
    val uint16: UShort,
    val int32: Int,
    val uint32: UInt,
    val int64: Long,
    val uint64: ULong,
    val enumerator: ObjectWithEveryTypeEnumerator,
    val array: List<Boolean>,
    @SerialName("object")
    val _object: ObjectWithEveryTypeObject,
    val record: Map<String, Boolean>,
    val discriminator: ObjectWithEveryTypeDiscriminator,
    val nestedObject: ObjectWithEveryTypeNestedObject,
    val nestedArray: List<List<ObjectWithEveryTypeNestedArray>>,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryType

        if (any != other.any) return false
        if (boolean != other.boolean) return false
        if (string != other.string) return false
        if (timestamp.toEpochMilli() != other.timestamp.toEpochMilli()) return false
        if (float32 != other.float32) return false
        if (float64 != other.float64) return false
        if (int8 != other.int8) return false
        if (uint8 != other.uint8) return false
        if (int16 != other.int16) return false
        if (uint16 != other.uint16) return false
        if (int32 != other.int32) return false
        if (uint32 != other.uint32) return false
        if (int64 != other.int64) return false
        if (uint64 != other.uint64) return false
        if (enumerator != other.enumerator) return false
        if (array != other.array) return false
        if (_object != other._object) return false
        if (record != other.record) return false
        if (discriminator != other.discriminator) return false
        if (nestedObject != other.nestedObject) return false
        if (nestedArray != other.nestedArray) return false

        return true
    }

    override fun hashCode(): Int {
        var result = any.hashCode()
        result = 31 * result + boolean.hashCode()
        result = 31 * result + string.hashCode()
        result = 31 * result + timestamp.hashCode()
        result = 31 * result + float32.hashCode()
        result = 31 * result + float64.hashCode()
        result = 31 * result + int8.hashCode()
        result = 31 * result + uint8.hashCode()
        result = 31 * result + int16.hashCode()
        result = 31 * result + uint16.hashCode()
        result = 31 * result + int32.hashCode()
        result = 31 * result + uint32.hashCode()
        result = 31 * result + int64.hashCode()
        result = 31 * result + uint64.hashCode()
        result = 31 * result + enumerator.hashCode()
        result = 31 * result + array.hashCode()
        result = 31 * result + _object.hashCode()
        result = 31 * result + record.hashCode()
        result = 31 * result + discriminator.hashCode()
        result = 31 * result + nestedObject.hashCode()
        result = 31 * result + nestedArray.hashCode()
        return result
    }
}

enum class ObjectWithEveryTypeEnumerator() {
    @SerialName("A")
    A,
    @SerialName("B")
    B,
    @SerialName("C")
    C,
}
@Serializable
data class ObjectWithEveryTypeObject(
    val string: String,
    val boolean: Boolean,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryTypeObject

        if (string != other.string) return false
        if (boolean != other.boolean) return false
        if (timestamp.toEpochMilli() != other.timestamp.toEpochMilli()) return false

        return true
    }

    override fun hashCode(): Int {
        var result = string.hashCode()
        result = 31 * result + boolean.hashCode()
        result = 31 * result + timestamp.hashCode()
        return result
    }
}


@Serializable
sealed class ObjectWithEveryTypeDiscriminator()

@Serializable
@SerialName("A")
data class ObjectWithEveryTypeDiscriminatorDiscriminatorA(
    val title: String,
) : ObjectWithEveryTypeDiscriminator()



@Serializable
@SerialName("B")
data class ObjectWithEveryTypeDiscriminatorDiscriminatorB(
    val title: String,
    val description: String,
) : ObjectWithEveryTypeDiscriminator()


@Serializable
data class ObjectWithEveryTypeNestedObject(
    val id: String,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant,
    val data: ObjectWithEveryTypeNestedObjectData,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryTypeNestedObject

        if (id != other.id) return false
        if (timestamp.toEpochMilli() != other.timestamp.toEpochMilli()) return false
        if (data != other.data) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + timestamp.hashCode()
        result = 31 * result + data.hashCode()
        return result
    }
}

@Serializable
data class ObjectWithEveryTypeNestedObjectData(
    val id: String,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant,
    val data: ObjectWithEveryTypeNestedObjectDataData,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryTypeNestedObjectData

        if (id != other.id) return false
        if (timestamp.toEpochMilli() != other.timestamp.toEpochMilli()) return false
        if (data != other.data) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + timestamp.hashCode()
        result = 31 * result + data.hashCode()
        return result
    }
}

@Serializable
data class ObjectWithEveryTypeNestedObjectDataData(
    val id: String,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryTypeNestedObjectDataData

        if (id != other.id) return false
        if (timestamp.toEpochMilli() != other.timestamp.toEpochMilli()) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + timestamp.hashCode()
        return result
    }
}


@Serializable
data class ObjectWithEveryTypeNestedArray(
    val id: String,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryTypeNestedArray

        if (id != other.id) return false
        if (timestamp.toEpochMilli() != other.timestamp.toEpochMilli()) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + timestamp.hashCode()
        return result
    }
}


@Serializable
data class ObjectWithEveryNullableType(
    val any: JsonElement?,
    val boolean: Boolean?,
    val string: String?,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant?,
    val float32: Float?,
    val float64: Double?,
    val int8: Byte?,
    val uint8: UByte?,
    val int16: Short?,
    val uint16: UShort?,
    val int32: Int?,
    val uint32: UInt?,
    val int64: Long?,
    val uint64: ULong?,
    val enumerator: ObjectWithEveryNullableTypeEnumerator?,
    val array: List<Boolean?>?,
    @SerialName("object")
    val _object: ObjectWithEveryNullableTypeObject?,
    val record: Map<String, Boolean?>?,
    val discriminator: ObjectWithEveryNullableTypeDiscriminator?,
    val nestedObject: ObjectWithEveryNullableTypeNestedObject?,
    val nestedArray: List<List<ObjectWithEveryNullableTypeNestedArray?>?>?,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryNullableType

        if (any != other.any) return false
        if (boolean != other.boolean) return false
        if (string != other.string) return false
        if(timestamp?.toEpochMilli() != other.timestamp?.toEpochMilli()) return false
        if (float32 != other.float32) return false
        if (float64 != other.float64) return false
        if (int8 != other.int8) return false
        if (uint8 != other.uint8) return false
        if (int16 != other.int16) return false
        if (uint16 != other.uint16) return false
        if (int32 != other.int32) return false
        if (uint32 != other.uint32) return false
        if (int64 != other.int64) return false
        if (uint64 != other.uint64) return false
        if (enumerator != other.enumerator) return false
        if (array != other.array) return false
        if (_object != other._object) return false
        if (record != other.record) return false
        if (discriminator != other.discriminator) return false
        if (nestedObject != other.nestedObject) return false
        if (nestedArray != other.nestedArray) return false

        return true
    }

    override fun hashCode(): Int {
        var result = (any?.hashCode() ?: 0)
        result = 31 * result + (boolean?.hashCode() ?: 0)
        result = 31 * result + (string?.hashCode() ?: 0)
        result = 31 * result + (timestamp?.hashCode() ?: 0)
        result = 31 * result + (float32?.hashCode() ?: 0)
        result = 31 * result + (float64?.hashCode() ?: 0)
        result = 31 * result + (int8?.hashCode() ?: 0)
        result = 31 * result + (uint8?.hashCode() ?: 0)
        result = 31 * result + (int16?.hashCode() ?: 0)
        result = 31 * result + (uint16?.hashCode() ?: 0)
        result = 31 * result + (int32?.hashCode() ?: 0)
        result = 31 * result + (uint32?.hashCode() ?: 0)
        result = 31 * result + (int64?.hashCode() ?: 0)
        result = 31 * result + (uint64?.hashCode() ?: 0)
        result = 31 * result + (enumerator?.hashCode() ?: 0)
        result = 31 * result + (array?.hashCode() ?: 0)
        result = 31 * result + (_object?.hashCode() ?: 0)
        result = 31 * result + (record?.hashCode() ?: 0)
        result = 31 * result + (discriminator?.hashCode() ?: 0)
        result = 31 * result + (nestedObject?.hashCode() ?: 0)
        result = 31 * result + (nestedArray?.hashCode() ?: 0)
        return result
    }
}

enum class ObjectWithEveryNullableTypeEnumerator() {
    @SerialName("A")
    A,
    @SerialName("B")
    B,
    @SerialName("C")
    C,
}
@Serializable
data class ObjectWithEveryNullableTypeObject(
    val string: String?,
    val boolean: Boolean?,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant?,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryNullableTypeObject

        if (string != other.string) return false
        if (boolean != other.boolean) return false
        if(timestamp?.toEpochMilli() != other.timestamp?.toEpochMilli()) return false

        return true
    }

    override fun hashCode(): Int {
        var result = (string?.hashCode() ?: 0)
        result = 31 * result + (boolean?.hashCode() ?: 0)
        result = 31 * result + (timestamp?.hashCode() ?: 0)
        return result
    }
}


@Serializable
sealed class ObjectWithEveryNullableTypeDiscriminator()

@Serializable
@SerialName("A")
data class ObjectWithEveryNullableTypeDiscriminatorDiscriminatorA(
    val title: String?,
) : ObjectWithEveryNullableTypeDiscriminator()



@Serializable
@SerialName("B")
data class ObjectWithEveryNullableTypeDiscriminatorDiscriminatorB(
    val title: String?,
    val description: String?,
) : ObjectWithEveryNullableTypeDiscriminator()


@Serializable
data class ObjectWithEveryNullableTypeNestedObject(
    val id: String?,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant?,
    val data: ObjectWithEveryNullableTypeNestedObjectData?,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryNullableTypeNestedObject

        if (id != other.id) return false
        if(timestamp?.toEpochMilli() != other.timestamp?.toEpochMilli()) return false
        if (data != other.data) return false

        return true
    }

    override fun hashCode(): Int {
        var result = (id?.hashCode() ?: 0)
        result = 31 * result + (timestamp?.hashCode() ?: 0)
        result = 31 * result + (data?.hashCode() ?: 0)
        return result
    }
}

@Serializable
data class ObjectWithEveryNullableTypeNestedObjectData(
    val id: String?,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant?,
    val data: ObjectWithEveryNullableTypeNestedObjectDataData?,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryNullableTypeNestedObjectData

        if (id != other.id) return false
        if(timestamp?.toEpochMilli() != other.timestamp?.toEpochMilli()) return false
        if (data != other.data) return false

        return true
    }

    override fun hashCode(): Int {
        var result = (id?.hashCode() ?: 0)
        result = 31 * result + (timestamp?.hashCode() ?: 0)
        result = 31 * result + (data?.hashCode() ?: 0)
        return result
    }
}

@Serializable
data class ObjectWithEveryNullableTypeNestedObjectDataData(
    val id: String?,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant?,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryNullableTypeNestedObjectDataData

        if (id != other.id) return false
        if(timestamp?.toEpochMilli() != other.timestamp?.toEpochMilli()) return false

        return true
    }

    override fun hashCode(): Int {
        var result = (id?.hashCode() ?: 0)
        result = 31 * result + (timestamp?.hashCode() ?: 0)
        return result
    }
}


@Serializable
data class ObjectWithEveryNullableTypeNestedArray(
    val id: String?,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant?,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryNullableTypeNestedArray

        if (id != other.id) return false
        if(timestamp?.toEpochMilli() != other.timestamp?.toEpochMilli()) return false

        return true
    }

    override fun hashCode(): Int {
        var result = (id?.hashCode() ?: 0)
        result = 31 * result + (timestamp?.hashCode() ?: 0)
        return result
    }
}


@Serializable
data class ObjectWithEveryOptionalType(
    val any: JsonElement? = null,
    val boolean: Boolean? = null,
    val string: String? = null,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant? = null,
    val float32: Float? = null,
    val float64: Double? = null,
    val int8: Byte? = null,
    val uint8: UByte? = null,
    val int16: Short? = null,
    val uint16: UShort? = null,
    val int32: Int? = null,
    val uint32: UInt? = null,
    val int64: Long? = null,
    val uint64: ULong? = null,
    val enumerator: ObjectWithEveryOptionalTypeEnumerator? = null,
    val array: List<Boolean>? = null,
    @SerialName("object")
    val _object: ObjectWithEveryOptionalTypeObject? = null,
    val record: Map<String, Boolean>? = null,
    val discriminator: ObjectWithEveryOptionalTypeDiscriminator? = null,
    val nestedObject: ObjectWithEveryOptionalTypeNestedObject? = null,
    val nestedArray: List<List<ObjectWithEveryOptionalTypeNestedArray>>? = null,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryOptionalType

        if (any != other.any) return false
        if (boolean != other.boolean) return false
        if (string != other.string) return false
        if(timestamp?.toEpochMilli() != other.timestamp?.toEpochMilli()) return false
        if (float32 != other.float32) return false
        if (float64 != other.float64) return false
        if (int8 != other.int8) return false
        if (uint8 != other.uint8) return false
        if (int16 != other.int16) return false
        if (uint16 != other.uint16) return false
        if (int32 != other.int32) return false
        if (uint32 != other.uint32) return false
        if (int64 != other.int64) return false
        if (uint64 != other.uint64) return false
        if (enumerator != other.enumerator) return false
        if (array != other.array) return false
        if (_object != other._object) return false
        if (record != other.record) return false
        if (discriminator != other.discriminator) return false
        if (nestedObject != other.nestedObject) return false
        if (nestedArray != other.nestedArray) return false

        return true
    }

    override fun hashCode(): Int {
        var result = (any?.hashCode() ?: 0)
        result = 31 * result + (boolean?.hashCode() ?: 0)
        result = 31 * result + (string?.hashCode() ?: 0)
        result = 31 * result + (timestamp?.hashCode() ?: 0)
        result = 31 * result + (float32?.hashCode() ?: 0)
        result = 31 * result + (float64?.hashCode() ?: 0)
        result = 31 * result + (int8?.hashCode() ?: 0)
        result = 31 * result + (uint8?.hashCode() ?: 0)
        result = 31 * result + (int16?.hashCode() ?: 0)
        result = 31 * result + (uint16?.hashCode() ?: 0)
        result = 31 * result + (int32?.hashCode() ?: 0)
        result = 31 * result + (uint32?.hashCode() ?: 0)
        result = 31 * result + (int64?.hashCode() ?: 0)
        result = 31 * result + (uint64?.hashCode() ?: 0)
        result = 31 * result + (enumerator?.hashCode() ?: 0)
        result = 31 * result + (array?.hashCode() ?: 0)
        result = 31 * result + (_object?.hashCode() ?: 0)
        result = 31 * result + (record?.hashCode() ?: 0)
        result = 31 * result + (discriminator?.hashCode() ?: 0)
        result = 31 * result + (nestedObject?.hashCode() ?: 0)
        result = 31 * result + (nestedArray?.hashCode() ?: 0)
        return result
    }
}

enum class ObjectWithEveryOptionalTypeEnumerator() {
    @SerialName("A")
    A,
    @SerialName("B")
    B,
    @SerialName("C")
    C,
}
@Serializable
data class ObjectWithEveryOptionalTypeObject(
    val string: String,
    val boolean: Boolean,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryOptionalTypeObject

        if (string != other.string) return false
        if (boolean != other.boolean) return false
        if (timestamp.toEpochMilli() != other.timestamp.toEpochMilli()) return false

        return true
    }

    override fun hashCode(): Int {
        var result = string.hashCode()
        result = 31 * result + boolean.hashCode()
        result = 31 * result + timestamp.hashCode()
        return result
    }
}


@Serializable
sealed class ObjectWithEveryOptionalTypeDiscriminator()

@Serializable
@SerialName("A")
data class ObjectWithEveryOptionalTypeDiscriminatorDiscriminatorA(
    val title: String,
) : ObjectWithEveryOptionalTypeDiscriminator()



@Serializable
@SerialName("B")
data class ObjectWithEveryOptionalTypeDiscriminatorDiscriminatorB(
    val title: String,
    val description: String,
) : ObjectWithEveryOptionalTypeDiscriminator()


@Serializable
data class ObjectWithEveryOptionalTypeNestedObject(
    val id: String,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant,
    val data: ObjectWithEveryOptionalTypeNestedObjectData,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryOptionalTypeNestedObject

        if (id != other.id) return false
        if (timestamp.toEpochMilli() != other.timestamp.toEpochMilli()) return false
        if (data != other.data) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + timestamp.hashCode()
        result = 31 * result + data.hashCode()
        return result
    }
}

@Serializable
data class ObjectWithEveryOptionalTypeNestedObjectData(
    val id: String,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant,
    val data: ObjectWithEveryOptionalTypeNestedObjectDataData,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryOptionalTypeNestedObjectData

        if (id != other.id) return false
        if (timestamp.toEpochMilli() != other.timestamp.toEpochMilli()) return false
        if (data != other.data) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + timestamp.hashCode()
        result = 31 * result + data.hashCode()
        return result
    }
}

@Serializable
data class ObjectWithEveryOptionalTypeNestedObjectDataData(
    val id: String,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryOptionalTypeNestedObjectDataData

        if (id != other.id) return false
        if (timestamp.toEpochMilli() != other.timestamp.toEpochMilli()) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + timestamp.hashCode()
        return result
    }
}


@Serializable
data class ObjectWithEveryOptionalTypeNestedArray(
    val id: String,
    @Serializable(with = InstantAsStringSerializer::class)
    val timestamp: Instant,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ObjectWithEveryOptionalTypeNestedArray

        if (id != other.id) return false
        if (timestamp.toEpochMilli() != other.timestamp.toEpochMilli()) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + timestamp.hashCode()
        return result
    }
}


@Serializable
data class RecursiveObject(
    val left: RecursiveObject?,
    val right: RecursiveObject?,
    val value: String,
)


@Serializable
sealed class RecursiveUnion()

@Serializable
@SerialName("CHILD")
data class RecursiveUnionChild(
    val data: RecursiveUnion,
) : RecursiveUnion()



@Serializable
@SerialName("CHILDREN")
data class RecursiveUnionChildren(
    val data: List<RecursiveUnion>,
) : RecursiveUnion()



@Serializable
@SerialName("TEXT")
data class RecursiveUnionText(
    val data: String,
) : RecursiveUnion()



@Serializable
@SerialName("SHAPE")
data class RecursiveUnionShape(
    val data: RecursiveUnionShapeData,
) : RecursiveUnion()

@Serializable
data class RecursiveUnionShapeData(
    val width: Double,
    val height: Double,
    val color: String,
)


@Serializable
data class AutoReconnectParams(
    val messageCount: UByte,
)


@Serializable
data class AutoReconnectResponse(
    val count: UByte,
    val message: String,
)


@Serializable
data class StreamConnectionErrorTestParams(
    val statusCode: UShort,
    val statusMessage: String,
)


@Serializable
data class StreamConnectionErrorTestResponse(
    val message: String,
)


@Serializable
data class StreamLargeObjectsResponse(
    val numbers: List<Double>,
    val objects: List<StreamLargeObjectsResponseObjects>,
)

@Serializable
data class StreamLargeObjectsResponseObjects(
    val id: String,
    val name: String,
    val email: String,
)


@Serializable
data class ChatMessageParams(
    val channelId: String,
)


@Serializable
sealed class ChatMessage()

@Serializable
@SerialName("TEXT")
data class ChatMessageText(
    val id: String,
    val channelId: String,
    val userId: String,
    @Serializable(with = InstantAsStringSerializer::class)
    val date: Instant,
    val text: String,
) : ChatMessage() {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ChatMessageText

        if (id != other.id) return false
        if (channelId != other.channelId) return false
        if (userId != other.userId) return false
        if (date.toEpochMilli() != other.date.toEpochMilli()) return false
        if (text != other.text) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + channelId.hashCode()
        result = 31 * result + userId.hashCode()
        result = 31 * result + date.hashCode()
        result = 31 * result + text.hashCode()
        return result
    }
}



@Serializable
@SerialName("IMAGE")
data class ChatMessageImage(
    val id: String,
    val channelId: String,
    val userId: String,
    @Serializable(with = InstantAsStringSerializer::class)
    val date: Instant,
    val image: String,
) : ChatMessage() {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ChatMessageImage

        if (id != other.id) return false
        if (channelId != other.channelId) return false
        if (userId != other.userId) return false
        if (date.toEpochMilli() != other.date.toEpochMilli()) return false
        if (image != other.image) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + channelId.hashCode()
        result = 31 * result + userId.hashCode()
        result = 31 * result + date.hashCode()
        result = 31 * result + image.hashCode()
        return result
    }
}



@Serializable
@SerialName("URL")
data class ChatMessageUrl(
    val id: String,
    val channelId: String,
    val userId: String,
    @Serializable(with = InstantAsStringSerializer::class)
    val date: Instant,
    val url: String,
) : ChatMessage() {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ChatMessageUrl

        if (id != other.id) return false
        if (channelId != other.channelId) return false
        if (userId != other.userId) return false
        if (date.toEpochMilli() != other.date.toEpochMilli()) return false
        if (url != other.url) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + channelId.hashCode()
        result = 31 * result + userId.hashCode()
        result = 31 * result + date.hashCode()
        result = 31 * result + url.hashCode()
        return result
    }
}


@Serializable
data class UsersWatchUserParams(
    val userId: String,
)


@Serializable
data class UsersWatchUserResponse(
    val id: String,
    val role: UsersWatchUserResponseRole,
    val photo: UserPhoto?,
    @Serializable(with = InstantAsStringSerializer::class)
    val createdAt: Instant,
    val numFollowers: Int,
    val settings: UserSettings,
    val recentNotifications: List<UsersWatchUserResponseRecentNotifications>,
    val bookmarks: Map<String, UsersWatchUserResponseBookmarks>,
    val metadata: Map<String, JsonElement>,
    val randomList: List<JsonElement>,
    val bio: String? = null,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as UsersWatchUserResponse

        if (id != other.id) return false
        if (role != other.role) return false
        if (photo != other.photo) return false
        if (createdAt.toEpochMilli() != other.createdAt.toEpochMilli()) return false
        if (numFollowers != other.numFollowers) return false
        if (settings != other.settings) return false
        if (recentNotifications != other.recentNotifications) return false
        if (bookmarks != other.bookmarks) return false
        if (metadata != other.metadata) return false
        if (randomList != other.randomList) return false
        if (bio != other.bio) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + role.hashCode()
        result = 31 * result + (photo?.hashCode() ?: 0)
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + numFollowers.hashCode()
        result = 31 * result + settings.hashCode()
        result = 31 * result + recentNotifications.hashCode()
        result = 31 * result + bookmarks.hashCode()
        result = 31 * result + metadata.hashCode()
        result = 31 * result + randomList.hashCode()
        result = 31 * result + (bio?.hashCode() ?: 0)
        return result
    }
}

enum class UsersWatchUserResponseRole() {
    @SerialName("standard")
    Standard,
    @SerialName("admin")
    Admin,
}
@Serializable
data class UserPhoto(
    val url: String,
    val width: Double,
    val height: Double,
    val bytes: Long,
    val nanoseconds: ULong,
)


@Serializable
data class UserSettings(
    val notificationsEnabled: Boolean,
    val preferredTheme: UserSettingsPreferredTheme,
)

enum class UserSettingsPreferredTheme() {
    @SerialName("dark-mode")
    DarkMode,
    @SerialName("light-mode")
    LightMode,
    @SerialName("system")
    System,
}
@Serializable
sealed class UsersWatchUserResponseRecentNotifications()

@Serializable
@SerialName("POST_LIKE")
data class UsersWatchUserResponseRecentNotificationsRecentNotificationsPostLike(
    val postId: String,
    val userId: String,
) : UsersWatchUserResponseRecentNotifications()



@Serializable
@SerialName("POST_COMMENT")
data class UsersWatchUserResponseRecentNotificationsRecentNotificationsPostComment(
    val postId: String,
    val userId: String,
    val commentText: String,
) : UsersWatchUserResponseRecentNotifications()


@Serializable
data class UsersWatchUserResponseBookmarks(
    val postId: String,
    val userId: String,
)



@Serializable
data class TestClientError(
    val code: Int,
    override val message: String,
    val data: JsonElement? = null,
    val stack: List<String>? = null,
): Exception()

object InstantAsStringSerializer : KSerializer<Instant> {
    override val descriptor: SerialDescriptor
        get() = PrimitiveSerialDescriptor("Instant", PrimitiveKind.STRING)

    override fun deserialize(decoder: Decoder): Instant {
        return Instant.parse(decoder.decodeString())
    }

    override fun serialize(encoder: Encoder, value: Instant) {
        return encoder.encodeString(value.toString())
    }
}

private suspend fun prepareRequest(
    client: HttpClient,
    url: String,
    method: HttpMethod,
    params: JsonElement?,
    headers: Map<String, String>?,
): HttpStatement {
    var finalUrl = url
    var finalBody = ""
    when (method) {
        HttpMethod.Get, HttpMethod.Head -> {
            val queryParts = mutableListOf<String>()
            params?.jsonObject?.entries?.forEach {
                queryParts.add("${it.key}=${it.value}")
            }
            finalUrl = "$finalUrl?${queryParts.joinToString("&")}"
        }

        HttpMethod.Post, HttpMethod.Put, HttpMethod.Patch, HttpMethod.Delete -> {
            finalBody = params?.toString() ?: ""
        }
    }
    val builder = HttpRequestBuilder()
    builder.method = method
    builder.url(finalUrl)
    builder.timeout {
        requestTimeoutMillis = 10 * 60 * 1000
    }
    builder.headers["client-version"] = "10"
    if (headers != null) {
        for (entry in headers.entries) {
            builder.headers[entry.key] = entry.value
        }
    }
    if (method != HttpMethod.Get && method != HttpMethod.Head) {
        builder.setBody(finalBody)
    }
    return client.prepareRequest(builder)
}

private fun parseSseEvent(input: String): SseEvent {
    val lines = input.split("\n")
    var id: String? = null
    var event: String? = null
    var data: String = ""
    for (line in lines) {
        if (line.startsWith("id: ")) {
            id = line.substring(3).trim()
            continue
        }
        if (line.startsWith("event: ")) {
            event = line.substring(6).trim()
            continue
        }
        if (line.startsWith("data: ")) {
            data = line.substring(5).trim()
            continue
        }
    }
    return SseEvent(id, event, data)
}

private class SseEvent(val id: String? = null, val event: String? = null, val data: String)

private fun parseSseEvents(input: String): List<SseEvent> {
    val inputs = input.split("\n\n")
    val events = mutableListOf<SseEvent>()
    for (item in inputs) {
        if (item.contains("data: ")) {
            events.add(parseSseEvent(item))
        }
    }
    return events
}


private suspend fun handleSseRequest(
    scope: CoroutineScope,
    httpClient: HttpClient,
    url: String,
    method: HttpMethod,
    params: JsonElement?,
    headers: Map<String, String> = mutableMapOf(),
    backoffTime: Long,
    maxBackoffTime: Long,
    lastEventId: String?,
    onOpen: ((response: HttpResponse) -> Unit) = {},
    onClose: (() -> Unit) = {},
    onError: ((error: TestClientError) -> Unit) = {},
    onData: ((data: String) -> Unit) = {},
    onConnectionError: ((error: TestClientError) -> Unit) = {},
    bufferCapacity: Int,
) {
    val finalHeaders = mutableMapOf<String, String>();
    for (entry in headers.entries) {
        finalHeaders[entry.key] = entry.value
    }
    var lastId = lastEventId
    // exponential backoff maxing out at 32 seconds
    if (backoffTime > 0) {
        withContext(scope.coroutineContext) {
            Thread.sleep(backoffTime)
        }
    }
    val newBackoffTime =
        if (backoffTime == 0L) 2L else if (backoffTime * 2L >= maxBackoffTime) maxBackoffTime else backoffTime * 2L
    if (lastId != null) {
        finalHeaders["Last-Event-ID"] = lastId.toString()
    }
    val request = prepareRequest(
        client = httpClient,
        url = url,
        method = HttpMethod.Get,
        params = params,
        headers = finalHeaders,
    )
    try {
        request.execute { httpResponse ->

            onOpen(httpResponse)
            if (httpResponse.status.value != 200) {

                onConnectionError(
                    TestClientError(
                        code = httpResponse.status.value,
                        message = "Error fetching stream",
                        data = JsonInstance.encodeToJsonElement(httpResponse),
                        stack = null,
                    )
                )
                handleSseRequest(
                    scope = scope,
                    httpClient = httpClient,
                    url = url,
                    method = method,
                    params = params,
                    headers = headers,
                    backoffTime = newBackoffTime,
                    maxBackoffTime = maxBackoffTime,
                    lastEventId = lastId,
                    bufferCapacity = bufferCapacity,
                    onOpen = onOpen,
                    onClose = onClose,
                    onError = onError,
                    onData = onData,
                    onConnectionError = onConnectionError,
                )
                return@execute
            }
            val channel: ByteReadChannel = httpResponse.bodyAsChannel()
            while (!channel.isClosedForRead) {
                val buffer = ByteBuffer.allocateDirect(bufferCapacity)
                val read = channel.readAvailable(buffer)
                if (read == -1) break;
                buffer.flip()
                val input = Charsets.UTF_8.decode(buffer).toString()
                val events = parseSseEvents(input)
                for (event in events) {
                    if (event.id != null) {
                        lastId = event.id
                    }
                    when (event.event) {
                        "message" -> {
                            onData(event.data)
                        }

                        "done" -> {
                            onClose()
                            return@execute
                        }

                        "error" -> {
                            val error = JsonInstance.decodeFromString<TestClientError>(event.data)
                            onError(error)
                        }

                        else -> {}
                    }
                }
            }
        }
    } catch (e: java.net.ConnectException) {
        onConnectionError(
            TestClientError(
                code = 503,
                message = if (e.message != null) e.message!! else "Error connecting to $url",
                data = JsonInstance.encodeToJsonElement(e.toString()),
                stack = e.stackTraceToString().split("\n"),
            )
        )
        handleSseRequest(
            scope = scope,
            httpClient = httpClient,
            url = url,
            method = method,
            params = params,
            headers = headers,
            backoffTime = newBackoffTime,
            maxBackoffTime = maxBackoffTime,
            lastEventId = lastId,
            bufferCapacity = bufferCapacity,
            onOpen = onOpen,
            onClose = onClose,
            onError = onError,
            onData = onData,
            onConnectionError = onConnectionError,
        )
        return
    } catch (e: Exception) {
        onConnectionError(
            TestClientError(
                code = 503,
                message = if (e.message != null) e.message!! else "Error connecting to $url",
                data = JsonInstance.encodeToJsonElement(e.toString()),
                stack = e.stackTraceToString().split("\n"),
            )
        )
        handleSseRequest(
            scope = scope,
            httpClient = httpClient,
            url = url,
            method = method,
            params = params,
            headers = headers,
            backoffTime = newBackoffTime,
            maxBackoffTime = maxBackoffTime,
            lastEventId = lastId,
            bufferCapacity = bufferCapacity,
            onOpen = onOpen,
            onClose = onClose,
            onError = onError,
            onData = onData,
            onConnectionError = onConnectionError,
        )
    }
}