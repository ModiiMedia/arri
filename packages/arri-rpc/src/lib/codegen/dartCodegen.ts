import { type TSchema, type TEnum, type TObject } from "@sinclair/typebox";
import { camelCase, pascalCase } from "scule";
import {
    type ApplicationDefinition,
    type ServiceDefinition,
    isProcedureDefinition,
    unflattenObject,
    jsonSchemaItemType,
} from "./utils";

/**
 * Tracking which model names we've already created classes for
 * to prevent duplication
 */
const generatedModels: string[] = [];

export function createDartClient(
    appDef: ApplicationDefinition,
    prefix = "Client"
) {
    const { models, procedures } = appDef;
    const serviceParts: Array<{
        name: string;
        key: string;
        content: string;
    }> = [];
    const services = unflattenObject(procedures) as Record<
        string,
        ServiceDefinition
    >;
    Object.keys(services).forEach((k) => {
        const service = services[k];
        const serviceName = pascalCase(`$_${prefix}_${k}_service`);
        serviceParts.push({
            name: serviceName,
            key: k,
            content: dartServiceFromServiceDefinition(
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                serviceName,
                service,
                prefix
            ),
        });
    });
    const endpoints: Record<string, string> = {};
    Object.keys(procedures).forEach((key) => {
        const rpc = procedures[key];
        endpoints[rpc.path] = rpc.method;
    });
    const modelParts: string[] = [];
    Object.keys(models).forEach((key) => {
        const model = models[key] as TSchema;
        if ("type" in model && model.type === "object") {
            const typeName = `${prefix}${pascalCase(key)}`;
            const objModel = model;
            if (!generatedModels.includes(typeName)) {
                modelParts.push(
                    dartModelFromJsonSchema(
                        `${prefix}${pascalCase(key)}`,
                        objModel as TObject
                    )
                );
                generatedModels.push(typeName);
            }
        }
    });
    return `// This code was autogenerated by arri. Do not modify directly.
import "dart:convert";
import "package:http/http.dart" as http;
import "package:arri_client/arri_client.dart";

class ${prefix} {
  final String baseUrl;
  final Map<String, String> headers;
  const ${prefix}({
    this.baseUrl = "",
    this.headers = const {},
  });
  ${prefix} withHeaders(Map<String, String> headers) {
    return ${prefix}(
      baseUrl: baseUrl,
      headers: headers,
    );
  }
  ${serviceParts
      .map(
          (service) => `${service.name} get ${service.key} {
    return ${service.name}(
      baseUrl: baseUrl, headers: headers,
    );
  }`
      )
      .join("\n  ")}
  Future<http.Response> rawRequest(
    ${prefix}Endpoints endpoint, {
    Map<String, String>? query,
    dynamic body,
    Map<String, String>? headers,
    Encoding? encoding,
  }) async {
    return arriRequest(
      "$baseUrl\${endpoint.path}",
      method: endpoint.method,
      headers: headers ?? this.headers,
      body: body,
      query: query,
      encoding: encoding,
    );
  }
}
${serviceParts.map((item) => item.content).join("\n")}
${modelParts.join("\n")}

enum ${prefix}Endpoints implements Comparable<${prefix}Endpoints>, ArriEndpoint {
  ${Object.keys(endpoints)
      .map(
          (key) => `${camelCase(key.split("/").join("_"))}(
        path: "${key}",
        method: HttpMethod.${endpoints[key]},
      )`
      )
      .join(",\n  ")};

  const ${prefix}Endpoints({
    required this.path, required this.method,
  });
  @override
  final String path;
  @override
  final HttpMethod method;

  @override
  compareTo(BackendEndpoints other) => name.compareTo(other.name);
}`;
}

export function dartServiceFromServiceDefinition(
    name: string,
    def: ServiceDefinition,
    prefix = ""
) {
    const rpcParts: string[] = [];
    const subServiceParts: Array<{
        name: string;
        key: string;
        content: string;
    }> = [];
    const serviceName = `${name}`;
    Object.keys(def).forEach((key) => {
        const item = def[key];
        if (isProcedureDefinition(item)) {
            let returnType:
                | `Future<String>`
                | "Future<int>"
                | "Future<number>"
                | "Future<void>"
                | `Future<${string}>` = `Future<String>`;
            let returnTypeName = "String";
            if (item.response) {
                returnType = `Future<${prefix}${item.response}>`;
                returnTypeName = `${prefix}${item.response}`;
            } else {
                returnType = "Future<void>";
            }
            let paramsInput = "";
            if (item.params) {
                paramsInput = `${prefix}${item.params} params`;
            }
            let responseParser: string = "(body) => body;";
            switch (returnType) {
                case "Future<String>":
                    break;
                case "Future<int>":
                    responseParser = `(body) => Int.parse(body)`;
                    break;
                case "Future<double>":
                    responseParser = `(body) => Double.parse(body)`;
                    break;
                case "Future<void>":
                    responseParser = `(body) {}`;
                    break;
                case "Future<bool>":
                    responseParser = `(body) {
                        switch(body) {
                            case "true":
                            case "1":
                                return true;
                            case "false":
                            case "0":
                            default:
                                return false;
                        }
                    }`;
                    break;
                default:
                    responseParser = `(body) => ${returnTypeName}.fromJson(json.decode(body))`;
                    break;
            }
            rpcParts.push(`${returnType} ${key}(${paramsInput}) {
    return parsedArriRequest(
      "$baseUrl${item.path}",
      method: HttpMethod.${item.method},
      headers: headers,
      params: ${paramsInput.length ? `params.toJson()` : "null"},
      parser: ${responseParser},
    );
  }`);
            return;
        }
        const subServiceName = pascalCase(`${name}_${key}_Service`);
        const subService = dartServiceFromServiceDefinition(
            pascalCase(`${name}_${key}_Service`),
            item,
            prefix
        );
        subServiceParts.push({
            name: subServiceName,
            key,
            content: subService,
        });
    });
    return `class ${serviceName} {
  final String baseUrl;
  final Map<String, String> headers;
  const ${serviceName}({
    this.baseUrl = "",
    this.headers = const {},
  });
  ${subServiceParts
      .map(
          (sub) => `${sub.name} get ${sub.key} {
    return ${sub.name}(
        baseUrl: baseUrl,
        headers: headers,
    );
  }`
      )
      .join("\n")}
  ${rpcParts.join("\n  ")}
}
${subServiceParts.map((sub) => sub.content).join("\n")}
`;
}

export function dartModelFromJsonSchema(name: string, schema: TObject): string {
    const fields: Array<{ type: string; name: string }> = [];
    const subModelParts: string[] = [];
    Object.entries(schema.properties).forEach(([key, val]) => {
        if (typeof val !== "object") {
            return;
        }
        const [dartType, subTypes] = dartPropertyTypeFromSchema(
            name,
            key,
            schema
        );

        if (subTypes?.length) {
            for (const sub of subTypes) {
                subModelParts.push(sub);
            }
        }
        fields.push({ type: dartType, name: key });
        if (!isDartType(dartType) && "type" in val && val.type === "object") {
            subModelParts.push(
                dartModelFromJsonSchema(
                    dartType.replace("?", ""),
                    val as TObject
                )
            );
        }
    });
    return `class ${name} {
  ${fields.map((field) => `final ${field.type} ${field.name};`).join("\n  ")}
  const ${name}({
    ${fields
        .map((field) =>
            field.type.includes("?")
                ? `this.${field.name},`
                : `required this.${field.name},`
        )
        .join("\n    ")}
  });
  factory ${name}.fromJson(Map<String, dynamic> json) {
    return ${name}(
      ${fields
          .map((field) => `${dartParsedJsonField(field.name, field.type)},`)
          .join("\n      ")}
    );
  }
  Map<String, dynamic> toJson() {
    return {
      ${fields
          .map((field) => {
              const isNullable = field.type.endsWith("?");
              const typeName = field.type.replace("?", "");
              if (isDartTypeWithNullables(field.type)) {
                  const transformer = transformers[typeName as DartType];
                  return transformer.toJsonBody(field.name, isNullable);
              }
              if (field.type.includes("List<")) {
                  return classListTransformer(typeName).toJsonBody(
                      field.name,
                      isNullable
                  );
              }
              return classTransformer(typeName, isNullable).toJsonBody(
                  field.name,
                  isNullable
              );
          })
          .join(",\n      ")},
    };
  }
  ${name} copyWith({
    ${fields
        .map((field) => `${field.type.replace("?", "")}? ${field.name},`)
        .join("\n    ")}
  }) {
    return ${name}(
      ${fields
          .map((field) => `${field.name}: ${field.name} ?? this.${field.name},`)
          .join("\n      ")}
    );
  }
}

${subModelParts.join("\n")}`;
}

export function dartPropertyTypeFromSchema(
    objectName: string,
    propertyName: string,
    schema: Omit<TObject, symbol>
): [DartType | string, string[] | undefined] {
    const prop = schema.properties[propertyName];
    const isOptional = !schema.required?.includes(propertyName);
    let finalType = "";
    const subTypes: string[] = [];
    if ((prop as TEnum).anyOf) {
        const enumName: string = pascalCase(`${objectName}_${propertyName}`);
        finalType = isOptional ? `${enumName}?` : enumName;
        const options: Array<{
            name: string;
            type: DartType;
            value: string | number;
        }> = [];
        for (const opt of (prop as TEnum).anyOf) {
            if (opt.type === "string") {
                options.push({
                    name: opt.const.toString(),
                    type: "String",
                    value: opt.const,
                });
            }
            if (opt.type === "number") {
                options.push({
                    name: camelCase(
                        `num_${opt.const}`.split(".").join("Point")
                    ),
                    type: "double",
                    value: opt.const,
                });
            }
        }
        subTypes.push(`enum ${enumName} implements Comparable<${enumName}> {
  ${options
      .map(
          (opt) =>
              `${opt.name}(${
                  opt.type === "String" ? `"${opt.value}"` : opt.value
              })`
      )
      .join(",\n  ")};
  const ${enumName}(this.value);
  final dynamic value;

  @override
  compareTo(${enumName} other) => name.compareTo(other.name);

  factory ${enumName}.fromJson(dynamic input) {
    for(final val in values) {
      if(val.value == input) {
        return val;
      }
    }
    return ${options[0].name};
  }

  dynamic toJson() {
    return value;
  }
}`);
        return [finalType, subTypes];
    }
    if (typeof prop.type === "string") {
        switch (prop.type) {
            case "string":
                finalType = isOptional ? "String?" : "String";
                break;
            case "integer":
                finalType = isOptional ? "int?" : "int";
                break;
            case "number":
                finalType = isOptional ? "double?" : "double";
                break;
            case "null":
                finalType = "null";
                break;
            case "Date":
                finalType = isOptional ? "DateTime?" : "DateTime";
                break;
            case "object": {
                const joinedPropName = pascalCase(
                    `${objectName}_${propertyName}`
                ) as string;
                finalType = isOptional ? `${joinedPropName}?` : joinedPropName;
                break;
            }
            case "boolean":
                finalType = isOptional ? "bool?" : "bool";
                break;
            case "array": {
                const item = prop.items;
                const type = item.type;
                if (typeof type !== "string") {
                    throw new Error(
                        "Union types are not supported in arrays at this time"
                    );
                }
                switch (type) {
                    case "string":
                        finalType = isOptional
                            ? "List<String>?"
                            : "List<String>";
                        break;
                    case "integer":
                        finalType = isOptional ? "List<int>?" : "List<int>";
                        break;
                    case "number":
                        finalType = isOptional
                            ? "List<double>?"
                            : "List<double>";
                        break;
                    case "null":
                        finalType = isOptional ? "List<null>?" : "List<null>";
                        break;
                    case "boolean":
                        finalType = isOptional ? "List<bool>?" : "List<bool>";
                        break;
                    case "Date":
                        finalType = isOptional
                            ? "List<DateTime>?"
                            : "List<DateTime>";
                        break;
                    case "object": {
                        const subTypeName =
                            (item as TObject).$id ??
                            pascalCase(`${objectName}_${propertyName}_item`);

                        const model = dartModelFromJsonSchema(
                            subTypeName,
                            item
                        );
                        if (!generatedModels.includes(subTypeName)) {
                            subTypes.push(model);
                            generatedModels.push(subTypeName);
                        }
                        finalType = isOptional
                            ? `List<${subTypeName}>?`
                            : `List<${subTypeName}>`;
                        break;
                    }
                }
                break;
            }
            default:
                break;
        }
    }
    return [finalType, subTypes.length ? subTypes : undefined];
}

export function dartParsedJsonField(fieldName: string, dartType: string) {
    if (isDartTypeWithNullables(dartType)) {
        switch (dartType) {
            case "String":
                return transformers.String.fromJsonBody(fieldName, '""');
            case "String?":
                return transformers.String.fromJsonBody(fieldName, "null");
            case "bool":
                return transformers.bool.fromJsonBody(fieldName, "false");
            case "double":
                return transformers.double.fromJsonBody(fieldName, "0.0");
            case "int":
                return transformers.int.fromJsonBody(fieldName, "0");
            case "null":
                return transformers.null.fromJsonBody(fieldName, "");
            case "DateTime":
                return transformers.DateTime.fromJsonBody(
                    fieldName,
                    "DateTime(0)"
                );
            case "DateTime?":
                return transformers.DateTime.fromJsonBody(fieldName, "null");
            case "List<String>":
            case "List<bool>":
            case "List<double>":
            case "List<int>":
            case "List<null>":
                return defaultListFromJsonBody(
                    fieldName,
                    dartType
                        .replace("List<", "")
                        .replace(">", "") as DartBaseType,
                    "[]"
                );
            default:
                return `${fieldName}: json["${fieldName}"] is ${dartType.replace(
                    "?",
                    ""
                )} ? json["${fieldName}"] : null`;
        }
    }
    if (dartType.includes("List<")) {
        const innerType = dartType
            .replace("List<", "")
            .replace(">", "")
            .replace("?", "");

        return classListTransformer(innerType).fromJsonBody(
            fieldName,
            dartType.endsWith("?") ? "null" : "[]"
        );
    }
    const classType = dartType.split("?").join("").trim();
    return classTransformer(classType, dartType.endsWith("?")).fromJsonBody(
        fieldName,
        classType
    );
}

type TypeMap = Record<jsonSchemaItemType, string | undefined>;

const dartTypeMap = {
    integer: "int",
    number: "double",
    string: "String",
    boolean: "bool",
    null: "null",
    Date: "DateTime",
    object: undefined,
    list: undefined,
} as const satisfies TypeMap;

interface DartMappedType {
    classBody?: string;
    fromJsonBody: (jsonKey: string, fallback: string) => string;
    toJsonBody: (key: string, isNullable?: boolean) => string;
}

export const transformers: Record<DartType, DartMappedType> = {
    null: {
        fromJsonBody: (_) => `null`,
        toJsonBody: defaultToJsonBody,
    },
    int: {
        fromJsonBody: (key, fallback) =>
            defaultFromJsonBody(key, "int", fallback),
        toJsonBody: defaultToJsonBody,
    },
    double: {
        fromJsonBody: (key, fallback) =>
            defaultFromJsonBody(key, "double", fallback),
        toJsonBody: defaultToJsonBody,
    },
    String: {
        fromJsonBody: (key, fallback) =>
            defaultFromJsonBody(key, "String", fallback),
        toJsonBody: defaultToJsonBody,
    },
    bool: {
        fromJsonBody: (key, fallback) =>
            defaultFromJsonBody(key, "bool", fallback),
        toJsonBody: defaultToJsonBody,
    },
    DateTime: {
        fromJsonBody: (key, fallback) =>
            `${key}: json["${key}"] is String ? DateTime.parse(json["${key}"]) : ${fallback}`,
        toJsonBody: (key, isNullable) =>
            `"${key}": ${key}${isNullable ? "?" : ""}.toIso8601String()`,
    },
    "List<null>": {
        fromJsonBody: (key, fallback) =>
            defaultListFromJsonBody(key, "null", fallback),
        toJsonBody: defaultToJsonBody,
    },
    "List<int>": {
        fromJsonBody: (key, fallback) =>
            defaultListFromJsonBody(key, "int", fallback),
        toJsonBody: defaultToJsonBody,
    },
    "List<double>": {
        fromJsonBody: (key, fallback) =>
            defaultListFromJsonBody(key, "double", fallback),
        toJsonBody: defaultToJsonBody,
    },
    "List<String>": {
        fromJsonBody: (key, fallback) =>
            defaultListFromJsonBody(key, "String", fallback),
        toJsonBody: defaultToJsonBody,
    },
    "List<bool>": {
        fromJsonBody: (key, fallback) =>
            defaultListFromJsonBody(key, "bool", fallback),
        toJsonBody: defaultToJsonBody,
    },
    "List<DateTime>": {
        fromJsonBody: (key, fallback) =>
            `${key}: json["${key}"] is List<String> ?
            (json["${key}"] as List<String>)
                .map((item) => DateTime.parse(item)).toList() : ${fallback}`,
        toJsonBody: (key, isNullable) =>
            `"${key}": ${key}${
                isNullable ? "?" : ""
            }.map((val) => val.toIso8601String()).toList()`,
    },
};

function defaultFromJsonBody(
    key: string,
    typename: DartType,
    fallback: string
) {
    return `${key}: json["${key}"] is ${typename} ? json["${key}"] : ${fallback}`;
}
function defaultListFromJsonBody(
    key: string,
    typename: DartBaseType,
    fallback: string
) {
    return `${key}: json["${key}"] is List<${typename}> ? json["${key}"] : ${fallback}`;
}
function defaultToJsonBody(key: string) {
    return `"${key}": ${key}`;
}

export const classTransformer = (
    typename: string,
    nullable: boolean
): DartMappedType => {
    return {
        fromJsonBody: (key, fallback) => {
            if (nullable) {
                return `${key}: json["${key}"] is Map<String, dynamic> ? 
                ${typename}.fromJson(json["${key}"]) : null`;
            }
            return `${key}: ${typename}.fromJson(json["${key}"])`;
        },
        toJsonBody: (key, isNullable) =>
            `"${key}": ${key}${isNullable ? "?" : ""}.toJson()`,
    };
};
export const classListTransformer = (typename: string): DartMappedType => {
    return {
        fromJsonBody: (key, fallback) => {
            return `${key}: json["${key}"] is List<Map<String, dynamic>> ? 
                (json["${key}"] as List<Map<String, dynamic>>)
                    .map((val) => ${typename}.fromJson(val)).toList() : ${fallback}`;
        },
        toJsonBody: (key, isNullable) =>
            `"${key}": ${key}${
                isNullable ? "?" : ""
            }.map((val) => val.toJson()).toList()`,
    };
};

export type DartBaseType = Exclude<
    (typeof dartTypeMap)[keyof typeof dartTypeMap],
    undefined
>;
export type DartType = DartBaseType | `List<${DartBaseType}>`;
export type DartTypeWithNullables = DartType | Exclude<`${DartType}?`, "null?">;
export function isDartType(input: any): input is DartType {
    if (typeof input !== "string") {
        return false;
    }
    for (const val of Object.values(dartTypeMap)) {
        if (input === val) {
            return true;
        }
        if (input.replace("List<", "").replace(">", "") === val) {
            return true;
        }
    }
    return false;
}
export function isDartTypeWithNullables(
    input: any
): input is DartTypeWithNullables {
    if (typeof input !== "string") {
        return false;
    }
    for (const val of Object.values(dartTypeMap)) {
        if (input.replace("?", "") === val) {
            return true;
        }
        if (
            input.replace("?", "").replace("List<", "").replace(">", "") === val
        ) {
            return true;
        }
    }
    return false;
}
