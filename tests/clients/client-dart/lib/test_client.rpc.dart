// this file was autogenerated by arri
// ignore_for_file: type=lint, unused_field
import "dart:convert";
import "package:arri_client/arri_client.dart";
import "package:http/http.dart" as http;

class TestClient {
  final http.Client? _httpClient;
  final String _baseUrl;
  final String _clientVersion = "10";
  late final Map<String, String> Function()? _headers;
  TestClient({
    http.Client? httpClient,
    String baseUrl = "",
    Map<String, String> Function()? headers,
  })  : _httpClient = httpClient,
        _baseUrl = baseUrl,
        _headers = headers;

  TestClientTestsService get tests {
    return TestClientTestsService(
      httpClient: _httpClient,
      baseUrl: _baseUrl,
      headers: _headers,
    );
  }

  TestClientAdaptersService get adapters {
    return TestClientAdaptersService(
      httpClient: _httpClient,
      baseUrl: _baseUrl,
      headers: _headers,
    );
  }
}

class TestClientTestsService {
  final http.Client? _httpClient;
  final String _baseUrl;
  final String _clientVersion = "10";
  late final Map<String, String> Function()? _headers;
  TestClientTestsService({
    http.Client? httpClient,
    String baseUrl = "",
    Map<String, String> Function()? headers,
  })  : _httpClient = httpClient,
        _baseUrl = baseUrl,
        _headers = headers;

  Future<DefaultPayload> emptyParamsGetRequest() {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/empty-params-get-request",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: null,
      parser: (body) => DefaultPayload.fromJson(
        json.decode(body),
      ),
      clientVersion: _clientVersion,
    );
  }

  Future<DefaultPayload> emptyParamsPostRequest() {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/empty-params-post-request",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: null,
      parser: (body) => DefaultPayload.fromJson(
        json.decode(body),
      ),
      clientVersion: _clientVersion,
    );
  }

  Future<void> emptyResponseGetRequest(DefaultPayload params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/empty-response-get-request",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) {},
      clientVersion: _clientVersion,
    );
  }

  Future<void> emptyResponsePostRequest(DefaultPayload params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/empty-response-post-request",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) {},
      clientVersion: _clientVersion,
    );
  }

  /// If the target language supports it. Generated code should mark this procedure as deprecated.
  @deprecated
  Future<void> deprecatedRpc(DeprecatedRpcParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/deprecated-rpc",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) {},
      clientVersion: _clientVersion,
    );
  }

  Future<ObjectWithEveryType> sendObject(ObjectWithEveryType params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/send-object",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => ObjectWithEveryType.fromJson(
        json.decode(body),
      ),
      clientVersion: _clientVersion,
    );
  }

  Future<ObjectWithEveryNullableType> sendObjectWithNullableFields(
      ObjectWithEveryNullableType params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/send-object-with-nullable-fields",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => ObjectWithEveryNullableType.fromJson(
        json.decode(body),
      ),
      clientVersion: _clientVersion,
    );
  }

  Future<ObjectWithEveryOptionalType> sendPartialObject(
      ObjectWithEveryOptionalType params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/send-partial-object",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => ObjectWithEveryOptionalType.fromJson(
        json.decode(body),
      ),
      clientVersion: _clientVersion,
    );
  }

  Future<RecursiveObject> sendRecursiveObject(RecursiveObject params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/send-recursive-object",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => RecursiveObject.fromJson(
        json.decode(body),
      ),
      clientVersion: _clientVersion,
    );
  }

  Future<RecursiveUnion> sendRecursiveUnion(RecursiveUnion params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/send-recursive-union",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => RecursiveUnion.fromJson(
        json.decode(body),
      ),
      clientVersion: _clientVersion,
    );
  }

  EventSource<AutoReconnectResponse> streamAutoReconnect(
    AutoReconnectParams params, {
    SseHookOnData<AutoReconnectResponse>? onData,
    SseHookOnError<AutoReconnectResponse>? onError,
    SseHookOnConnectionError<AutoReconnectResponse>? onConnectionError,
    SseHookOnOpen<AutoReconnectResponse>? onOpen,
    SseHookOnClose<AutoReconnectResponse>? onClose,
    String? lastEventId,
  }) {
    return parsedArriSseRequest<AutoReconnectResponse>(
      "$_baseUrl/rpcs/tests/stream-auto-reconnect",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => AutoReconnectResponse.fromJson(
        json.decode(body),
      ),
      onData: onData,
      onError: onError,
      onConnectionError: onConnectionError,
      onOpen: onOpen,
      onClose: onClose,
      lastEventId: lastEventId,
      clientVersion: _clientVersion,
    );
  }

  /// This route will always return an error. The client should automatically retry with exponential backoff.
  EventSource<StreamConnectionErrorTestResponse> streamConnectionErrorTest(
    StreamConnectionErrorTestParams params, {
    SseHookOnData<StreamConnectionErrorTestResponse>? onData,
    SseHookOnError<StreamConnectionErrorTestResponse>? onError,
    SseHookOnConnectionError<StreamConnectionErrorTestResponse>?
        onConnectionError,
    SseHookOnOpen<StreamConnectionErrorTestResponse>? onOpen,
    SseHookOnClose<StreamConnectionErrorTestResponse>? onClose,
    String? lastEventId,
  }) {
    return parsedArriSseRequest<StreamConnectionErrorTestResponse>(
      "$_baseUrl/rpcs/tests/stream-connection-error-test",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => StreamConnectionErrorTestResponse.fromJson(
        json.decode(body),
      ),
      onData: onData,
      onError: onError,
      onConnectionError: onConnectionError,
      onOpen: onOpen,
      onClose: onClose,
      lastEventId: lastEventId,
      clientVersion: _clientVersion,
    );
  }

  /// Test to ensure that the client can handle receiving streams of large objects. When objects are large messages will sometimes get sent in chunks. Meaning you have to handle receiving a partial message
  EventSource<StreamLargeObjectsResponse> streamLargeObjects({
    SseHookOnData<StreamLargeObjectsResponse>? onData,
    SseHookOnError<StreamLargeObjectsResponse>? onError,
    SseHookOnConnectionError<StreamLargeObjectsResponse>? onConnectionError,
    SseHookOnOpen<StreamLargeObjectsResponse>? onOpen,
    SseHookOnClose<StreamLargeObjectsResponse>? onClose,
    String? lastEventId,
  }) {
    return parsedArriSseRequest<StreamLargeObjectsResponse>(
      "$_baseUrl/rpcs/tests/stream-large-objects",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: null,
      parser: (body) => StreamLargeObjectsResponse.fromJson(
        json.decode(body),
      ),
      onData: onData,
      onError: onError,
      onConnectionError: onConnectionError,
      onOpen: onOpen,
      onClose: onClose,
      lastEventId: lastEventId,
      clientVersion: _clientVersion,
    );
  }

  EventSource<ChatMessage> streamMessages(
    ChatMessageParams params, {
    SseHookOnData<ChatMessage>? onData,
    SseHookOnError<ChatMessage>? onError,
    SseHookOnConnectionError<ChatMessage>? onConnectionError,
    SseHookOnOpen<ChatMessage>? onOpen,
    SseHookOnClose<ChatMessage>? onClose,
    String? lastEventId,
  }) {
    return parsedArriSseRequest<ChatMessage>(
      "$_baseUrl/rpcs/tests/stream-messages",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => ChatMessage.fromJson(
        json.decode(body),
      ),
      onData: onData,
      onError: onError,
      onConnectionError: onConnectionError,
      onOpen: onOpen,
      onClose: onClose,
      lastEventId: lastEventId,
      clientVersion: _clientVersion,
    );
  }

  EventSource<TestsStreamRetryWithNewCredentialsResponse>
      streamRetryWithNewCredentials({
    SseHookOnData<TestsStreamRetryWithNewCredentialsResponse>? onData,
    SseHookOnError<TestsStreamRetryWithNewCredentialsResponse>? onError,
    SseHookOnConnectionError<TestsStreamRetryWithNewCredentialsResponse>?
        onConnectionError,
    SseHookOnOpen<TestsStreamRetryWithNewCredentialsResponse>? onOpen,
    SseHookOnClose<TestsStreamRetryWithNewCredentialsResponse>? onClose,
    String? lastEventId,
  }) {
    return parsedArriSseRequest<TestsStreamRetryWithNewCredentialsResponse>(
      "$_baseUrl/rpcs/tests/stream-retry-with-new-credentials",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: null,
      parser: (body) => TestsStreamRetryWithNewCredentialsResponse.fromJson(
        json.decode(body),
      ),
      onData: onData,
      onError: onError,
      onConnectionError: onConnectionError,
      onOpen: onOpen,
      onClose: onClose,
      lastEventId: lastEventId,
      clientVersion: _clientVersion,
    );
  }

  /// When the client receives the 'done' event, it should close the connection and NOT reconnect
  EventSource<ChatMessage> streamTenEventsThenEnd({
    SseHookOnData<ChatMessage>? onData,
    SseHookOnError<ChatMessage>? onError,
    SseHookOnConnectionError<ChatMessage>? onConnectionError,
    SseHookOnOpen<ChatMessage>? onOpen,
    SseHookOnClose<ChatMessage>? onClose,
    String? lastEventId,
  }) {
    return parsedArriSseRequest<ChatMessage>(
      "$_baseUrl/rpcs/tests/stream-ten-events-then-end",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: null,
      parser: (body) => ChatMessage.fromJson(
        json.decode(body),
      ),
      onData: onData,
      onError: onError,
      onConnectionError: onConnectionError,
      onOpen: onOpen,
      onClose: onClose,
      lastEventId: lastEventId,
      clientVersion: _clientVersion,
    );
  }

  EventSource<ChatMessage> streamTenEventsThenError({
    SseHookOnData<ChatMessage>? onData,
    SseHookOnError<ChatMessage>? onError,
    SseHookOnConnectionError<ChatMessage>? onConnectionError,
    SseHookOnOpen<ChatMessage>? onOpen,
    SseHookOnClose<ChatMessage>? onClose,
    String? lastEventId,
  }) {
    return parsedArriSseRequest<ChatMessage>(
      "$_baseUrl/rpcs/tests/stream-ten-events-then-error",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: null,
      parser: (body) => ChatMessage.fromJson(
        json.decode(body),
      ),
      onData: onData,
      onError: onError,
      onConnectionError: onConnectionError,
      onOpen: onOpen,
      onClose: onClose,
      lastEventId: lastEventId,
      clientVersion: _clientVersion,
    );
  }

  Future<ArriWebsocketController<WsMessageResponse, WsMessageParams>>
      websocketRpc() {
    return arriWebsocketRequest<WsMessageResponse, WsMessageParams>(
      "$_baseUrl/rpcs/tests/websocket-rpc",
      headers: _headers,
      parser: (body) => WsMessageResponse.fromJson(json.decode(body)),
      serializer: (body) => json.encode(body.toJson()),
      clientVersion: _clientVersion,
    );
  }

  Future<ArriWebsocketController<StreamLargeObjectsResponse, Null>>
      websocketRpcSendTenLargeMessages() {
    return arriWebsocketRequest<StreamLargeObjectsResponse, Null>(
      "$_baseUrl/rpcs/tests/websocket-rpc-send-ten-large-messages",
      headers: _headers,
      parser: (body) => StreamLargeObjectsResponse.fromJson(json.decode(body)),
      serializer: (_) => "",
      clientVersion: _clientVersion,
    );
  }
}

class TestClientAdaptersService {
  final http.Client? _httpClient;
  final String _baseUrl;
  final String _clientVersion = "10";
  late final Map<String, String> Function()? _headers;
  TestClientAdaptersService({
    http.Client? httpClient,
    String baseUrl = "",
    Map<String, String> Function()? headers,
  })  : _httpClient = httpClient,
        _baseUrl = baseUrl,
        _headers = headers;

  Future<TypeBoxObject> typebox(TypeBoxObject params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/adapters/typebox",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => TypeBoxObject.fromJson(
        json.decode(body),
      ),
      clientVersion: _clientVersion,
    );
  }
}

class ManuallyAddedModel {
  final String hello;
  const ManuallyAddedModel({
    required this.hello,
  });
  factory ManuallyAddedModel.fromJson(Map<String, dynamic> json) {
    return ManuallyAddedModel(
      hello: typeFromDynamic<String>(json["hello"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "hello": hello,
    };

    return __result;
  }

  ManuallyAddedModel copyWith({
    String? hello,
  }) {
    return ManuallyAddedModel(
      hello: hello ?? this.hello,
    );
  }
}

class DefaultPayload {
  final String message;
  const DefaultPayload({
    required this.message,
  });
  factory DefaultPayload.fromJson(Map<String, dynamic> json) {
    return DefaultPayload(
      message: typeFromDynamic<String>(json["message"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "message": message,
    };

    return __result;
  }

  DefaultPayload copyWith({
    String? message,
  }) {
    return DefaultPayload(
      message: message ?? this.message,
    );
  }
}

class TypeBoxObject {
  final String string;
  final bool boolean;
  final int integer;
  final double number;
  final TypeBoxObjectEnumField enumField;
  final TypeBoxObjectObject object;
  final List<bool> array;
  final String? optionalString;
  const TypeBoxObject({
    required this.string,
    required this.boolean,
    required this.integer,
    required this.number,
    required this.enumField,
    required this.object,
    required this.array,
    this.optionalString,
  });
  factory TypeBoxObject.fromJson(Map<String, dynamic> json) {
    return TypeBoxObject(
      string: typeFromDynamic<String>(json["string"], ""),
      boolean: typeFromDynamic<bool>(json["boolean"], false),
      integer: intFromDynamic(json["integer"], 0),
      number: doubleFromDynamic(json["number"], 0),
      enumField: TypeBoxObjectEnumField.fromJson(json["enumField"]),
      object: TypeBoxObjectObject.fromJson(json["object"]),
      array: json["array"] is List
          ?
          // ignore: unnecessary_cast
          (json["array"] as List)
              .map((item) => typeFromDynamic<bool>(item, false))
              .toList() as List<bool>
          : <bool>[],
      optionalString: nullableTypeFromDynamic<String>(json["optionalString"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "integer": integer,
      "number": number,
      "enumField": enumField.value,
      "object": object.toJson(),
      "array": array.map((item) => item).toList(),
    };
    if (optionalString != null) {
      __result["optionalString"] = optionalString;
    }
    return __result;
  }

  TypeBoxObject copyWith({
    String? string,
    bool? boolean,
    int? integer,
    double? number,
    TypeBoxObjectEnumField? enumField,
    TypeBoxObjectObject? object,
    List<bool>? array,
    String? optionalString,
  }) {
    return TypeBoxObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      integer: integer ?? this.integer,
      number: number ?? this.number,
      enumField: enumField ?? this.enumField,
      object: object ?? this.object,
      array: array ?? this.array,
      optionalString: optionalString ?? this.optionalString,
    );
  }
}

enum TypeBoxObjectEnumField implements Comparable<TypeBoxObjectEnumField> {
  a("A"),
  b("B"),
  c("C");

  const TypeBoxObjectEnumField(this.value);
  final String value;

  factory TypeBoxObjectEnumField.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return a;
  }

  @override
  compareTo(TypeBoxObjectEnumField other) => name.compareTo(other.name);
}

class TypeBoxObjectObject {
  final String string;
  const TypeBoxObjectObject({
    required this.string,
  });
  factory TypeBoxObjectObject.fromJson(Map<String, dynamic> json) {
    return TypeBoxObjectObject(
      string: typeFromDynamic<String>(json["string"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "string": string,
    };

    return __result;
  }

  TypeBoxObjectObject copyWith({
    String? string,
  }) {
    return TypeBoxObjectObject(
      string: string ?? this.string,
    );
  }
}

@deprecated
class DeprecatedRpcParams {
  @deprecated
  final String deprecatedField;
  const DeprecatedRpcParams({
    required this.deprecatedField,
  });
  factory DeprecatedRpcParams.fromJson(Map<String, dynamic> json) {
    return DeprecatedRpcParams(
      deprecatedField: typeFromDynamic<String>(json["deprecatedField"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "deprecatedField": deprecatedField,
    };

    return __result;
  }

  DeprecatedRpcParams copyWith({
    String? deprecatedField,
  }) {
    return DeprecatedRpcParams(
      deprecatedField: deprecatedField ?? this.deprecatedField,
    );
  }
}

class ObjectWithEveryType {
  final dynamic any;
  final bool boolean;
  final String string;
  final DateTime timestamp;
  final double float32;
  final double float64;
  final int int8;
  final int uint8;
  final int int16;
  final int uint16;
  final int int32;
  final int uint32;
  final BigInt int64;
  final BigInt uint64;
  final ObjectWithEveryTypeEnumerator enumerator;
  final List<bool> array;
  final ObjectWithEveryTypeObject object;
  final Map<String, bool> record;
  final ObjectWithEveryTypeDiscriminator discriminator;
  final ObjectWithEveryTypeNestedObject nestedObject;
  final List<List<ObjectWithEveryTypeNestedArrayItemItem>> nestedArray;
  const ObjectWithEveryType({
    required this.any,
    required this.boolean,
    required this.string,
    required this.timestamp,
    required this.float32,
    required this.float64,
    required this.int8,
    required this.uint8,
    required this.int16,
    required this.uint16,
    required this.int32,
    required this.uint32,
    required this.int64,
    required this.uint64,
    required this.enumerator,
    required this.array,
    required this.object,
    required this.record,
    required this.discriminator,
    required this.nestedObject,
    required this.nestedArray,
  });
  factory ObjectWithEveryType.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryType(
      any: json["any"],
      boolean: typeFromDynamic<bool>(json["boolean"], false),
      string: typeFromDynamic<String>(json["string"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      float32: doubleFromDynamic(json["float32"], 0),
      float64: doubleFromDynamic(json["float64"], 0),
      int8: intFromDynamic(json["int8"], 0),
      uint8: intFromDynamic(json["uint8"], 0),
      int16: intFromDynamic(json["int16"], 0),
      uint16: intFromDynamic(json["uint16"], 0),
      int32: intFromDynamic(json["int32"], 0),
      uint32: intFromDynamic(json["uint32"], 0),
      int64: bigIntFromDynamic(json["int64"], BigInt.zero),
      uint64: bigIntFromDynamic(json["uint64"], BigInt.zero),
      enumerator: ObjectWithEveryTypeEnumerator.fromJson(json["enumerator"]),
      array: json["array"] is List
          ?
          // ignore: unnecessary_cast
          (json["array"] as List)
              .map((item) => typeFromDynamic<bool>(item, false))
              .toList() as List<bool>
          : <bool>[],
      object: ObjectWithEveryTypeObject.fromJson(json["object"]),
      record: json["record"] is Map<String, dynamic>
          ? (json["record"] as Map<String, dynamic>).map((key, value) =>
              MapEntry(key, typeFromDynamic<bool>(value, false)))
          : <String, bool>{},
      discriminator:
          ObjectWithEveryTypeDiscriminator.fromJson(json["discriminator"]),
      nestedObject:
          ObjectWithEveryTypeNestedObject.fromJson(json["nestedObject"]),
      nestedArray: json["nestedArray"] is List
          ?
          // ignore: unnecessary_cast
          (json["nestedArray"] as List)
              .map((item) => item is List
                  ?
                  // ignore: unnecessary_cast
                  (item as List)
                      .map((item) =>
                          ObjectWithEveryTypeNestedArrayItemItem.fromJson(item))
                      .toList() as List<ObjectWithEveryTypeNestedArrayItemItem>
                  : <ObjectWithEveryTypeNestedArrayItemItem>[])
              .toList() as List<List<ObjectWithEveryTypeNestedArrayItemItem>>
          : <List<ObjectWithEveryTypeNestedArrayItemItem>>[],
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "any": any,
      "boolean": boolean,
      "string": string,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "float32": float32,
      "float64": float64,
      "int8": int8,
      "uint8": uint8,
      "int16": int16,
      "uint16": uint16,
      "int32": int32,
      "uint32": uint32,
      "int64": int64.toString(),
      "uint64": uint64.toString(),
      "enumerator": enumerator.value,
      "array": array.map((item) => item).toList(),
      "object": object.toJson(),
      "record": record.map((key, value) => MapEntry(key, value)),
      "discriminator": discriminator.toJson(),
      "nestedObject": nestedObject.toJson(),
      "nestedArray": nestedArray
          .map((item) => item.map((item) => item.toJson()).toList())
          .toList(),
    };

    return __result;
  }

  ObjectWithEveryType copyWith({
    dynamic any,
    bool? boolean,
    String? string,
    DateTime? timestamp,
    double? float32,
    double? float64,
    int? int8,
    int? uint8,
    int? int16,
    int? uint16,
    int? int32,
    int? uint32,
    BigInt? int64,
    BigInt? uint64,
    ObjectWithEveryTypeEnumerator? enumerator,
    List<bool>? array,
    ObjectWithEveryTypeObject? object,
    Map<String, bool>? record,
    ObjectWithEveryTypeDiscriminator? discriminator,
    ObjectWithEveryTypeNestedObject? nestedObject,
    List<List<ObjectWithEveryTypeNestedArrayItemItem>>? nestedArray,
  }) {
    return ObjectWithEveryType(
      any: any ?? this.any,
      boolean: boolean ?? this.boolean,
      string: string ?? this.string,
      timestamp: timestamp ?? this.timestamp,
      float32: float32 ?? this.float32,
      float64: float64 ?? this.float64,
      int8: int8 ?? this.int8,
      uint8: uint8 ?? this.uint8,
      int16: int16 ?? this.int16,
      uint16: uint16 ?? this.uint16,
      int32: int32 ?? this.int32,
      uint32: uint32 ?? this.uint32,
      int64: int64 ?? this.int64,
      uint64: uint64 ?? this.uint64,
      enumerator: enumerator ?? this.enumerator,
      array: array ?? this.array,
      object: object ?? this.object,
      record: record ?? this.record,
      discriminator: discriminator ?? this.discriminator,
      nestedObject: nestedObject ?? this.nestedObject,
      nestedArray: nestedArray ?? this.nestedArray,
    );
  }
}

enum ObjectWithEveryTypeEnumerator
    implements Comparable<ObjectWithEveryTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryTypeEnumerator(this.value);
  final String value;

  factory ObjectWithEveryTypeEnumerator.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return a;
  }

  @override
  compareTo(ObjectWithEveryTypeEnumerator other) => name.compareTo(other.name);
}

class ObjectWithEveryTypeObject {
  final String string;
  final bool boolean;
  final DateTime timestamp;
  const ObjectWithEveryTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });
  factory ObjectWithEveryTypeObject.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryTypeObject(
      string: typeFromDynamic<String>(json["string"], ""),
      boolean: typeFromDynamic<bool>(json["boolean"], false),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

sealed class ObjectWithEveryTypeDiscriminator {
  final String type;
  const ObjectWithEveryTypeDiscriminator({
    required this.type,
  });
  factory ObjectWithEveryTypeDiscriminator.fromJson(Map<String, dynamic> json) {
    if (json["type"] is! String) {
      throw Exception(
        "Unable to decode ObjectWithEveryTypeDiscriminator. Expected String from \"type\". Received ${json["type"]}}",
      );
    }
    switch (json["type"]) {
      case "A":
        return ObjectWithEveryTypeDiscriminatorA.fromJson(json);
      case "B":
        return ObjectWithEveryTypeDiscriminatorB.fromJson(json);
    }
    throw Exception(
      "Unable to decode ObjectWithEveryTypeDiscriminator. \"${json["type"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class ObjectWithEveryTypeDiscriminatorA
    implements ObjectWithEveryTypeDiscriminator {
  @override
  final String type = "A";
  final String title;
  const ObjectWithEveryTypeDiscriminatorA({
    required this.title,
  });
  factory ObjectWithEveryTypeDiscriminatorA.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeDiscriminatorA(
      title: typeFromDynamic<String>(json["title"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return __result;
  }

  ObjectWithEveryTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return ObjectWithEveryTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }
}

class ObjectWithEveryTypeDiscriminatorB
    implements ObjectWithEveryTypeDiscriminator {
  @override
  final String type = "B";
  final String title;
  final String description;
  const ObjectWithEveryTypeDiscriminatorB({
    required this.title,
    required this.description,
  });
  factory ObjectWithEveryTypeDiscriminatorB.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeDiscriminatorB(
      title: typeFromDynamic<String>(json["title"], ""),
      description: typeFromDynamic<String>(json["description"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return __result;
  }

  ObjectWithEveryTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return ObjectWithEveryTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }
}

class ObjectWithEveryTypeNestedObject {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryTypeNestedObjectData data;
  const ObjectWithEveryTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryTypeNestedObject.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryTypeNestedObject(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      data: ObjectWithEveryTypeNestedObjectData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return __result;
  }

  ObjectWithEveryTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryTypeNestedObjectData? data,
  }) {
    return ObjectWithEveryTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryTypeNestedObjectData {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryTypeNestedObjectDataData data;
  const ObjectWithEveryTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryTypeNestedObjectData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeNestedObjectData(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      data: ObjectWithEveryTypeNestedObjectDataData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return __result;
  }

  ObjectWithEveryTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryTypeNestedObjectDataData? data,
  }) {
    return ObjectWithEveryTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryTypeNestedObjectDataData {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeNestedObjectDataData(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class ObjectWithEveryTypeNestedArrayItemItem {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryTypeNestedArrayItemItem({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryTypeNestedArrayItemItem.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeNestedArrayItemItem(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryTypeNestedArrayItemItem copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeNestedArrayItemItem(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class ObjectWithEveryNullableType {
  final dynamic any;
  final bool? boolean;
  final String? string;
  final DateTime? timestamp;
  final double? float32;
  final double? float64;
  final int? int8;
  final int? uint8;
  final int? int16;
  final int? uint16;
  final int? int32;
  final int? uint32;
  final BigInt? int64;
  final BigInt? uint64;
  final ObjectWithEveryNullableTypeEnumerator? enumerator;
  final List<bool?>? array;
  final ObjectWithEveryNullableTypeObject? object;
  final Map<String, bool?>? record;
  final ObjectWithEveryNullableTypeDiscriminator? discriminator;
  final ObjectWithEveryNullableTypeNestedObject? nestedObject;
  final List<List<ObjectWithEveryNullableTypeNestedArrayItemItem?>?>?
      nestedArray;
  const ObjectWithEveryNullableType({
    required this.any,
    required this.boolean,
    required this.string,
    required this.timestamp,
    required this.float32,
    required this.float64,
    required this.int8,
    required this.uint8,
    required this.int16,
    required this.uint16,
    required this.int32,
    required this.uint32,
    required this.int64,
    required this.uint64,
    required this.enumerator,
    required this.array,
    required this.object,
    required this.record,
    required this.discriminator,
    required this.nestedObject,
    required this.nestedArray,
  });
  factory ObjectWithEveryNullableType.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryNullableType(
      any: json["any"],
      boolean: nullableTypeFromDynamic<bool>(json["boolean"]),
      string: nullableTypeFromDynamic<String>(json["string"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
      float32: nullableDoubleFromDynamic(json["float32"]),
      float64: nullableDoubleFromDynamic(json["float64"]),
      int8: nullableIntFromDynamic(json["int8"]),
      uint8: nullableIntFromDynamic(json["uint8"]),
      int16: nullableIntFromDynamic(json["int16"]),
      uint16: nullableIntFromDynamic(json["uint16"]),
      int32: nullableIntFromDynamic(json["int32"]),
      uint32: nullableIntFromDynamic(json["uint32"]),
      int64: nullableBigIntFromDynamic(json["int64"]),
      uint64: nullableBigIntFromDynamic(json["uint64"]),
      enumerator: json["enumerator"] is String
          ? ObjectWithEveryNullableTypeEnumerator.fromJson(json["enumerator"])
          : null,
      array: json["array"] is List
          ?
          // ignore: unnecessary_cast
          (json["array"] as List)
              .map((item) => nullableTypeFromDynamic<bool>(item))
              .toList() as List<bool?>?
          : null,
      object: json["object"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeObject.fromJson(json["object"])
          : null,
      record: json["record"] is Map<String, dynamic>
          ? (json["record"] as Map<String, dynamic>).map((key, value) =>
              MapEntry(key, nullableTypeFromDynamic<bool>(value)))
          : <String, bool?>{},
      discriminator: json["discriminator"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeDiscriminator.fromJson(
              json["discriminator"])
          : null,
      nestedObject: json["nestedObject"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeNestedObject.fromJson(
              json["nestedObject"])
          : null,
      nestedArray: json["nestedArray"] is List
          ?
          // ignore: unnecessary_cast
          (json["nestedArray"] as List)
                  .map((item) => item is List
                      ?
                      // ignore: unnecessary_cast
                      (item as List)
                              .map((item) => item is Map<String, dynamic>
                                  ? ObjectWithEveryNullableTypeNestedArrayItemItem
                                      .fromJson(item)
                                  : null)
                              .toList()
                          as List<ObjectWithEveryNullableTypeNestedArrayItemItem?>?
                      : null)
                  .toList()
              as List<List<ObjectWithEveryNullableTypeNestedArrayItemItem?>?>?
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "any": any,
      "boolean": boolean,
      "string": string,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "float32": float32,
      "float64": float64,
      "int8": int8,
      "uint8": uint8,
      "int16": int16,
      "uint16": uint16,
      "int32": int32,
      "uint32": uint32,
      "int64": int64?.toString(),
      "uint64": uint64?.toString(),
      "enumerator": enumerator?.value,
      "array": array?.map((item) => item).toList(),
      "object": object?.toJson(),
      "record": record?.map((key, value) => MapEntry(key, value)),
      "discriminator": discriminator?.toJson(),
      "nestedObject": nestedObject?.toJson(),
      "nestedArray": nestedArray
          ?.map((item) => item?.map((item) => item?.toJson()).toList())
          .toList(),
    };

    return __result;
  }

  ObjectWithEveryNullableType copyWith({
    dynamic any,
    bool? boolean,
    String? string,
    DateTime? timestamp,
    double? float32,
    double? float64,
    int? int8,
    int? uint8,
    int? int16,
    int? uint16,
    int? int32,
    int? uint32,
    BigInt? int64,
    BigInt? uint64,
    ObjectWithEveryNullableTypeEnumerator? enumerator,
    List<bool?>? array,
    ObjectWithEveryNullableTypeObject? object,
    Map<String, bool?>? record,
    ObjectWithEveryNullableTypeDiscriminator? discriminator,
    ObjectWithEveryNullableTypeNestedObject? nestedObject,
    List<List<ObjectWithEveryNullableTypeNestedArrayItemItem?>?>? nestedArray,
  }) {
    return ObjectWithEveryNullableType(
      any: any ?? this.any,
      boolean: boolean ?? this.boolean,
      string: string ?? this.string,
      timestamp: timestamp ?? this.timestamp,
      float32: float32 ?? this.float32,
      float64: float64 ?? this.float64,
      int8: int8 ?? this.int8,
      uint8: uint8 ?? this.uint8,
      int16: int16 ?? this.int16,
      uint16: uint16 ?? this.uint16,
      int32: int32 ?? this.int32,
      uint32: uint32 ?? this.uint32,
      int64: int64 ?? this.int64,
      uint64: uint64 ?? this.uint64,
      enumerator: enumerator ?? this.enumerator,
      array: array ?? this.array,
      object: object ?? this.object,
      record: record ?? this.record,
      discriminator: discriminator ?? this.discriminator,
      nestedObject: nestedObject ?? this.nestedObject,
      nestedArray: nestedArray ?? this.nestedArray,
    );
  }
}

enum ObjectWithEveryNullableTypeEnumerator
    implements Comparable<ObjectWithEveryNullableTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryNullableTypeEnumerator(this.value);
  final String value;

  factory ObjectWithEveryNullableTypeEnumerator.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return a;
  }

  @override
  compareTo(ObjectWithEveryNullableTypeEnumerator other) =>
      name.compareTo(other.name);
}

class ObjectWithEveryNullableTypeObject {
  final String? string;
  final bool? boolean;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });
  factory ObjectWithEveryNullableTypeObject.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeObject(
      string: nullableTypeFromDynamic<String>(json["string"]),
      boolean: nullableTypeFromDynamic<bool>(json["boolean"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryNullableTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryNullableTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

sealed class ObjectWithEveryNullableTypeDiscriminator {
  final String type;
  const ObjectWithEveryNullableTypeDiscriminator({
    required this.type,
  });
  factory ObjectWithEveryNullableTypeDiscriminator.fromJson(
      Map<String, dynamic> json) {
    if (json["type"] is! String) {
      throw Exception(
        "Unable to decode ObjectWithEveryNullableTypeDiscriminator. Expected String from \"type\". Received ${json["type"]}}",
      );
    }
    switch (json["type"]) {
      case "A":
        return ObjectWithEveryNullableTypeDiscriminatorA.fromJson(json);
      case "B":
        return ObjectWithEveryNullableTypeDiscriminatorB.fromJson(json);
    }
    throw Exception(
      "Unable to decode ObjectWithEveryNullableTypeDiscriminator. \"${json["type"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class ObjectWithEveryNullableTypeDiscriminatorA
    implements ObjectWithEveryNullableTypeDiscriminator {
  @override
  final String type = "A";
  final String? title;
  const ObjectWithEveryNullableTypeDiscriminatorA({
    required this.title,
  });
  factory ObjectWithEveryNullableTypeDiscriminatorA.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeDiscriminatorA(
      title: nullableTypeFromDynamic<String>(json["title"]),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return __result;
  }

  ObjectWithEveryNullableTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return ObjectWithEveryNullableTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }
}

class ObjectWithEveryNullableTypeDiscriminatorB
    implements ObjectWithEveryNullableTypeDiscriminator {
  @override
  final String type = "B";
  final String? title;
  final String? description;
  const ObjectWithEveryNullableTypeDiscriminatorB({
    required this.title,
    required this.description,
  });
  factory ObjectWithEveryNullableTypeDiscriminatorB.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeDiscriminatorB(
      title: nullableTypeFromDynamic<String>(json["title"]),
      description: nullableTypeFromDynamic<String>(json["description"]),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return __result;
  }

  ObjectWithEveryNullableTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return ObjectWithEveryNullableTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }
}

class ObjectWithEveryNullableTypeNestedObject {
  final String? id;
  final DateTime? timestamp;
  final ObjectWithEveryNullableTypeNestedObjectData? data;
  const ObjectWithEveryNullableTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryNullableTypeNestedObject.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeNestedObject(
      id: nullableTypeFromDynamic<String>(json["id"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
      data: json["data"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeNestedObjectData.fromJson(json["data"])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "data": data?.toJson(),
    };

    return __result;
  }

  ObjectWithEveryNullableTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryNullableTypeNestedObjectData? data,
  }) {
    return ObjectWithEveryNullableTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryNullableTypeNestedObjectData {
  final String? id;
  final DateTime? timestamp;
  final ObjectWithEveryNullableTypeNestedObjectDataData? data;
  const ObjectWithEveryNullableTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryNullableTypeNestedObjectData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeNestedObjectData(
      id: nullableTypeFromDynamic<String>(json["id"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
      data: json["data"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
              json["data"])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "data": data?.toJson(),
    };

    return __result;
  }

  ObjectWithEveryNullableTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryNullableTypeNestedObjectDataData? data,
  }) {
    return ObjectWithEveryNullableTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryNullableTypeNestedObjectDataData {
  final String? id;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeNestedObjectDataData(
      id: nullableTypeFromDynamic<String>(json["id"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryNullableTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryNullableTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class ObjectWithEveryNullableTypeNestedArrayItemItem {
  final String? id;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeNestedArrayItemItem({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryNullableTypeNestedArrayItemItem.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeNestedArrayItemItem(
      id: nullableTypeFromDynamic<String>(json["id"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryNullableTypeNestedArrayItemItem copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryNullableTypeNestedArrayItemItem(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class ObjectWithEveryOptionalType {
  final dynamic any;
  final bool? boolean;
  final String? string;
  final DateTime? timestamp;
  final double? float32;
  final double? float64;
  final int? int8;
  final int? uint8;
  final int? int16;
  final int? uint16;
  final int? int32;
  final int? uint32;
  final BigInt? int64;
  final BigInt? uint64;
  final ObjectWithEveryOptionalTypeEnumerator? enumerator;
  final List<bool>? array;
  final ObjectWithEveryOptionalTypeObject? object;
  final Map<String, bool>? record;
  final ObjectWithEveryOptionalTypeDiscriminator? discriminator;
  final ObjectWithEveryOptionalTypeNestedObject? nestedObject;
  final List<List<ObjectWithEveryOptionalTypeNestedArrayItemItem>>? nestedArray;
  const ObjectWithEveryOptionalType({
    this.any,
    this.boolean,
    this.string,
    this.timestamp,
    this.float32,
    this.float64,
    this.int8,
    this.uint8,
    this.int16,
    this.uint16,
    this.int32,
    this.uint32,
    this.int64,
    this.uint64,
    this.enumerator,
    this.array,
    this.object,
    this.record,
    this.discriminator,
    this.nestedObject,
    this.nestedArray,
  });
  factory ObjectWithEveryOptionalType.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryOptionalType(
      any: json["any"],
      boolean: nullableTypeFromDynamic<bool>(json["boolean"]),
      string: nullableTypeFromDynamic<String>(json["string"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
      float32: nullableDoubleFromDynamic(json["float32"]),
      float64: nullableDoubleFromDynamic(json["float64"]),
      int8: nullableIntFromDynamic(json["int8"]),
      uint8: nullableIntFromDynamic(json["uint8"]),
      int16: nullableIntFromDynamic(json["int16"]),
      uint16: nullableIntFromDynamic(json["uint16"]),
      int32: nullableIntFromDynamic(json["int32"]),
      uint32: nullableIntFromDynamic(json["uint32"]),
      int64: nullableBigIntFromDynamic(json["int64"]),
      uint64: nullableBigIntFromDynamic(json["uint64"]),
      enumerator: json["enumerator"] is String
          ? ObjectWithEveryOptionalTypeEnumerator.fromJson(json["enumerator"])
          : null,
      array: json["array"] is List
          ?
          // ignore: unnecessary_cast
          (json["array"] as List)
              .map((item) => typeFromDynamic<bool>(item, false))
              .toList() as List<bool>?
          : null,
      object: json["object"] is Map<String, dynamic>
          ? ObjectWithEveryOptionalTypeObject.fromJson(json["object"])
          : null,
      record: json["record"] is Map<String, dynamic>
          ? (json["record"] as Map<String, dynamic>).map((key, value) =>
              MapEntry(key, typeFromDynamic<bool>(value, false)))
          : <String, bool>{},
      discriminator: json["discriminator"] is Map<String, dynamic>
          ? ObjectWithEveryOptionalTypeDiscriminator.fromJson(
              json["discriminator"])
          : null,
      nestedObject: json["nestedObject"] is Map<String, dynamic>
          ? ObjectWithEveryOptionalTypeNestedObject.fromJson(
              json["nestedObject"])
          : null,
      nestedArray: json["nestedArray"] is List
          ?
          // ignore: unnecessary_cast
          (json["nestedArray"] as List)
                  .map((item) => item is List
                      ?
                      // ignore: unnecessary_cast
                      (item as List)
                              .map((item) =>
                                  ObjectWithEveryOptionalTypeNestedArrayItemItem
                                      .fromJson(item))
                              .toList()
                          as List<ObjectWithEveryOptionalTypeNestedArrayItemItem>
                      : <ObjectWithEveryOptionalTypeNestedArrayItemItem>[])
                  .toList()
              as List<List<ObjectWithEveryOptionalTypeNestedArrayItemItem>>?
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{};
    if (any != null) {
      __result["any"] = any;
    }
    if (boolean != null) {
      __result["boolean"] = boolean;
    }
    if (string != null) {
      __result["string"] = string;
    }
    if (timestamp != null) {
      __result["timestamp"] = timestamp?.toUtc().toIso8601String();
    }
    if (float32 != null) {
      __result["float32"] = float32;
    }
    if (float64 != null) {
      __result["float64"] = float64;
    }
    if (int8 != null) {
      __result["int8"] = int8;
    }
    if (uint8 != null) {
      __result["uint8"] = uint8;
    }
    if (int16 != null) {
      __result["int16"] = int16;
    }
    if (uint16 != null) {
      __result["uint16"] = uint16;
    }
    if (int32 != null) {
      __result["int32"] = int32;
    }
    if (uint32 != null) {
      __result["uint32"] = uint32;
    }
    if (int64 != null) {
      __result["int64"] = int64?.toString();
    }
    if (uint64 != null) {
      __result["uint64"] = uint64?.toString();
    }
    if (enumerator != null) {
      __result["enumerator"] = enumerator?.value;
    }
    if (array != null) {
      __result["array"] = array?.map((item) => item).toList();
    }
    if (object != null) {
      __result["object"] = object?.toJson();
    }
    if (record != null) {
      __result["record"] = record?.map((key, value) => MapEntry(key, value));
    }
    if (discriminator != null) {
      __result["discriminator"] = discriminator?.toJson();
    }
    if (nestedObject != null) {
      __result["nestedObject"] = nestedObject?.toJson();
    }
    if (nestedArray != null) {
      __result["nestedArray"] = nestedArray
          ?.map((item) => item.map((item) => item.toJson()).toList())
          .toList();
    }
    return __result;
  }

  ObjectWithEveryOptionalType copyWith({
    dynamic any,
    bool? boolean,
    String? string,
    DateTime? timestamp,
    double? float32,
    double? float64,
    int? int8,
    int? uint8,
    int? int16,
    int? uint16,
    int? int32,
    int? uint32,
    BigInt? int64,
    BigInt? uint64,
    ObjectWithEveryOptionalTypeEnumerator? enumerator,
    List<bool>? array,
    ObjectWithEveryOptionalTypeObject? object,
    Map<String, bool>? record,
    ObjectWithEveryOptionalTypeDiscriminator? discriminator,
    ObjectWithEveryOptionalTypeNestedObject? nestedObject,
    List<List<ObjectWithEveryOptionalTypeNestedArrayItemItem>>? nestedArray,
  }) {
    return ObjectWithEveryOptionalType(
      any: any ?? this.any,
      boolean: boolean ?? this.boolean,
      string: string ?? this.string,
      timestamp: timestamp ?? this.timestamp,
      float32: float32 ?? this.float32,
      float64: float64 ?? this.float64,
      int8: int8 ?? this.int8,
      uint8: uint8 ?? this.uint8,
      int16: int16 ?? this.int16,
      uint16: uint16 ?? this.uint16,
      int32: int32 ?? this.int32,
      uint32: uint32 ?? this.uint32,
      int64: int64 ?? this.int64,
      uint64: uint64 ?? this.uint64,
      enumerator: enumerator ?? this.enumerator,
      array: array ?? this.array,
      object: object ?? this.object,
      record: record ?? this.record,
      discriminator: discriminator ?? this.discriminator,
      nestedObject: nestedObject ?? this.nestedObject,
      nestedArray: nestedArray ?? this.nestedArray,
    );
  }
}

enum ObjectWithEveryOptionalTypeEnumerator
    implements Comparable<ObjectWithEveryOptionalTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryOptionalTypeEnumerator(this.value);
  final String value;

  factory ObjectWithEveryOptionalTypeEnumerator.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return a;
  }

  @override
  compareTo(ObjectWithEveryOptionalTypeEnumerator other) =>
      name.compareTo(other.name);
}

class ObjectWithEveryOptionalTypeObject {
  final String string;
  final bool boolean;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });
  factory ObjectWithEveryOptionalTypeObject.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeObject(
      string: typeFromDynamic<String>(json["string"], ""),
      boolean: typeFromDynamic<bool>(json["boolean"], false),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryOptionalTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

sealed class ObjectWithEveryOptionalTypeDiscriminator {
  final String type;
  const ObjectWithEveryOptionalTypeDiscriminator({
    required this.type,
  });
  factory ObjectWithEveryOptionalTypeDiscriminator.fromJson(
      Map<String, dynamic> json) {
    if (json["type"] is! String) {
      throw Exception(
        "Unable to decode ObjectWithEveryOptionalTypeDiscriminator. Expected String from \"type\". Received ${json["type"]}}",
      );
    }
    switch (json["type"]) {
      case "A":
        return ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(json);
      case "B":
        return ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(json);
    }
    throw Exception(
      "Unable to decode ObjectWithEveryOptionalTypeDiscriminator. \"${json["type"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class ObjectWithEveryOptionalTypeDiscriminatorA
    implements ObjectWithEveryOptionalTypeDiscriminator {
  @override
  final String type = "A";
  final String title;
  const ObjectWithEveryOptionalTypeDiscriminatorA({
    required this.title,
  });
  factory ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeDiscriminatorA(
      title: typeFromDynamic<String>(json["title"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return __result;
  }

  ObjectWithEveryOptionalTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return ObjectWithEveryOptionalTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }
}

class ObjectWithEveryOptionalTypeDiscriminatorB
    implements ObjectWithEveryOptionalTypeDiscriminator {
  @override
  final String type = "B";
  final String title;
  final String description;
  const ObjectWithEveryOptionalTypeDiscriminatorB({
    required this.title,
    required this.description,
  });
  factory ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeDiscriminatorB(
      title: typeFromDynamic<String>(json["title"], ""),
      description: typeFromDynamic<String>(json["description"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return __result;
  }

  ObjectWithEveryOptionalTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return ObjectWithEveryOptionalTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }
}

class ObjectWithEveryOptionalTypeNestedObject {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryOptionalTypeNestedObjectData data;
  const ObjectWithEveryOptionalTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryOptionalTypeNestedObject.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeNestedObject(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      data: ObjectWithEveryOptionalTypeNestedObjectData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return __result;
  }

  ObjectWithEveryOptionalTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryOptionalTypeNestedObjectData? data,
  }) {
    return ObjectWithEveryOptionalTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryOptionalTypeNestedObjectData {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryOptionalTypeNestedObjectDataData data;
  const ObjectWithEveryOptionalTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryOptionalTypeNestedObjectData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeNestedObjectData(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      data: ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
          json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return __result;
  }

  ObjectWithEveryOptionalTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryOptionalTypeNestedObjectDataData? data,
  }) {
    return ObjectWithEveryOptionalTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryOptionalTypeNestedObjectDataData {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeNestedObjectDataData(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryOptionalTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class ObjectWithEveryOptionalTypeNestedArrayItemItem {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeNestedArrayItemItem({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryOptionalTypeNestedArrayItemItem.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeNestedArrayItemItem(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryOptionalTypeNestedArrayItemItem copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeNestedArrayItemItem(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class RecursiveObject {
  final RecursiveObject? left;
  final RecursiveObject? right;
  final String value;
  const RecursiveObject({
    required this.left,
    required this.right,
    required this.value,
  });
  factory RecursiveObject.fromJson(Map<String, dynamic> json) {
    return RecursiveObject(
      left: json["left"] is Map<String, dynamic>
          ? RecursiveObject.fromJson(json["left"])
          : null,
      right: json["right"] is Map<String, dynamic>
          ? RecursiveObject.fromJson(json["right"])
          : null,
      value: typeFromDynamic<String>(json["value"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "left": left?.toJson(),
      "right": right?.toJson(),
      "value": value,
    };

    return __result;
  }

  RecursiveObject copyWith({
    RecursiveObject? left,
    RecursiveObject? right,
    String? value,
  }) {
    return RecursiveObject(
      left: left ?? this.left,
      right: right ?? this.right,
      value: value ?? this.value,
    );
  }
}

sealed class RecursiveUnion {
  final String type;
  const RecursiveUnion({
    required this.type,
  });
  factory RecursiveUnion.fromJson(Map<String, dynamic> json) {
    if (json["type"] is! String) {
      throw Exception(
        "Unable to decode RecursiveUnion. Expected String from \"type\". Received ${json["type"]}}",
      );
    }
    switch (json["type"]) {
      case "CHILD":
        return RecursiveUnionChild.fromJson(json);
      case "CHILDREN":
        return RecursiveUnionChildren.fromJson(json);
      case "TEXT":
        return RecursiveUnionText.fromJson(json);
      case "SHAPE":
        return RecursiveUnionShape.fromJson(json);
    }
    throw Exception(
      "Unable to decode RecursiveUnion. \"${json["type"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class RecursiveUnionChild implements RecursiveUnion {
  @override
  final String type = "CHILD";
  final RecursiveUnion data;
  const RecursiveUnionChild({
    required this.data,
  });
  factory RecursiveUnionChild.fromJson(Map<String, dynamic> json) {
    return RecursiveUnionChild(
      data: RecursiveUnion.fromJson(json["data"]),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "data": data.toJson(),
    };

    return __result;
  }

  RecursiveUnionChild copyWith({
    RecursiveUnion? data,
  }) {
    return RecursiveUnionChild(
      data: data ?? this.data,
    );
  }
}

class RecursiveUnionChildren implements RecursiveUnion {
  @override
  final String type = "CHILDREN";
  final List<RecursiveUnion> data;
  const RecursiveUnionChildren({
    required this.data,
  });
  factory RecursiveUnionChildren.fromJson(Map<String, dynamic> json) {
    return RecursiveUnionChildren(
      data: json["data"] is List
          ?
          // ignore: unnecessary_cast
          (json["data"] as List)
              .map((item) => RecursiveUnion.fromJson(item))
              .toList() as List<RecursiveUnion>
          : <RecursiveUnion>[],
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "data": data.map((item) => item.toJson()).toList(),
    };

    return __result;
  }

  RecursiveUnionChildren copyWith({
    List<RecursiveUnion>? data,
  }) {
    return RecursiveUnionChildren(
      data: data ?? this.data,
    );
  }
}

class RecursiveUnionText implements RecursiveUnion {
  @override
  final String type = "TEXT";
  final String data;
  const RecursiveUnionText({
    required this.data,
  });
  factory RecursiveUnionText.fromJson(Map<String, dynamic> json) {
    return RecursiveUnionText(
      data: typeFromDynamic<String>(json["data"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "data": data,
    };

    return __result;
  }

  RecursiveUnionText copyWith({
    String? data,
  }) {
    return RecursiveUnionText(
      data: data ?? this.data,
    );
  }
}

class RecursiveUnionShape implements RecursiveUnion {
  @override
  final String type = "SHAPE";
  final RecursiveUnionShapeData data;
  const RecursiveUnionShape({
    required this.data,
  });
  factory RecursiveUnionShape.fromJson(Map<String, dynamic> json) {
    return RecursiveUnionShape(
      data: RecursiveUnionShapeData.fromJson(json["data"]),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "data": data.toJson(),
    };

    return __result;
  }

  RecursiveUnionShape copyWith({
    RecursiveUnionShapeData? data,
  }) {
    return RecursiveUnionShape(
      data: data ?? this.data,
    );
  }
}

class RecursiveUnionShapeData {
  final double width;
  final double height;
  final String color;
  const RecursiveUnionShapeData({
    required this.width,
    required this.height,
    required this.color,
  });
  factory RecursiveUnionShapeData.fromJson(Map<String, dynamic> json) {
    return RecursiveUnionShapeData(
      width: doubleFromDynamic(json["width"], 0),
      height: doubleFromDynamic(json["height"], 0),
      color: typeFromDynamic<String>(json["color"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "width": width,
      "height": height,
      "color": color,
    };

    return __result;
  }

  RecursiveUnionShapeData copyWith({
    double? width,
    double? height,
    String? color,
  }) {
    return RecursiveUnionShapeData(
      width: width ?? this.width,
      height: height ?? this.height,
      color: color ?? this.color,
    );
  }
}

class AutoReconnectParams {
  final int messageCount;
  const AutoReconnectParams({
    required this.messageCount,
  });
  factory AutoReconnectParams.fromJson(Map<String, dynamic> json) {
    return AutoReconnectParams(
      messageCount: intFromDynamic(json["messageCount"], 0),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "messageCount": messageCount,
    };

    return __result;
  }

  AutoReconnectParams copyWith({
    int? messageCount,
  }) {
    return AutoReconnectParams(
      messageCount: messageCount ?? this.messageCount,
    );
  }
}

class AutoReconnectResponse {
  final int count;
  final String message;
  const AutoReconnectResponse({
    required this.count,
    required this.message,
  });
  factory AutoReconnectResponse.fromJson(Map<String, dynamic> json) {
    return AutoReconnectResponse(
      count: intFromDynamic(json["count"], 0),
      message: typeFromDynamic<String>(json["message"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "count": count,
      "message": message,
    };

    return __result;
  }

  AutoReconnectResponse copyWith({
    int? count,
    String? message,
  }) {
    return AutoReconnectResponse(
      count: count ?? this.count,
      message: message ?? this.message,
    );
  }
}

class StreamConnectionErrorTestParams {
  final int statusCode;
  final String statusMessage;
  const StreamConnectionErrorTestParams({
    required this.statusCode,
    required this.statusMessage,
  });
  factory StreamConnectionErrorTestParams.fromJson(Map<String, dynamic> json) {
    return StreamConnectionErrorTestParams(
      statusCode: intFromDynamic(json["statusCode"], 0),
      statusMessage: typeFromDynamic<String>(json["statusMessage"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "statusCode": statusCode,
      "statusMessage": statusMessage,
    };

    return __result;
  }

  StreamConnectionErrorTestParams copyWith({
    int? statusCode,
    String? statusMessage,
  }) {
    return StreamConnectionErrorTestParams(
      statusCode: statusCode ?? this.statusCode,
      statusMessage: statusMessage ?? this.statusMessage,
    );
  }
}

class StreamConnectionErrorTestResponse {
  final String message;
  const StreamConnectionErrorTestResponse({
    required this.message,
  });
  factory StreamConnectionErrorTestResponse.fromJson(
      Map<String, dynamic> json) {
    return StreamConnectionErrorTestResponse(
      message: typeFromDynamic<String>(json["message"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "message": message,
    };

    return __result;
  }

  StreamConnectionErrorTestResponse copyWith({
    String? message,
  }) {
    return StreamConnectionErrorTestResponse(
      message: message ?? this.message,
    );
  }
}

class StreamLargeObjectsResponse {
  final List<double> numbers;
  final List<StreamLargeObjectsResponseObjectsItem> objects;
  const StreamLargeObjectsResponse({
    required this.numbers,
    required this.objects,
  });
  factory StreamLargeObjectsResponse.fromJson(Map<String, dynamic> json) {
    return StreamLargeObjectsResponse(
      numbers: json["numbers"] is List
          ?
          // ignore: unnecessary_cast
          (json["numbers"] as List)
              .map((item) => doubleFromDynamic(item, 0))
              .toList() as List<double>
          : <double>[],
      objects: json["objects"] is List
          ?
          // ignore: unnecessary_cast
          (json["objects"] as List)
              .map((item) =>
                  StreamLargeObjectsResponseObjectsItem.fromJson(item))
              .toList() as List<StreamLargeObjectsResponseObjectsItem>
          : <StreamLargeObjectsResponseObjectsItem>[],
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "numbers": numbers.map((item) => item).toList(),
      "objects": objects.map((item) => item.toJson()).toList(),
    };

    return __result;
  }

  StreamLargeObjectsResponse copyWith({
    List<double>? numbers,
    List<StreamLargeObjectsResponseObjectsItem>? objects,
  }) {
    return StreamLargeObjectsResponse(
      numbers: numbers ?? this.numbers,
      objects: objects ?? this.objects,
    );
  }
}

class StreamLargeObjectsResponseObjectsItem {
  final String id;
  final String name;
  final String email;
  const StreamLargeObjectsResponseObjectsItem({
    required this.id,
    required this.name,
    required this.email,
  });
  factory StreamLargeObjectsResponseObjectsItem.fromJson(
      Map<String, dynamic> json) {
    return StreamLargeObjectsResponseObjectsItem(
      id: typeFromDynamic<String>(json["id"], ""),
      name: typeFromDynamic<String>(json["name"], ""),
      email: typeFromDynamic<String>(json["email"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "name": name,
      "email": email,
    };

    return __result;
  }

  StreamLargeObjectsResponseObjectsItem copyWith({
    String? id,
    String? name,
    String? email,
  }) {
    return StreamLargeObjectsResponseObjectsItem(
      id: id ?? this.id,
      name: name ?? this.name,
      email: email ?? this.email,
    );
  }
}

class ChatMessageParams {
  final String channelId;
  const ChatMessageParams({
    required this.channelId,
  });
  factory ChatMessageParams.fromJson(Map<String, dynamic> json) {
    return ChatMessageParams(
      channelId: typeFromDynamic<String>(json["channelId"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "channelId": channelId,
    };

    return __result;
  }

  ChatMessageParams copyWith({
    String? channelId,
  }) {
    return ChatMessageParams(
      channelId: channelId ?? this.channelId,
    );
  }
}

sealed class ChatMessage {
  final String messageType;
  const ChatMessage({
    required this.messageType,
  });
  factory ChatMessage.fromJson(Map<String, dynamic> json) {
    if (json["messageType"] is! String) {
      throw Exception(
        "Unable to decode ChatMessage. Expected String from \"messageType\". Received ${json["messageType"]}}",
      );
    }
    switch (json["messageType"]) {
      case "TEXT":
        return ChatMessageText.fromJson(json);
      case "IMAGE":
        return ChatMessageImage.fromJson(json);
      case "URL":
        return ChatMessageUrl.fromJson(json);
    }
    throw Exception(
      "Unable to decode ChatMessage. \"${json["messageType"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class ChatMessageText implements ChatMessage {
  @override
  final String messageType = "TEXT";
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String text;
  const ChatMessageText({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.text,
  });
  factory ChatMessageText.fromJson(Map<String, dynamic> json) {
    return ChatMessageText(
      id: typeFromDynamic<String>(json["id"], ""),
      channelId: typeFromDynamic<String>(json["channelId"], ""),
      userId: typeFromDynamic<String>(json["userId"], ""),
      date: dateTimeFromDynamic(
        json["date"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      text: typeFromDynamic<String>(json["text"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "text": text,
    };

    return __result;
  }

  ChatMessageText copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? text,
  }) {
    return ChatMessageText(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      text: text ?? this.text,
    );
  }
}

class ChatMessageImage implements ChatMessage {
  @override
  final String messageType = "IMAGE";
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String image;
  const ChatMessageImage({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.image,
  });
  factory ChatMessageImage.fromJson(Map<String, dynamic> json) {
    return ChatMessageImage(
      id: typeFromDynamic<String>(json["id"], ""),
      channelId: typeFromDynamic<String>(json["channelId"], ""),
      userId: typeFromDynamic<String>(json["userId"], ""),
      date: dateTimeFromDynamic(
        json["date"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      image: typeFromDynamic<String>(json["image"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "image": image,
    };

    return __result;
  }

  ChatMessageImage copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? image,
  }) {
    return ChatMessageImage(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      image: image ?? this.image,
    );
  }
}

class ChatMessageUrl implements ChatMessage {
  @override
  final String messageType = "URL";
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String url;
  const ChatMessageUrl({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.url,
  });
  factory ChatMessageUrl.fromJson(Map<String, dynamic> json) {
    return ChatMessageUrl(
      id: typeFromDynamic<String>(json["id"], ""),
      channelId: typeFromDynamic<String>(json["channelId"], ""),
      userId: typeFromDynamic<String>(json["userId"], ""),
      date: dateTimeFromDynamic(
        json["date"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      url: typeFromDynamic<String>(json["url"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "url": url,
    };

    return __result;
  }

  ChatMessageUrl copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? url,
  }) {
    return ChatMessageUrl(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      url: url ?? this.url,
    );
  }
}

class TestsStreamRetryWithNewCredentialsResponse {
  final String message;
  const TestsStreamRetryWithNewCredentialsResponse({
    required this.message,
  });
  factory TestsStreamRetryWithNewCredentialsResponse.fromJson(
      Map<String, dynamic> json) {
    return TestsStreamRetryWithNewCredentialsResponse(
      message: typeFromDynamic<String>(json["message"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "message": message,
    };

    return __result;
  }

  TestsStreamRetryWithNewCredentialsResponse copyWith({
    String? message,
  }) {
    return TestsStreamRetryWithNewCredentialsResponse(
      message: message ?? this.message,
    );
  }
}

sealed class WsMessageParams {
  final String type;
  const WsMessageParams({
    required this.type,
  });
  factory WsMessageParams.fromJson(Map<String, dynamic> json) {
    if (json["type"] is! String) {
      throw Exception(
        "Unable to decode WsMessageParams. Expected String from \"type\". Received ${json["type"]}}",
      );
    }
    switch (json["type"]) {
      case "CREATE_ENTITY":
        return WsMessageParamsCreateEntity.fromJson(json);
      case "UPDATE_ENTITY":
        return WsMessageParamsUpdateEntity.fromJson(json);
      case "DISCONNECT":
        return WsMessageParamsDisconnect.fromJson(json);
    }
    throw Exception(
      "Unable to decode WsMessageParams. \"${json["type"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class WsMessageParamsCreateEntity implements WsMessageParams {
  @override
  final String type = "CREATE_ENTITY";
  final String entityId;
  final double x;
  final double y;
  const WsMessageParamsCreateEntity({
    required this.entityId,
    required this.x,
    required this.y,
  });
  factory WsMessageParamsCreateEntity.fromJson(Map<String, dynamic> json) {
    return WsMessageParamsCreateEntity(
      entityId: typeFromDynamic<String>(json["entityId"], ""),
      x: doubleFromDynamic(json["x"], 0),
      y: doubleFromDynamic(json["y"], 0),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "entityId": entityId,
      "x": x,
      "y": y,
    };

    return __result;
  }

  WsMessageParamsCreateEntity copyWith({
    String? entityId,
    double? x,
    double? y,
  }) {
    return WsMessageParamsCreateEntity(
      entityId: entityId ?? this.entityId,
      x: x ?? this.x,
      y: y ?? this.y,
    );
  }
}

class WsMessageParamsUpdateEntity implements WsMessageParams {
  @override
  final String type = "UPDATE_ENTITY";
  final String entityId;
  final double x;
  final double y;
  const WsMessageParamsUpdateEntity({
    required this.entityId,
    required this.x,
    required this.y,
  });
  factory WsMessageParamsUpdateEntity.fromJson(Map<String, dynamic> json) {
    return WsMessageParamsUpdateEntity(
      entityId: typeFromDynamic<String>(json["entityId"], ""),
      x: doubleFromDynamic(json["x"], 0),
      y: doubleFromDynamic(json["y"], 0),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "entityId": entityId,
      "x": x,
      "y": y,
    };

    return __result;
  }

  WsMessageParamsUpdateEntity copyWith({
    String? entityId,
    double? x,
    double? y,
  }) {
    return WsMessageParamsUpdateEntity(
      entityId: entityId ?? this.entityId,
      x: x ?? this.x,
      y: y ?? this.y,
    );
  }
}

class WsMessageParamsDisconnect implements WsMessageParams {
  @override
  final String type = "DISCONNECT";
  final String reason;
  const WsMessageParamsDisconnect({
    required this.reason,
  });
  factory WsMessageParamsDisconnect.fromJson(Map<String, dynamic> json) {
    return WsMessageParamsDisconnect(
      reason: typeFromDynamic<String>(json["reason"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "reason": reason,
    };

    return __result;
  }

  WsMessageParamsDisconnect copyWith({
    String? reason,
  }) {
    return WsMessageParamsDisconnect(
      reason: reason ?? this.reason,
    );
  }
}

sealed class WsMessageResponse {
  final String type;
  const WsMessageResponse({
    required this.type,
  });
  factory WsMessageResponse.fromJson(Map<String, dynamic> json) {
    if (json["type"] is! String) {
      throw Exception(
        "Unable to decode WsMessageResponse. Expected String from \"type\". Received ${json["type"]}}",
      );
    }
    switch (json["type"]) {
      case "ENTITY_CREATED":
        return WsMessageResponseEntityCreated.fromJson(json);
      case "ENTITY_UPDATED":
        return WsMessageResponseEntityUpdated.fromJson(json);
    }
    throw Exception(
      "Unable to decode WsMessageResponse. \"${json["type"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class WsMessageResponseEntityCreated implements WsMessageResponse {
  @override
  final String type = "ENTITY_CREATED";
  final String entityId;
  final double x;
  final double y;
  const WsMessageResponseEntityCreated({
    required this.entityId,
    required this.x,
    required this.y,
  });
  factory WsMessageResponseEntityCreated.fromJson(Map<String, dynamic> json) {
    return WsMessageResponseEntityCreated(
      entityId: typeFromDynamic<String>(json["entityId"], ""),
      x: doubleFromDynamic(json["x"], 0),
      y: doubleFromDynamic(json["y"], 0),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "entityId": entityId,
      "x": x,
      "y": y,
    };

    return __result;
  }

  WsMessageResponseEntityCreated copyWith({
    String? entityId,
    double? x,
    double? y,
  }) {
    return WsMessageResponseEntityCreated(
      entityId: entityId ?? this.entityId,
      x: x ?? this.x,
      y: y ?? this.y,
    );
  }
}

class WsMessageResponseEntityUpdated implements WsMessageResponse {
  @override
  final String type = "ENTITY_UPDATED";
  final String entityId;
  final double x;
  final double y;
  const WsMessageResponseEntityUpdated({
    required this.entityId,
    required this.x,
    required this.y,
  });
  factory WsMessageResponseEntityUpdated.fromJson(Map<String, dynamic> json) {
    return WsMessageResponseEntityUpdated(
      entityId: typeFromDynamic<String>(json["entityId"], ""),
      x: doubleFromDynamic(json["x"], 0),
      y: doubleFromDynamic(json["y"], 0),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "entityId": entityId,
      "x": x,
      "y": y,
    };

    return __result;
  }

  WsMessageResponseEntityUpdated copyWith({
    String? entityId,
    double? x,
    double? y,
  }) {
    return WsMessageResponseEntityUpdated(
      entityId: entityId ?? this.entityId,
      x: x ?? this.x,
      y: y ?? this.y,
    );
  }
}
