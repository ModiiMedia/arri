// This file was autogenerated by @arrirpc/codegen-ts. Do not modify directly.
// For more information visit https://github.com/modiimedia/arri

/* eslint-disable */
// @ts-nocheck
import {
    ArriEnumValidator,
    ArriModelValidator,
    arriRequest,
    arriSseRequest,
    arriWsRequest,
    type EventSourceController,
    INT8_MAX,
    INT8_MIN,
    INT16_MAX,
    INT16_MIN,
    INT32_MAX,
    INT32_MIN,
    INT64_MAX,
    INT64_MIN,
    isObject,
    serializeString,
    type SseOptions,
    UINT8_MAX,
    UINT16_MAX,
    UINT32_MAX,
    UINT64_MAX,
    type WsController,
    type WsOptions,
} from "@arrirpc/client";

type HeaderMap = Record<string, string | undefined>;
export class TestClient {
    private readonly _baseUrl: string;
    private readonly _headers:
        | HeaderMap
        | (() => HeaderMap | Promise<HeaderMap>);
    tests: TestClientTestsService;
    adapters: TestClientAdaptersService;
    users: TestClientUsersService;
    constructor(
        options: {
            baseUrl?: string;
            headers?: HeaderMap | (() => HeaderMap | Promise<HeaderMap>);
        } = {},
    ) {
        this._baseUrl = options.baseUrl ?? "";
        this._headers = options.headers ?? {};
        this.tests = new TestClientTestsService(options);
        this.adapters = new TestClientAdaptersService(options);
        this.users = new TestClientUsersService(options);
    }
}

export class TestClientTestsService {
    private readonly _baseUrl: string;
    private readonly _headers:
        | HeaderMap
        | (() => HeaderMap | Promise<HeaderMap>);

    constructor(
        options: {
            baseUrl?: string;
            headers?: HeaderMap | (() => HeaderMap | Promise<HeaderMap>);
        } = {},
    ) {
        this._baseUrl = options.baseUrl ?? "";
        this._headers = options.headers ?? {};
    }
    async emptyParamsGetRequest(): Promise<DefaultPayload> {
        return arriRequest<DefaultPayload, undefined>({
            url: `${this._baseUrl}/rpcs/tests/empty-params-get-request`,
            method: "get",
            headers: this._headers,

            responseFromJson: $$DefaultPayload.fromJson,
            responseFromString: $$DefaultPayload.fromJsonString,
            serializer: () => {},
            clientVersion: "10",
        });
    }
    async emptyParamsPostRequest(): Promise<DefaultPayload> {
        return arriRequest<DefaultPayload, undefined>({
            url: `${this._baseUrl}/rpcs/tests/empty-params-post-request`,
            method: "post",
            headers: this._headers,

            responseFromJson: $$DefaultPayload.fromJson,
            responseFromString: $$DefaultPayload.fromJsonString,
            serializer: () => {},
            clientVersion: "10",
        });
    }
    async emptyResponseGetRequest(params: DefaultPayload): Promise<undefined> {
        return arriRequest<undefined, DefaultPayload>({
            url: `${this._baseUrl}/rpcs/tests/empty-response-get-request`,
            method: "get",
            headers: this._headers,
            params: params,
            responseFromJson: () => {},
            responseFromString: () => {},
            serializer: $$DefaultPayload.toUrlQueryString,
            clientVersion: "10",
        });
    }
    async emptyResponsePostRequest(params: DefaultPayload): Promise<undefined> {
        return arriRequest<undefined, DefaultPayload>({
            url: `${this._baseUrl}/rpcs/tests/empty-response-post-request`,
            method: "post",
            headers: this._headers,
            params: params,
            responseFromJson: () => {},
            responseFromString: () => {},
            serializer: $$DefaultPayload.toJsonString,
            clientVersion: "10",
        });
    }
    async deprecatedRpc(params: DeprecatedRpcParams): Promise<undefined> {
        return arriRequest<undefined, DeprecatedRpcParams>({
            url: `${this._baseUrl}/rpcs/tests/deprecated-rpc`,
            method: "post",
            headers: this._headers,
            params: params,
            responseFromJson: () => {},
            responseFromString: () => {},
            serializer: $$DeprecatedRpcParams.toJsonString,
            clientVersion: "10",
        });
    }
    async sendError(params: SendErrorParams): Promise<undefined> {
        return arriRequest<undefined, SendErrorParams>({
            url: `${this._baseUrl}/rpcs/tests/send-error`,
            method: "post",
            headers: this._headers,
            params: params,
            responseFromJson: () => {},
            responseFromString: () => {},
            serializer: $$SendErrorParams.toJsonString,
            clientVersion: "10",
        });
    }
    async sendObject(
        params: ObjectWithEveryType,
    ): Promise<ObjectWithEveryType> {
        return arriRequest<ObjectWithEveryType, ObjectWithEveryType>({
            url: `${this._baseUrl}/rpcs/tests/send-object`,
            method: "post",
            headers: this._headers,
            params: params,
            responseFromJson: $$ObjectWithEveryType.fromJson,
            responseFromString: $$ObjectWithEveryType.fromJsonString,
            serializer: $$ObjectWithEveryType.toJsonString,
            clientVersion: "10",
        });
    }
    async sendObjectWithNullableFields(
        params: ObjectWithEveryNullableType,
    ): Promise<ObjectWithEveryNullableType> {
        return arriRequest<
            ObjectWithEveryNullableType,
            ObjectWithEveryNullableType
        >({
            url: `${this._baseUrl}/rpcs/tests/send-object-with-nullable-fields`,
            method: "post",
            headers: this._headers,
            params: params,
            responseFromJson: $$ObjectWithEveryNullableType.fromJson,
            responseFromString: $$ObjectWithEveryNullableType.fromJsonString,
            serializer: $$ObjectWithEveryNullableType.toJsonString,
            clientVersion: "10",
        });
    }
    async sendPartialObject(
        params: ObjectWithEveryOptionalType,
    ): Promise<ObjectWithEveryOptionalType> {
        return arriRequest<
            ObjectWithEveryOptionalType,
            ObjectWithEveryOptionalType
        >({
            url: `${this._baseUrl}/rpcs/tests/send-partial-object`,
            method: "post",
            headers: this._headers,
            params: params,
            responseFromJson: $$ObjectWithEveryOptionalType.fromJson,
            responseFromString: $$ObjectWithEveryOptionalType.fromJsonString,
            serializer: $$ObjectWithEveryOptionalType.toJsonString,
            clientVersion: "10",
        });
    }
    async sendRecursiveObject(
        params: RecursiveObject,
    ): Promise<RecursiveObject> {
        return arriRequest<RecursiveObject, RecursiveObject>({
            url: `${this._baseUrl}/rpcs/tests/send-recursive-object`,
            method: "post",
            headers: this._headers,
            params: params,
            responseFromJson: $$RecursiveObject.fromJson,
            responseFromString: $$RecursiveObject.fromJsonString,
            serializer: $$RecursiveObject.toJsonString,
            clientVersion: "10",
        });
    }
    async sendRecursiveUnion(params: RecursiveUnion): Promise<RecursiveUnion> {
        return arriRequest<RecursiveUnion, RecursiveUnion>({
            url: `${this._baseUrl}/rpcs/tests/send-recursive-union`,
            method: "post",
            headers: this._headers,
            params: params,
            responseFromJson: $$RecursiveUnion.fromJson,
            responseFromString: $$RecursiveUnion.fromJsonString,
            serializer: $$RecursiveUnion.toJsonString,
            clientVersion: "10",
        });
    }
    streamAutoReconnect(
        params: AutoReconnectParams,
        options: SseOptions<AutoReconnectResponse> = {},
    ): EventSourceController {
        return arriSseRequest<AutoReconnectResponse, AutoReconnectParams>(
            {
                url: `${this._baseUrl}/rpcs/tests/stream-auto-reconnect`,
                method: "get",
                headers: this._headers,
                params: params,
                responseFromJson: $$AutoReconnectResponse.fromJson,
                responseFromString: $$AutoReconnectResponse.fromJsonString,
                serializer: $$AutoReconnectParams.toUrlQueryString,
                clientVersion: "10",
            },
            options,
        );
    }
    streamConnectionErrorTest(
        params: StreamConnectionErrorTestParams,
        options: SseOptions<StreamConnectionErrorTestResponse> = {},
    ): EventSourceController {
        return arriSseRequest<
            StreamConnectionErrorTestResponse,
            StreamConnectionErrorTestParams
        >(
            {
                url: `${this._baseUrl}/rpcs/tests/stream-connection-error-test`,
                method: "get",
                headers: this._headers,
                params: params,
                responseFromJson: $$StreamConnectionErrorTestResponse.fromJson,
                responseFromString:
                    $$StreamConnectionErrorTestResponse.fromJsonString,
                serializer: $$StreamConnectionErrorTestParams.toUrlQueryString,
                clientVersion: "10",
            },
            options,
        );
    }
    streamLargeObjects(
        options: SseOptions<StreamLargeObjectsResponse> = {},
    ): EventSourceController {
        return arriSseRequest<StreamLargeObjectsResponse, undefined>(
            {
                url: `${this._baseUrl}/rpcs/tests/stream-large-objects`,
                method: "get",
                headers: this._headers,

                responseFromJson: $$StreamLargeObjectsResponse.fromJson,
                responseFromString: $$StreamLargeObjectsResponse.fromJsonString,
                serializer: () => {},
                clientVersion: "10",
            },
            options,
        );
    }
    streamMessages(
        params: ChatMessageParams,
        options: SseOptions<ChatMessage> = {},
    ): EventSourceController {
        return arriSseRequest<ChatMessage, ChatMessageParams>(
            {
                url: `${this._baseUrl}/rpcs/tests/stream-messages`,
                method: "get",
                headers: this._headers,
                params: params,
                responseFromJson: $$ChatMessage.fromJson,
                responseFromString: $$ChatMessage.fromJsonString,
                serializer: $$ChatMessageParams.toUrlQueryString,
                clientVersion: "10",
            },
            options,
        );
    }
    streamRetryWithNewCredentials(
        options: SseOptions<TestsStreamRetryWithNewCredentialsResponse> = {},
    ): EventSourceController {
        return arriSseRequest<
            TestsStreamRetryWithNewCredentialsResponse,
            undefined
        >(
            {
                url: `${this._baseUrl}/rpcs/tests/stream-retry-with-new-credentials`,
                method: "get",
                headers: this._headers,

                responseFromJson:
                    $$TestsStreamRetryWithNewCredentialsResponse.fromJson,
                responseFromString:
                    $$TestsStreamRetryWithNewCredentialsResponse.fromJsonString,
                serializer: () => {},
                clientVersion: "10",
            },
            options,
        );
    }
    streamTenEventsThenEnd(
        options: SseOptions<ChatMessage> = {},
    ): EventSourceController {
        return arriSseRequest<ChatMessage, undefined>(
            {
                url: `${this._baseUrl}/rpcs/tests/stream-ten-events-then-end`,
                method: "get",
                headers: this._headers,

                responseFromJson: $$ChatMessage.fromJson,
                responseFromString: $$ChatMessage.fromJsonString,
                serializer: () => {},
                clientVersion: "10",
            },
            options,
        );
    }
    async websocketRpc(
        options: WsOptions<WsMessageResponse> = {},
    ): Promise<WsController<WsMessageParams, WsMessageResponse>> {
        return arriWsRequest<WsMessageParams, WsMessageResponse>({
            url: `${this._baseUrl}/rpcs/tests/websocket-rpc`,
            headers: this._headers,
            responseFromJson: $$WsMessageResponse.fromJson,
            responseFromString: $$WsMessageResponse.fromJsonString,
            serializer: $$WsMessageParams.toJsonString,
            onOpen: options.onOpen,
            onClose: options.onClose,
            onError: options.onError,
            onConnectionError: options.onConnectionError,
            onMessage: options.onMessage,
            clientVersion: "10",
        });
    }
    async websocketRpcSendTenLargeMessages(
        options: WsOptions<StreamLargeObjectsResponse> = {},
    ): Promise<WsController<undefined, StreamLargeObjectsResponse>> {
        return arriWsRequest<undefined, StreamLargeObjectsResponse>({
            url: `${this._baseUrl}/rpcs/tests/websocket-rpc-send-ten-large-messages`,
            headers: this._headers,
            responseFromJson: $$StreamLargeObjectsResponse.fromJson,
            responseFromString: $$StreamLargeObjectsResponse.fromJsonString,
            serializer: () => {},
            onOpen: options.onOpen,
            onClose: options.onClose,
            onError: options.onError,
            onConnectionError: options.onConnectionError,
            onMessage: options.onMessage,
            clientVersion: "10",
        });
    }
}

export class TestClientAdaptersService {
    private readonly _baseUrl: string;
    private readonly _headers:
        | HeaderMap
        | (() => HeaderMap | Promise<HeaderMap>);

    constructor(
        options: {
            baseUrl?: string;
            headers?: HeaderMap | (() => HeaderMap | Promise<HeaderMap>);
        } = {},
    ) {
        this._baseUrl = options.baseUrl ?? "";
        this._headers = options.headers ?? {};
    }
    async typebox(params: TypeBoxObject): Promise<TypeBoxObject> {
        return arriRequest<TypeBoxObject, TypeBoxObject>({
            url: `${this._baseUrl}/rpcs/adapters/typebox`,
            method: "post",
            headers: this._headers,
            params: params,
            responseFromJson: $$TypeBoxObject.fromJson,
            responseFromString: $$TypeBoxObject.fromJsonString,
            serializer: $$TypeBoxObject.toJsonString,
            clientVersion: "10",
        });
    }
}

export class TestClientUsersService {
    private readonly _baseUrl: string;
    private readonly _headers:
        | HeaderMap
        | (() => HeaderMap | Promise<HeaderMap>);

    constructor(
        options: {
            baseUrl?: string;
            headers?: HeaderMap | (() => HeaderMap | Promise<HeaderMap>);
        } = {},
    ) {
        this._baseUrl = options.baseUrl ?? "";
        this._headers = options.headers ?? {};
    }
    watchUser(
        params: UsersWatchUserParams,
        options: SseOptions<UsersWatchUserResponse> = {},
    ): EventSourceController {
        return arriSseRequest<UsersWatchUserResponse, UsersWatchUserParams>(
            {
                url: `${this._baseUrl}/rpcs/users/watch-user`,
                method: "get",
                headers: this._headers,
                params: params,
                responseFromJson: $$UsersWatchUserResponse.fromJson,
                responseFromString: $$UsersWatchUserResponse.fromJsonString,
                serializer: $$UsersWatchUserParams.toUrlQueryString,
                clientVersion: "10",
            },
            options,
        );
    }
}

export interface ManuallyAddedModel {
    hello: string;
}
export const $$ManuallyAddedModel: ArriModelValidator<ManuallyAddedModel> = {
    new(): ManuallyAddedModel {
        return {
            hello: "",
        };
    },
    validate(input): input is ManuallyAddedModel {
        return isObject(input) && typeof input.hello === "string";
    },
    fromJson(input): ManuallyAddedModel {
        let _hello: string;
        if (typeof input.hello === "string") {
            _hello = input.hello;
        } else {
            _hello = "";
        }
        return {
            hello: _hello,
        };
    },
    fromJsonString(input): ManuallyAddedModel {
        return $$ManuallyAddedModel.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"hello":';
        json += serializeString(input.hello);
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`hello=${input.hello}`);
        return queryParts.join("&");
    },
};

export interface DefaultPayload {
    message: string;
}
export const $$DefaultPayload: ArriModelValidator<DefaultPayload> = {
    new(): DefaultPayload {
        return {
            message: "",
        };
    },
    validate(input): input is DefaultPayload {
        return isObject(input) && typeof input.message === "string";
    },
    fromJson(input): DefaultPayload {
        let _message: string;
        if (typeof input.message === "string") {
            _message = input.message;
        } else {
            _message = "";
        }
        return {
            message: _message,
        };
    },
    fromJsonString(input): DefaultPayload {
        return $$DefaultPayload.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"message":';
        json += serializeString(input.message);
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`message=${input.message}`);
        return queryParts.join("&");
    },
};

export interface TypeBoxObject {
    string: string;
    boolean: boolean;
    integer: number;
    number: number;
    enumField: TypeBoxObjectEnumField;
    object: TypeBoxObjectObject;
    array: boolean[];
    optionalString?: string;
}
export const $$TypeBoxObject: ArriModelValidator<TypeBoxObject> = {
    new(): TypeBoxObject {
        return {
            string: "",
            boolean: false,
            integer: 0,
            number: 0,
            enumField: $$TypeBoxObjectEnumField.new(),
            object: $$TypeBoxObjectObject.new(),
            array: [],
        };
    },
    validate(input): input is TypeBoxObject {
        return (
            isObject(input) &&
            typeof input.string === "string" &&
            typeof input.boolean === "boolean" &&
            typeof input.integer === "number" &&
            Number.isInteger(input.integer) &&
            input.integer >= INT32_MIN &&
            input.integer <= INT32_MAX &&
            typeof input.number === "number" &&
            $$TypeBoxObjectEnumField.validate(input.enumField) &&
            $$TypeBoxObjectObject.validate(input.object) &&
            Array.isArray(input.array) &&
            input.array.every((_element) => typeof _element === "boolean") &&
            (typeof input.optionalString === "string" ||
                typeof input.optionalString === "undefined")
        );
    },
    fromJson(input): TypeBoxObject {
        let _string: string;
        if (typeof input.string === "string") {
            _string = input.string;
        } else {
            _string = "";
        }
        let _boolean: boolean;
        if (typeof input.boolean === "boolean") {
            _boolean = input.boolean;
        } else {
            _boolean = false;
        }
        let _integer: number;
        if (
            typeof input.integer === "number" &&
            Number.isInteger(input.integer) &&
            input.integer >= INT32_MIN &&
            input.integer <= INT32_MAX
        ) {
            _integer = input.integer;
        } else {
            _integer = 0;
        }
        let _number: number;
        if (typeof input.number === "number") {
            _number = input.number;
        } else {
            _number = 0;
        }
        let _enumField: TypeBoxObjectEnumField;
        if (typeof input.enumField === "string") {
            _enumField = $$TypeBoxObjectEnumField.fromSerialValue(
                input.enumField,
            );
        } else {
            _enumField = $$TypeBoxObjectEnumField.new();
        }
        let _object: TypeBoxObjectObject;
        if (isObject(input.object)) {
            _object = $$TypeBoxObjectObject.fromJson(input.object);
        } else {
            _object = $$TypeBoxObjectObject.new();
        }
        let _array: boolean[];
        if (Array.isArray(input.array)) {
            _array = [];
            for (const _arrayEl of input.array) {
                let _arrayElValue: boolean;
                if (typeof _arrayEl === "boolean") {
                    _arrayElValue = _arrayEl;
                } else {
                    _arrayElValue = false;
                }
                _array.push(_arrayElValue);
            }
        } else {
            _array = [];
        }
        let _optionalString: string | undefined;
        if (typeof input.optionalString !== "undefined") {
            if (typeof input.optionalString === "string") {
                _optionalString = input.optionalString;
            } else {
                _optionalString = "";
            }
        }
        return {
            string: _string,
            boolean: _boolean,
            integer: _integer,
            number: _number,
            enumField: _enumField,
            object: _object,
            array: _array,
            optionalString: _optionalString,
        };
    },
    fromJsonString(input): TypeBoxObject {
        return $$TypeBoxObject.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"string":';
        json += serializeString(input.string);
        json += ',"boolean":';
        json += `${input.boolean}`;
        json += ',"integer":';
        json += `${input.integer}`;
        json += ',"number":';
        json += `${input.number}`;
        json += ',"enumField":';
        json += `"${input.enumField}"`;
        json += ',"object":';
        json += $$TypeBoxObjectObject.toJsonString(input.object);
        json += ',"array":';
        json += "[";
        for (let i = 0; i < input.array.length; i++) {
            if (i !== 0) json += ",";
            const _inputArrayEl = input.array[i];
            json += `${_inputArrayEl}`;
        }
        json += "]";
        if (typeof input.optionalString !== "undefined") {
            json += `,"optionalString":`;
            json += serializeString(input.optionalString);
        }
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`string=${input.string}`);
        queryParts.push(`boolean=${input.boolean}`);
        queryParts.push(`integer=${input.integer}`);
        queryParts.push(`number=${input.number}`);
        queryParts.push(`enumField=${input.enumField}`);
        console.warn(
            "[WARNING] Cannot serialize nested objects to query string. Skipping property at /TypeBoxObject/object.",
        );
        console.warn(
            "[WARNING] Cannot serialize arrays to query string. Skipping property at /TypeBoxObject/array.",
        );
        if (typeof input.optionalString !== "undefined") {
            queryParts.push(`optionalString=${input.optionalString}`);
        }
        return queryParts.join("&");
    },
};

export type TypeBoxObjectEnumField =
    (typeof $$TypeBoxObjectEnumFieldValues)[number];
const $$TypeBoxObjectEnumFieldValues = ["A", "B", "C"] as const;
export const $$TypeBoxObjectEnumField: ArriEnumValidator<TypeBoxObjectEnumField> =
    {
        new(): TypeBoxObjectEnumField {
            return $$TypeBoxObjectEnumFieldValues[0];
        },
        validate(input): input is TypeBoxObjectEnumField {
            return (
                typeof input === "string" &&
                $$TypeBoxObjectEnumFieldValues.includes(input as any)
            );
        },
        values: $$TypeBoxObjectEnumFieldValues,
        fromSerialValue(input): TypeBoxObjectEnumField {
            if ($$TypeBoxObjectEnumFieldValues.includes(input as any)) {
                return input as TypeBoxObjectEnumField;
            }
            if (
                $$TypeBoxObjectEnumFieldValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as TypeBoxObjectEnumField;
            }
            if (
                $$TypeBoxObjectEnumFieldValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as TypeBoxObjectEnumField;
            }
            return "A";
        },
    };

export interface TypeBoxObjectObject {
    string: string;
}
export const $$TypeBoxObjectObject: ArriModelValidator<TypeBoxObjectObject> = {
    new(): TypeBoxObjectObject {
        return {
            string: "",
        };
    },
    validate(input): input is TypeBoxObjectObject {
        return isObject(input) && typeof input.string === "string";
    },
    fromJson(input): TypeBoxObjectObject {
        let _string: string;
        if (typeof input.string === "string") {
            _string = input.string;
        } else {
            _string = "";
        }
        return {
            string: _string,
        };
    },
    fromJsonString(input): TypeBoxObjectObject {
        return $$TypeBoxObjectObject.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"string":';
        json += serializeString(input.string);
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`string=${input.string}`);
        return queryParts.join("&");
    },
};

/**
 * @deprecated
 */
export interface DeprecatedRpcParams {
    deprecatedField: string;
}
export const $$DeprecatedRpcParams: ArriModelValidator<DeprecatedRpcParams> = {
    new(): DeprecatedRpcParams {
        return {
            deprecatedField: "",
        };
    },
    validate(input): input is DeprecatedRpcParams {
        return isObject(input) && typeof input.deprecatedField === "string";
    },
    fromJson(input): DeprecatedRpcParams {
        let _deprecatedField: string;
        if (typeof input.deprecatedField === "string") {
            _deprecatedField = input.deprecatedField;
        } else {
            _deprecatedField = "";
        }
        return {
            deprecatedField: _deprecatedField,
        };
    },
    fromJsonString(input): DeprecatedRpcParams {
        return $$DeprecatedRpcParams.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"deprecatedField":';
        json += serializeString(input.deprecatedField);
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`deprecatedField=${input.deprecatedField}`);
        return queryParts.join("&");
    },
};

export interface SendErrorParams {
    code: number;
    message: string;
}
export const $$SendErrorParams: ArriModelValidator<SendErrorParams> = {
    new(): SendErrorParams {
        return {
            code: 0,
            message: "",
        };
    },
    validate(input): input is SendErrorParams {
        return (
            isObject(input) &&
            typeof input.code === "number" &&
            Number.isInteger(input.code) &&
            input.code >= 0 &&
            input.code <= UINT16_MAX &&
            typeof input.message === "string"
        );
    },
    fromJson(input): SendErrorParams {
        let _code: number;
        if (
            typeof input.code === "number" &&
            Number.isInteger(input.code) &&
            input.code >= 0 &&
            input.code <= UINT16_MAX
        ) {
            _code = input.code;
        } else {
            _code = 0;
        }
        let _message: string;
        if (typeof input.message === "string") {
            _message = input.message;
        } else {
            _message = "";
        }
        return {
            code: _code,
            message: _message,
        };
    },
    fromJsonString(input): SendErrorParams {
        return $$SendErrorParams.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"code":';
        json += `${input.code}`;
        json += ',"message":';
        json += serializeString(input.message);
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`code=${input.code}`);
        queryParts.push(`message=${input.message}`);
        return queryParts.join("&");
    },
};

export interface ObjectWithEveryType {
    any: any;
    boolean: boolean;
    string: string;
    timestamp: Date;
    float32: number;
    float64: number;
    int8: number;
    uint8: number;
    int16: number;
    uint16: number;
    int32: number;
    uint32: number;
    int64: bigint;
    uint64: bigint;
    enumerator: ObjectWithEveryTypeEnumerator;
    array: boolean[];
    object: ObjectWithEveryTypeObject;
    record: Record<string, boolean>;
    discriminator: ObjectWithEveryTypeDiscriminator;
    nestedObject: ObjectWithEveryTypeNestedObject;
    nestedArray: ObjectWithEveryTypeNestedArrayelementelement[][];
}
export const $$ObjectWithEveryType: ArriModelValidator<ObjectWithEveryType> = {
    new(): ObjectWithEveryType {
        return {
            any: undefined,
            boolean: false,
            string: "",
            timestamp: new Date(),
            float32: 0,
            float64: 0,
            int8: 0,
            uint8: 0,
            int16: 0,
            uint16: 0,
            int32: 0,
            uint32: 0,
            int64: BigInt(0),
            uint64: BigInt(0),
            enumerator: $$ObjectWithEveryTypeEnumerator.new(),
            array: [],
            object: $$ObjectWithEveryTypeObject.new(),
            record: {},
            discriminator: $$ObjectWithEveryTypeDiscriminator.new(),
            nestedObject: $$ObjectWithEveryTypeNestedObject.new(),
            nestedArray: [],
        };
    },
    validate(input): input is ObjectWithEveryType {
        return (
            isObject(input) &&
            true &&
            typeof input.boolean === "boolean" &&
            typeof input.string === "string" &&
            input.timestamp instanceof Date &&
            typeof input.float32 === "number" &&
            typeof input.float64 === "number" &&
            typeof input.int8 === "number" &&
            Number.isInteger(input.int8) &&
            input.int8 >= INT8_MIN &&
            input.int8 <= INT8_MAX &&
            typeof input.uint8 === "number" &&
            Number.isInteger(input.uint8) &&
            input.uint8 >= 0 &&
            input.uint8 <= UINT8_MAX &&
            typeof input.int16 === "number" &&
            Number.isInteger(input.int16) &&
            input.int16 >= INT16_MIN &&
            input.int16 <= INT16_MAX &&
            typeof input.uint16 === "number" &&
            Number.isInteger(input.uint16) &&
            input.uint16 >= 0 &&
            input.uint16 <= UINT16_MAX &&
            typeof input.int32 === "number" &&
            Number.isInteger(input.int32) &&
            input.int32 >= INT32_MIN &&
            input.int32 <= INT32_MAX &&
            typeof input.uint32 === "number" &&
            Number.isInteger(input.uint32) &&
            input.uint32 >= 0 &&
            input.uint32 <= UINT32_MAX &&
            typeof input.int64 === "bigint" &&
            input.int64 >= INT64_MIN &&
            input.int64 <= INT64_MAX &&
            typeof input.uint64 === "bigint" &&
            input.uint64 >= BigInt(0) &&
            input.uint64 <= UINT64_MAX &&
            $$ObjectWithEveryTypeEnumerator.validate(input.enumerator) &&
            Array.isArray(input.array) &&
            input.array.every((_element) => typeof _element === "boolean") &&
            $$ObjectWithEveryTypeObject.validate(input.object) &&
            isObject(input.record) &&
            Object.values(input.record).every(
                (_value) => typeof _value === "boolean",
            ) &&
            $$ObjectWithEveryTypeDiscriminator.validate(input.discriminator) &&
            $$ObjectWithEveryTypeNestedObject.validate(input.nestedObject) &&
            Array.isArray(input.nestedArray) &&
            input.nestedArray.every(
                (_element) =>
                    Array.isArray(_element) &&
                    _element.every((_element) =>
                        $$ObjectWithEveryTypeNestedArrayelementelement.validate(
                            _element,
                        ),
                    ),
            )
        );
    },
    fromJson(input): ObjectWithEveryType {
        let _any: any;
        _any = input.any;
        let _boolean: boolean;
        if (typeof input.boolean === "boolean") {
            _boolean = input.boolean;
        } else {
            _boolean = false;
        }
        let _string: string;
        if (typeof input.string === "string") {
            _string = input.string;
        } else {
            _string = "";
        }
        let _timestamp: Date;
        if (typeof input.timestamp === "string") {
            _timestamp = new Date(input.timestamp);
        } else if (input.timestamp instanceof Date) {
            _timestamp = input.timestamp;
        } else {
            _timestamp = new Date();
        }
        let _float32: number;
        if (typeof input.float32 === "number") {
            _float32 = input.float32;
        } else {
            _float32 = 0;
        }
        let _float64: number;
        if (typeof input.float64 === "number") {
            _float64 = input.float64;
        } else {
            _float64 = 0;
        }
        let _int8: number;
        if (
            typeof input.int8 === "number" &&
            Number.isInteger(input.int8) &&
            input.int8 >= INT8_MIN &&
            input.int8 <= INT8_MAX
        ) {
            _int8 = input.int8;
        } else {
            _int8 = 0;
        }
        let _uint8: number;
        if (
            typeof input.uint8 === "number" &&
            Number.isInteger(input.uint8) &&
            input.uint8 >= 0 &&
            input.uint8 <= UINT8_MAX
        ) {
            _uint8 = input.uint8;
        } else {
            _uint8 = 0;
        }
        let _int16: number;
        if (
            typeof input.int16 === "number" &&
            Number.isInteger(input.int16) &&
            input.int16 >= INT16_MIN &&
            input.int16 <= INT16_MAX
        ) {
            _int16 = input.int16;
        } else {
            _int16 = 0;
        }
        let _uint16: number;
        if (
            typeof input.uint16 === "number" &&
            Number.isInteger(input.uint16) &&
            input.uint16 >= 0 &&
            input.uint16 <= UINT16_MAX
        ) {
            _uint16 = input.uint16;
        } else {
            _uint16 = 0;
        }
        let _int32: number;
        if (
            typeof input.int32 === "number" &&
            Number.isInteger(input.int32) &&
            input.int32 >= INT32_MIN &&
            input.int32 <= INT32_MAX
        ) {
            _int32 = input.int32;
        } else {
            _int32 = 0;
        }
        let _uint32: number;
        if (
            typeof input.uint32 === "number" &&
            Number.isInteger(input.uint32) &&
            input.uint32 >= 0 &&
            input.uint32 <= UINT32_MAX
        ) {
            _uint32 = input.uint32;
        } else {
            _uint32 = 0;
        }
        let _int64: bigint;
        if (typeof input.int64 === "string") {
            _int64 = BigInt(input.int64);
        } else if (typeof input.int64 === "bigint") {
            _int64 = input.int64;
        } else {
            _int64 = BigInt(0);
        }
        let _uint64: bigint;
        if (
            typeof input.uint64 === "string" &&
            BigInt(input.uint64) >= BigInt(0)
        ) {
            _uint64 = BigInt(input.uint64);
        } else if (
            typeof input.uint64 === "bigint" &&
            input.uint64 >= BigInt(0)
        ) {
            _uint64 = input.uint64;
        } else {
            _uint64 = BigInt(0);
        }
        let _enumerator: ObjectWithEveryTypeEnumerator;
        if (typeof input.enumerator === "string") {
            _enumerator = $$ObjectWithEveryTypeEnumerator.fromSerialValue(
                input.enumerator,
            );
        } else {
            _enumerator = $$ObjectWithEveryTypeEnumerator.new();
        }
        let _array: boolean[];
        if (Array.isArray(input.array)) {
            _array = [];
            for (const _arrayEl of input.array) {
                let _arrayElValue: boolean;
                if (typeof _arrayEl === "boolean") {
                    _arrayElValue = _arrayEl;
                } else {
                    _arrayElValue = false;
                }
                _array.push(_arrayElValue);
            }
        } else {
            _array = [];
        }
        let _object: ObjectWithEveryTypeObject;
        if (isObject(input.object)) {
            _object = $$ObjectWithEveryTypeObject.fromJson(input.object);
        } else {
            _object = $$ObjectWithEveryTypeObject.new();
        }
        let _record: Record<string, boolean>;
        if (isObject(input.record)) {
            _record = {};
            for (const [_key, _value] of Object.entries(input.record)) {
                let _recordValue: boolean;
                if (typeof _value === "boolean") {
                    _recordValue = _value;
                } else {
                    _recordValue = false;
                }
                _record[_key] = _recordValue;
            }
        } else {
            _record = {};
        }
        let _discriminator: ObjectWithEveryTypeDiscriminator;
        if (isObject(input.discriminator)) {
            _discriminator = $$ObjectWithEveryTypeDiscriminator.fromJson(
                input.discriminator,
            );
        } else {
            _discriminator = $$ObjectWithEveryTypeDiscriminator.new();
        }
        let _nestedObject: ObjectWithEveryTypeNestedObject;
        if (isObject(input.nestedObject)) {
            _nestedObject = $$ObjectWithEveryTypeNestedObject.fromJson(
                input.nestedObject,
            );
        } else {
            _nestedObject = $$ObjectWithEveryTypeNestedObject.new();
        }
        let _nestedArray: ObjectWithEveryTypeNestedArrayelementelement[][];
        if (Array.isArray(input.nestedArray)) {
            _nestedArray = [];
            for (const _nestedArrayEl of input.nestedArray) {
                let _nestedArrayElValue: ObjectWithEveryTypeNestedArrayelementelement[];
                if (Array.isArray(_nestedArrayEl)) {
                    _nestedArrayElValue = [];
                    for (const _nestedArrayElValueEl of _nestedArrayEl) {
                        let _nestedArrayElValueElValue: ObjectWithEveryTypeNestedArrayelementelement;
                        if (isObject(_nestedArrayElValueEl)) {
                            _nestedArrayElValueElValue =
                                $$ObjectWithEveryTypeNestedArrayelementelement.fromJson(
                                    _nestedArrayElValueEl,
                                );
                        } else {
                            _nestedArrayElValueElValue =
                                $$ObjectWithEveryTypeNestedArrayelementelement.new();
                        }
                        _nestedArrayElValue.push(_nestedArrayElValueElValue);
                    }
                } else {
                    _nestedArrayElValue = [];
                }
                _nestedArray.push(_nestedArrayElValue);
            }
        } else {
            _nestedArray = [];
        }
        return {
            any: _any,
            boolean: _boolean,
            string: _string,
            timestamp: _timestamp,
            float32: _float32,
            float64: _float64,
            int8: _int8,
            uint8: _uint8,
            int16: _int16,
            uint16: _uint16,
            int32: _int32,
            uint32: _uint32,
            int64: _int64,
            uint64: _uint64,
            enumerator: _enumerator,
            array: _array,
            object: _object,
            record: _record,
            discriminator: _discriminator,
            nestedObject: _nestedObject,
            nestedArray: _nestedArray,
        };
    },
    fromJsonString(input): ObjectWithEveryType {
        return $$ObjectWithEveryType.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"any":';
        json += JSON.stringify(input.any);
        json += ',"boolean":';
        json += `${input.boolean}`;
        json += ',"string":';
        json += serializeString(input.string);
        json += ',"timestamp":';
        json += `"${input.timestamp.toISOString()}"`;
        json += ',"float32":';
        json += `${input.float32}`;
        json += ',"float64":';
        json += `${input.float64}`;
        json += ',"int8":';
        json += `${input.int8}`;
        json += ',"uint8":';
        json += `${input.uint8}`;
        json += ',"int16":';
        json += `${input.int16}`;
        json += ',"uint16":';
        json += `${input.uint16}`;
        json += ',"int32":';
        json += `${input.int32}`;
        json += ',"uint32":';
        json += `${input.uint32}`;
        json += ',"int64":';
        json += `"${input.int64}"`;
        json += ',"uint64":';
        json += `"${input.uint64}"`;
        json += ',"enumerator":';
        json += `"${input.enumerator}"`;
        json += ',"array":';
        json += "[";
        for (let i = 0; i < input.array.length; i++) {
            if (i !== 0) json += ",";
            const _inputArrayEl = input.array[i];
            json += `${_inputArrayEl}`;
        }
        json += "]";
        json += ',"object":';
        json += $$ObjectWithEveryTypeObject.toJsonString(input.object);
        json += ',"record":';
        json += "{";
        let _recordPropertyCount = 0;
        for (const [_key, _value] of Object.entries(input.record)) {
            if (_recordPropertyCount !== 0) {
                json += ",";
            }
            json += `"${_key}":`;
            json += `${_value}`;
            _recordPropertyCount++;
        }
        json += "}";

        json += ',"discriminator":';
        json += $$ObjectWithEveryTypeDiscriminator.toJsonString(
            input.discriminator,
        );
        json += ',"nestedObject":';
        json += $$ObjectWithEveryTypeNestedObject.toJsonString(
            input.nestedObject,
        );
        json += ',"nestedArray":';
        json += "[";
        for (let i = 0; i < input.nestedArray.length; i++) {
            if (i !== 0) json += ",";
            const _inputNestedArrayEl = input.nestedArray[i];
            json += "[";
            for (let i = 0; i < _inputNestedArrayEl.length; i++) {
                if (i !== 0) json += ",";
                const _inputNestedArrayElEl = _inputNestedArrayEl[i];
                json +=
                    $$ObjectWithEveryTypeNestedArrayelementelement.toJsonString(
                        _inputNestedArrayElEl,
                    );
            }
            json += "]";
        }
        json += "]";
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        console.warn(
            "[WARNING] Cannot serialize any's to query string. Skipping property at /ObjectWithEveryType/any.",
        );
        queryParts.push(`boolean=${input.boolean}`);
        queryParts.push(`string=${input.string}`);
        queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
        queryParts.push(`float32=${input.float32}`);
        queryParts.push(`float64=${input.float64}`);
        queryParts.push(`int8=${input.int8}`);
        queryParts.push(`uint8=${input.uint8}`);
        queryParts.push(`int16=${input.int16}`);
        queryParts.push(`uint16=${input.uint16}`);
        queryParts.push(`int32=${input.int32}`);
        queryParts.push(`uint32=${input.uint32}`);
        queryParts.push(`int64=${input.int64}`);
        queryParts.push(`uint64=${input.uint64}`);
        queryParts.push(`enumerator=${input.enumerator}`);
        console.warn(
            "[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryType/array.",
        );
        console.warn(
            "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/object.",
        );
        console.warn(
            "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/record.",
        );
        console.warn(
            "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/discriminator.",
        );
        console.warn(
            "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/nestedObject.",
        );
        console.warn(
            "[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryType/nestedArray.",
        );
        return queryParts.join("&");
    },
};

export type ObjectWithEveryTypeEnumerator =
    (typeof $$ObjectWithEveryTypeEnumeratorValues)[number];
const $$ObjectWithEveryTypeEnumeratorValues = ["A", "B", "C"] as const;
export const $$ObjectWithEveryTypeEnumerator: ArriEnumValidator<ObjectWithEveryTypeEnumerator> =
    {
        new(): ObjectWithEveryTypeEnumerator {
            return $$ObjectWithEveryTypeEnumeratorValues[0];
        },
        validate(input): input is ObjectWithEveryTypeEnumerator {
            return (
                typeof input === "string" &&
                $$ObjectWithEveryTypeEnumeratorValues.includes(input as any)
            );
        },
        values: $$ObjectWithEveryTypeEnumeratorValues,
        fromSerialValue(input): ObjectWithEveryTypeEnumerator {
            if ($$ObjectWithEveryTypeEnumeratorValues.includes(input as any)) {
                return input as ObjectWithEveryTypeEnumerator;
            }
            if (
                $$ObjectWithEveryTypeEnumeratorValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as ObjectWithEveryTypeEnumerator;
            }
            if (
                $$ObjectWithEveryTypeEnumeratorValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as ObjectWithEveryTypeEnumerator;
            }
            return "A";
        },
    };

export interface ObjectWithEveryTypeObject {
    string: string;
    boolean: boolean;
    timestamp: Date;
}
export const $$ObjectWithEveryTypeObject: ArriModelValidator<ObjectWithEveryTypeObject> =
    {
        new(): ObjectWithEveryTypeObject {
            return {
                string: "",
                boolean: false,
                timestamp: new Date(),
            };
        },
        validate(input): input is ObjectWithEveryTypeObject {
            return (
                isObject(input) &&
                typeof input.string === "string" &&
                typeof input.boolean === "boolean" &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): ObjectWithEveryTypeObject {
            let _string: string;
            if (typeof input.string === "string") {
                _string = input.string;
            } else {
                _string = "";
            }
            let _boolean: boolean;
            if (typeof input.boolean === "boolean") {
                _boolean = input.boolean;
            } else {
                _boolean = false;
            }
            let _timestamp: Date;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                string: _string,
                boolean: _boolean,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): ObjectWithEveryTypeObject {
            return $$ObjectWithEveryTypeObject.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = "{";
            json += '"string":';
            json += serializeString(input.string);
            json += ',"boolean":';
            json += `${input.boolean}`;
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`string=${input.string}`);
            queryParts.push(`boolean=${input.boolean}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join("&");
        },
    };

export type ObjectWithEveryTypeDiscriminator =
    | ObjectWithEveryTypeDiscriminatorA
    | ObjectWithEveryTypeDiscriminatorB;
export const $$ObjectWithEveryTypeDiscriminator: ArriModelValidator<ObjectWithEveryTypeDiscriminator> =
    {
        new(): ObjectWithEveryTypeDiscriminator {
            return $$ObjectWithEveryTypeDiscriminatorA.new();
        },
        validate(input): input is ObjectWithEveryTypeDiscriminator {
            if (!isObject(input)) {
                return false;
            }
            if (typeof input.type !== "string") {
                return false;
            }
            switch (input.type) {
                case "A":
                    return $$ObjectWithEveryTypeDiscriminatorA.validate(input);
                case "B":
                    return $$ObjectWithEveryTypeDiscriminatorB.validate(input);
                default:
                    return false;
            }
        },
        fromJson(input): ObjectWithEveryTypeDiscriminator {
            switch (input.type) {
                case "A":
                    return $$ObjectWithEveryTypeDiscriminatorA.fromJson(input);
                case "B":
                    return $$ObjectWithEveryTypeDiscriminatorB.fromJson(input);
                default:
                    return $$ObjectWithEveryTypeDiscriminatorA.new();
            }
        },
        fromJsonString(input): ObjectWithEveryTypeDiscriminator {
            return $$ObjectWithEveryTypeDiscriminator.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            switch (input.type) {
                case "A":
                    return $$ObjectWithEveryTypeDiscriminatorA.toJsonString(
                        input,
                    );
                case "B":
                    return $$ObjectWithEveryTypeDiscriminatorB.toJsonString(
                        input,
                    );
                default:
                    throw new Error(`Unhandled case "${(input as any).type}"`);
            }
        },
        toUrlQueryString(input): string {
            switch (input.type) {
                case "A":
                    return $$ObjectWithEveryTypeDiscriminatorA.toUrlQueryString(
                        input,
                    );
                case "B":
                    return $$ObjectWithEveryTypeDiscriminatorB.toUrlQueryString(
                        input,
                    );
                default:
                    throw new Error("Unhandled case");
            }
        },
    };
export interface ObjectWithEveryTypeDiscriminatorA {
    type: "A";
    title: string;
}
const $$ObjectWithEveryTypeDiscriminatorA: ArriModelValidator<ObjectWithEveryTypeDiscriminatorA> =
    {
        new(): ObjectWithEveryTypeDiscriminatorA {
            return {
                type: "A",
                title: "",
            };
        },
        validate(input): input is ObjectWithEveryTypeDiscriminatorA {
            return (
                isObject(input) &&
                input.type === "A" &&
                typeof input.title === "string"
            );
        },
        fromJson(input): ObjectWithEveryTypeDiscriminatorA {
            const _type = "A";
            let _title: string;
            if (typeof input.title === "string") {
                _title = input.title;
            } else {
                _title = "";
            }
            return {
                type: _type,
                title: _title,
            };
        },
        fromJsonString(input): ObjectWithEveryTypeDiscriminatorA {
            return $$ObjectWithEveryTypeDiscriminatorA.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"type":"A"';
            json += ',"title":';
            json += serializeString(input.title);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push("type=A");
            queryParts.push(`title=${input.title}`);
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryTypeDiscriminatorB {
    type: "B";
    title: string;
    description: string;
}
const $$ObjectWithEveryTypeDiscriminatorB: ArriModelValidator<ObjectWithEveryTypeDiscriminatorB> =
    {
        new(): ObjectWithEveryTypeDiscriminatorB {
            return {
                type: "B",
                title: "",
                description: "",
            };
        },
        validate(input): input is ObjectWithEveryTypeDiscriminatorB {
            return (
                isObject(input) &&
                input.type === "B" &&
                typeof input.title === "string" &&
                typeof input.description === "string"
            );
        },
        fromJson(input): ObjectWithEveryTypeDiscriminatorB {
            const _type = "B";
            let _title: string;
            if (typeof input.title === "string") {
                _title = input.title;
            } else {
                _title = "";
            }
            let _description: string;
            if (typeof input.description === "string") {
                _description = input.description;
            } else {
                _description = "";
            }
            return {
                type: _type,
                title: _title,
                description: _description,
            };
        },
        fromJsonString(input): ObjectWithEveryTypeDiscriminatorB {
            return $$ObjectWithEveryTypeDiscriminatorB.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"type":"B"';
            json += ',"title":';
            json += serializeString(input.title);
            json += ',"description":';
            json += serializeString(input.description);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push("type=B");
            queryParts.push(`title=${input.title}`);
            queryParts.push(`description=${input.description}`);
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryTypeNestedObject {
    id: string;
    timestamp: Date;
    data: ObjectWithEveryTypeNestedObjectData;
}
export const $$ObjectWithEveryTypeNestedObject: ArriModelValidator<ObjectWithEveryTypeNestedObject> =
    {
        new(): ObjectWithEveryTypeNestedObject {
            return {
                id: "",
                timestamp: new Date(),
                data: $$ObjectWithEveryTypeNestedObjectData.new(),
            };
        },
        validate(input): input is ObjectWithEveryTypeNestedObject {
            return (
                isObject(input) &&
                typeof input.id === "string" &&
                input.timestamp instanceof Date &&
                $$ObjectWithEveryTypeNestedObjectData.validate(input.data)
            );
        },
        fromJson(input): ObjectWithEveryTypeNestedObject {
            let _id: string;
            if (typeof input.id === "string") {
                _id = input.id;
            } else {
                _id = "";
            }
            let _timestamp: Date;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            let _data: ObjectWithEveryTypeNestedObjectData;
            if (isObject(input.data)) {
                _data = $$ObjectWithEveryTypeNestedObjectData.fromJson(
                    input.data,
                );
            } else {
                _data = $$ObjectWithEveryTypeNestedObjectData.new();
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): ObjectWithEveryTypeNestedObject {
            return $$ObjectWithEveryTypeNestedObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += ',"data":';
            json += $$ObjectWithEveryTypeNestedObjectData.toJsonString(
                input.data,
            );
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            console.warn(
                "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryTypeNestedObject/data.",
            );
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryTypeNestedObjectData {
    id: string;
    timestamp: Date;
    data: ObjectWithEveryTypeNestedObjectDataData;
}
export const $$ObjectWithEveryTypeNestedObjectData: ArriModelValidator<ObjectWithEveryTypeNestedObjectData> =
    {
        new(): ObjectWithEveryTypeNestedObjectData {
            return {
                id: "",
                timestamp: new Date(),
                data: $$ObjectWithEveryTypeNestedObjectDataData.new(),
            };
        },
        validate(input): input is ObjectWithEveryTypeNestedObjectData {
            return (
                isObject(input) &&
                typeof input.id === "string" &&
                input.timestamp instanceof Date &&
                $$ObjectWithEveryTypeNestedObjectDataData.validate(input.data)
            );
        },
        fromJson(input): ObjectWithEveryTypeNestedObjectData {
            let _id: string;
            if (typeof input.id === "string") {
                _id = input.id;
            } else {
                _id = "";
            }
            let _timestamp: Date;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            let _data: ObjectWithEveryTypeNestedObjectDataData;
            if (isObject(input.data)) {
                _data = $$ObjectWithEveryTypeNestedObjectDataData.fromJson(
                    input.data,
                );
            } else {
                _data = $$ObjectWithEveryTypeNestedObjectDataData.new();
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): ObjectWithEveryTypeNestedObjectData {
            return $$ObjectWithEveryTypeNestedObjectData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += ',"data":';
            json += $$ObjectWithEveryTypeNestedObjectDataData.toJsonString(
                input.data,
            );
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            console.warn(
                "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryTypeNestedObjectData/data.",
            );
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryTypeNestedObjectDataData {
    id: string;
    timestamp: Date;
}
export const $$ObjectWithEveryTypeNestedObjectDataData: ArriModelValidator<ObjectWithEveryTypeNestedObjectDataData> =
    {
        new(): ObjectWithEveryTypeNestedObjectDataData {
            return {
                id: "",
                timestamp: new Date(),
            };
        },
        validate(input): input is ObjectWithEveryTypeNestedObjectDataData {
            return (
                isObject(input) &&
                typeof input.id === "string" &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): ObjectWithEveryTypeNestedObjectDataData {
            let _id: string;
            if (typeof input.id === "string") {
                _id = input.id;
            } else {
                _id = "";
            }
            let _timestamp: Date;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): ObjectWithEveryTypeNestedObjectDataData {
            return $$ObjectWithEveryTypeNestedObjectDataData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryTypeNestedArrayelementelement {
    id: string;
    timestamp: Date;
}
export const $$ObjectWithEveryTypeNestedArrayelementelement: ArriModelValidator<ObjectWithEveryTypeNestedArrayelementelement> =
    {
        new(): ObjectWithEveryTypeNestedArrayelementelement {
            return {
                id: "",
                timestamp: new Date(),
            };
        },
        validate(input): input is ObjectWithEveryTypeNestedArrayelementelement {
            return (
                isObject(input) &&
                typeof input.id === "string" &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): ObjectWithEveryTypeNestedArrayelementelement {
            let _id: string;
            if (typeof input.id === "string") {
                _id = input.id;
            } else {
                _id = "";
            }
            let _timestamp: Date;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): ObjectWithEveryTypeNestedArrayelementelement {
            return $$ObjectWithEveryTypeNestedArrayelementelement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryNullableType {
    any: any;
    boolean: boolean | null;
    string: string | null;
    timestamp: Date | null;
    float32: number | null;
    float64: number | null;
    int8: number | null;
    uint8: number | null;
    int16: number | null;
    uint16: number | null;
    int32: number | null;
    uint32: number | null;
    int64: bigint | null;
    uint64: bigint | null;
    enumerator: ObjectWithEveryNullableTypeEnumerator | null;
    array: (boolean | null)[] | null;
    object: ObjectWithEveryNullableTypeObject | null;
    record: Record<string, boolean | null> | null;
    discriminator: ObjectWithEveryNullableTypeDiscriminator | null;
    nestedObject: ObjectWithEveryNullableTypeNestedObject | null;
    nestedArray:
        | (
              | (ObjectWithEveryNullableTypeNestedArrayelementelement | null)[]
              | null
          )[]
        | null;
}
export const $$ObjectWithEveryNullableType: ArriModelValidator<ObjectWithEveryNullableType> =
    {
        new(): ObjectWithEveryNullableType {
            return {
                any: null,
                boolean: null,
                string: null,
                timestamp: null,
                float32: null,
                float64: null,
                int8: null,
                uint8: null,
                int16: null,
                uint16: null,
                int32: null,
                uint32: null,
                int64: null,
                uint64: null,
                enumerator: null,
                array: null,
                object: null,
                record: null,
                discriminator: null,
                nestedObject: null,
                nestedArray: null,
            };
        },
        validate(input): input is ObjectWithEveryNullableType {
            return (
                isObject(input) &&
                true &&
                (typeof input.boolean === "boolean" ||
                    input.boolean === null) &&
                (typeof input.string === "string" || input.string === null) &&
                (input.timestamp instanceof Date || input.timestamp === null) &&
                (typeof input.float32 === "number" || input.float32 === null) &&
                (typeof input.float64 === "number" || input.float64 === null) &&
                ((typeof input.int8 === "number" &&
                    Number.isInteger(input.int8) &&
                    input.int8 >= INT8_MIN &&
                    input.int8 <= INT8_MAX) ||
                    input.int8 === null) &&
                ((typeof input.uint8 === "number" &&
                    Number.isInteger(input.uint8) &&
                    input.uint8 >= 0 &&
                    input.uint8 <= UINT8_MAX) ||
                    input.uint8 === null) &&
                ((typeof input.int16 === "number" &&
                    Number.isInteger(input.int16) &&
                    input.int16 >= INT16_MIN &&
                    input.int16 <= INT16_MAX) ||
                    input.int16 === null) &&
                ((typeof input.uint16 === "number" &&
                    Number.isInteger(input.uint16) &&
                    input.uint16 >= 0 &&
                    input.uint16 <= UINT16_MAX) ||
                    input.uint16 === null) &&
                ((typeof input.int32 === "number" &&
                    Number.isInteger(input.int32) &&
                    input.int32 >= INT32_MIN &&
                    input.int32 <= INT32_MAX) ||
                    input.int32 === null) &&
                ((typeof input.uint32 === "number" &&
                    Number.isInteger(input.uint32) &&
                    input.uint32 >= 0 &&
                    input.uint32 <= UINT32_MAX) ||
                    input.uint32 === null) &&
                ((typeof input.int64 === "bigint" &&
                    input.int64 >= INT64_MIN &&
                    input.int64 <= INT64_MAX) ||
                    input.int64 === null) &&
                ((typeof input.uint64 === "bigint" &&
                    input.uint64 >= BigInt(0) &&
                    input.uint64 <= UINT64_MAX) ||
                    input.uint64 === null) &&
                ($$ObjectWithEveryNullableTypeEnumerator.validate(
                    input.enumerator,
                ) ||
                    input.enumerator === null) &&
                ((Array.isArray(input.array) &&
                    input.array.every(
                        (_element) =>
                            typeof _element === "boolean" || _element === null,
                    )) ||
                    input.array === null) &&
                ($$ObjectWithEveryNullableTypeObject.validate(input.object) ||
                    input.object === null) &&
                ((isObject(input.record) &&
                    Object.values(input.record).every(
                        (_value) =>
                            typeof _value === "boolean" || _value === null,
                    )) ||
                    input.record === null) &&
                ($$ObjectWithEveryNullableTypeDiscriminator.validate(
                    input.discriminator,
                ) ||
                    input.discriminator === null) &&
                ($$ObjectWithEveryNullableTypeNestedObject.validate(
                    input.nestedObject,
                ) ||
                    input.nestedObject === null) &&
                ((Array.isArray(input.nestedArray) &&
                    input.nestedArray.every(
                        (_element) =>
                            (Array.isArray(_element) &&
                                _element.every(
                                    (_element) =>
                                        $$ObjectWithEveryNullableTypeNestedArrayelementelement.validate(
                                            _element,
                                        ) || _element === null,
                                )) ||
                            _element === null,
                    )) ||
                    input.nestedArray === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableType {
            let _any: any;
            _any = input.any;
            let _boolean: boolean | null;
            if (typeof input.boolean === "boolean") {
                _boolean = input.boolean;
            } else {
                _boolean = null;
            }
            let _string: string | null;
            if (typeof input.string === "string") {
                _string = input.string;
            } else {
                _string = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            let _float32: number | null;
            if (typeof input.float32 === "number") {
                _float32 = input.float32;
            } else {
                _float32 = null;
            }
            let _float64: number | null;
            if (typeof input.float64 === "number") {
                _float64 = input.float64;
            } else {
                _float64 = null;
            }
            let _int8: number | null;
            if (
                typeof input.int8 === "number" &&
                Number.isInteger(input.int8) &&
                input.int8 >= INT8_MIN &&
                input.int8 <= INT8_MAX
            ) {
                _int8 = input.int8;
            } else {
                _int8 = null;
            }
            let _uint8: number | null;
            if (
                typeof input.uint8 === "number" &&
                Number.isInteger(input.uint8) &&
                input.uint8 >= 0 &&
                input.uint8 <= UINT8_MAX
            ) {
                _uint8 = input.uint8;
            } else {
                _uint8 = null;
            }
            let _int16: number | null;
            if (
                typeof input.int16 === "number" &&
                Number.isInteger(input.int16) &&
                input.int16 >= INT16_MIN &&
                input.int16 <= INT16_MAX
            ) {
                _int16 = input.int16;
            } else {
                _int16 = null;
            }
            let _uint16: number | null;
            if (
                typeof input.uint16 === "number" &&
                Number.isInteger(input.uint16) &&
                input.uint16 >= 0 &&
                input.uint16 <= UINT16_MAX
            ) {
                _uint16 = input.uint16;
            } else {
                _uint16 = null;
            }
            let _int32: number | null;
            if (
                typeof input.int32 === "number" &&
                Number.isInteger(input.int32) &&
                input.int32 >= INT32_MIN &&
                input.int32 <= INT32_MAX
            ) {
                _int32 = input.int32;
            } else {
                _int32 = null;
            }
            let _uint32: number | null;
            if (
                typeof input.uint32 === "number" &&
                Number.isInteger(input.uint32) &&
                input.uint32 >= 0 &&
                input.uint32 <= UINT32_MAX
            ) {
                _uint32 = input.uint32;
            } else {
                _uint32 = null;
            }
            let _int64: bigint | null;
            if (typeof input.int64 === "string") {
                _int64 = BigInt(input.int64);
            } else if (typeof input.int64 === "bigint") {
                _int64 = input.int64;
            } else {
                _int64 = null;
            }
            let _uint64: bigint | null;
            if (
                typeof input.uint64 === "string" &&
                BigInt(input.uint64) >= BigInt(0)
            ) {
                _uint64 = BigInt(input.uint64);
            } else if (
                typeof input.uint64 === "bigint" &&
                input.uint64 >= BigInt(0)
            ) {
                _uint64 = input.uint64;
            } else {
                _uint64 = null;
            }
            let _enumerator: ObjectWithEveryNullableTypeEnumerator | null;
            if (typeof input.enumerator === "string") {
                _enumerator =
                    $$ObjectWithEveryNullableTypeEnumerator.fromSerialValue(
                        input.enumerator,
                    );
            } else {
                _enumerator = null;
            }
            let _array: (boolean | null)[] | null;
            if (Array.isArray(input.array)) {
                _array = [];
                for (const _arrayEl of input.array) {
                    let _arrayElValue: boolean | null;
                    if (typeof _arrayEl === "boolean") {
                        _arrayElValue = _arrayEl;
                    } else {
                        _arrayElValue = null;
                    }
                    _array.push(_arrayElValue);
                }
            } else {
                _array = null;
            }
            let _object: ObjectWithEveryNullableTypeObject | null;
            if (isObject(input.object)) {
                _object = $$ObjectWithEveryNullableTypeObject.fromJson(
                    input.object,
                );
            } else {
                _object = null;
            }
            let _record: Record<string, boolean | null> | null;
            if (isObject(input.record)) {
                _record = {};
                for (const [_key, _value] of Object.entries(input.record)) {
                    let _recordValue: boolean | null;
                    if (typeof _value === "boolean") {
                        _recordValue = _value;
                    } else {
                        _recordValue = false;
                    }
                    _record[_key] = _recordValue;
                }
            } else {
                _record = null;
            }
            let _discriminator: ObjectWithEveryNullableTypeDiscriminator | null;
            if (isObject(input.discriminator)) {
                _discriminator =
                    $$ObjectWithEveryNullableTypeDiscriminator.fromJson(
                        input.discriminator,
                    );
            } else {
                _discriminator = null;
            }
            let _nestedObject: ObjectWithEveryNullableTypeNestedObject | null;
            if (isObject(input.nestedObject)) {
                _nestedObject =
                    $$ObjectWithEveryNullableTypeNestedObject.fromJson(
                        input.nestedObject,
                    );
            } else {
                _nestedObject = null;
            }
            let _nestedArray:
                | (
                      | (ObjectWithEveryNullableTypeNestedArrayelementelement | null)[]
                      | null
                  )[]
                | null;
            if (Array.isArray(input.nestedArray)) {
                _nestedArray = [];
                for (const _nestedArrayEl of input.nestedArray) {
                    let _nestedArrayElValue:
                        | (ObjectWithEveryNullableTypeNestedArrayelementelement | null)[]
                        | null;
                    if (Array.isArray(_nestedArrayEl)) {
                        _nestedArrayElValue = [];
                        for (const _nestedArrayElValueEl of _nestedArrayEl) {
                            let _nestedArrayElValueElValue: ObjectWithEveryNullableTypeNestedArrayelementelement | null;
                            if (isObject(_nestedArrayElValueEl)) {
                                _nestedArrayElValueElValue =
                                    $$ObjectWithEveryNullableTypeNestedArrayelementelement.fromJson(
                                        _nestedArrayElValueEl,
                                    );
                            } else {
                                _nestedArrayElValueElValue = null;
                            }
                            _nestedArrayElValue.push(
                                _nestedArrayElValueElValue,
                            );
                        }
                    } else {
                        _nestedArrayElValue = null;
                    }
                    _nestedArray.push(_nestedArrayElValue);
                }
            } else {
                _nestedArray = null;
            }
            return {
                any: _any,
                boolean: _boolean,
                string: _string,
                timestamp: _timestamp,
                float32: _float32,
                float64: _float64,
                int8: _int8,
                uint8: _uint8,
                int16: _int16,
                uint16: _uint16,
                int32: _int32,
                uint32: _uint32,
                int64: _int64,
                uint64: _uint64,
                enumerator: _enumerator,
                array: _array,
                object: _object,
                record: _record,
                discriminator: _discriminator,
                nestedObject: _nestedObject,
                nestedArray: _nestedArray,
            };
        },
        fromJsonString(input): ObjectWithEveryNullableType {
            return $$ObjectWithEveryNullableType.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = "{";
            json += '"any":';
            json += JSON.stringify(input.any);
            json += ',"boolean":';
            json += `${input.boolean}`;
            json += ',"string":';
            if (typeof input.string === "string") {
                json += serializeString(input.string);
            } else {
                json += "null";
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += "null";
            }
            json += ',"float32":';
            json += `${input.float32}`;
            json += ',"float64":';
            json += `${input.float64}`;
            json += ',"int8":';
            json += `${input.int8}`;
            json += ',"uint8":';
            json += `${input.uint8}`;
            json += ',"int16":';
            json += `${input.int16}`;
            json += ',"uint16":';
            json += `${input.uint16}`;
            json += ',"int32":';
            json += `${input.int32}`;
            json += ',"uint32":';
            json += `${input.uint32}`;
            json += ',"int64":';
            if (typeof input.int64 === "bigint") {
                json += `"${input.int64}"`;
            } else {
                json += "null";
            }
            json += ',"uint64":';
            if (typeof input.uint64 === "bigint") {
                json += `"${input.uint64}"`;
            } else {
                json += "null";
            }
            json += ',"enumerator":';
            if (typeof input.enumerator === "string") {
                json += `"${input.enumerator}"`;
            } else {
                json += "null";
            }
            json += ',"array":';
            if (input.array !== null) {
                json += "[";
                for (let i = 0; i < input.array.length; i++) {
                    if (i !== 0) json += ",";
                    const _inputArrayEl = input.array[i];
                    json += `${_inputArrayEl}`;
                }
                json += "]";
            } else {
                json += "null";
            }
            json += ',"object":';
            if (input.object !== null) {
                json += $$ObjectWithEveryNullableTypeObject.toJsonString(
                    input.object,
                );
            } else {
                json += "null";
            }
            json += ',"record":';
            if (input.record !== null) {
                json += "{";
                let _recordPropertyCount = 0;
                for (const [_key, _value] of Object.entries(input.record)) {
                    if (_recordPropertyCount !== 0) {
                        json += ",";
                    }
                    json += `"${_key}":`;
                    json += `${_value}`;
                    _recordPropertyCount++;
                }
                json += "}";
            } else {
                json += "null";
            }
            json += ',"discriminator":';
            if (input.discriminator != null) {
                json += $$ObjectWithEveryNullableTypeDiscriminator.toJsonString(
                    input.discriminator,
                );
            } else {
                json += "null";
            }
            json += ',"nestedObject":';
            if (input.nestedObject !== null) {
                json += $$ObjectWithEveryNullableTypeNestedObject.toJsonString(
                    input.nestedObject,
                );
            } else {
                json += "null";
            }
            json += ',"nestedArray":';
            if (input.nestedArray !== null) {
                json += "[";
                for (let i = 0; i < input.nestedArray.length; i++) {
                    if (i !== 0) json += ",";
                    const _inputNestedArrayEl = input.nestedArray[i];
                    if (_inputNestedArrayEl !== null) {
                        json += "[";
                        for (let i = 0; i < _inputNestedArrayEl.length; i++) {
                            if (i !== 0) json += ",";
                            const _inputNestedArrayElEl =
                                _inputNestedArrayEl[i];
                            if (_inputNestedArrayElEl !== null) {
                                json +=
                                    $$ObjectWithEveryNullableTypeNestedArrayelementelement.toJsonString(
                                        _inputNestedArrayElEl,
                                    );
                            } else {
                                json += "null";
                            }
                        }
                        json += "]";
                    } else {
                        json += "null";
                    }
                }
                json += "]";
            } else {
                json += "null";
            }
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            console.warn(
                "[WARNING] Cannot serialize any's to query string. Skipping property at /ObjectWithEveryNullableType/any.",
            );
            queryParts.push(`boolean=${input.boolean}`);
            queryParts.push(`string=${input.string}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            queryParts.push(`float32=${input.float32}`);
            queryParts.push(`float64=${input.float64}`);
            queryParts.push(`int8=${input.int8}`);
            queryParts.push(`uint8=${input.uint8}`);
            queryParts.push(`int16=${input.int16}`);
            queryParts.push(`uint16=${input.uint16}`);
            queryParts.push(`int32=${input.int32}`);
            queryParts.push(`uint32=${input.uint32}`);
            queryParts.push(`int64=${input.int64}`);
            queryParts.push(`uint64=${input.uint64}`);
            queryParts.push(`enumerator=${input.enumerator}`);
            console.warn(
                "[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryNullableType/array.",
            );
            console.warn(
                "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableType/object.",
            );
            console.warn(
                "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableType/record.",
            );
            console.warn(
                "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableType/discriminator.",
            );
            console.warn(
                "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableType/nestedObject.",
            );
            console.warn(
                "[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryNullableType/nestedArray.",
            );
            return queryParts.join("&");
        },
    };

export type ObjectWithEveryNullableTypeEnumerator =
    (typeof $$ObjectWithEveryNullableTypeEnumeratorValues)[number];
const $$ObjectWithEveryNullableTypeEnumeratorValues = ["A", "B", "C"] as const;
export const $$ObjectWithEveryNullableTypeEnumerator: ArriEnumValidator<ObjectWithEveryNullableTypeEnumerator> =
    {
        new(): ObjectWithEveryNullableTypeEnumerator {
            return $$ObjectWithEveryNullableTypeEnumeratorValues[0];
        },
        validate(input): input is ObjectWithEveryNullableTypeEnumerator {
            return (
                typeof input === "string" &&
                $$ObjectWithEveryNullableTypeEnumeratorValues.includes(
                    input as any,
                )
            );
        },
        values: $$ObjectWithEveryNullableTypeEnumeratorValues,
        fromSerialValue(input): ObjectWithEveryNullableTypeEnumerator {
            if (
                $$ObjectWithEveryNullableTypeEnumeratorValues.includes(
                    input as any,
                )
            ) {
                return input as ObjectWithEveryNullableTypeEnumerator;
            }
            if (
                $$ObjectWithEveryNullableTypeEnumeratorValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as ObjectWithEveryNullableTypeEnumerator;
            }
            if (
                $$ObjectWithEveryNullableTypeEnumeratorValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as ObjectWithEveryNullableTypeEnumerator;
            }
            return "A";
        },
    };

export interface ObjectWithEveryNullableTypeObject {
    string: string | null;
    boolean: boolean | null;
    timestamp: Date | null;
}
export const $$ObjectWithEveryNullableTypeObject: ArriModelValidator<ObjectWithEveryNullableTypeObject> =
    {
        new(): ObjectWithEveryNullableTypeObject {
            return {
                string: null,
                boolean: null,
                timestamp: null,
            };
        },
        validate(input): input is ObjectWithEveryNullableTypeObject {
            return (
                isObject(input) &&
                (typeof input.string === "string" || input.string === null) &&
                (typeof input.boolean === "boolean" ||
                    input.boolean === null) &&
                (input.timestamp instanceof Date || input.timestamp === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableTypeObject {
            let _string: string | null;
            if (typeof input.string === "string") {
                _string = input.string;
            } else {
                _string = null;
            }
            let _boolean: boolean | null;
            if (typeof input.boolean === "boolean") {
                _boolean = input.boolean;
            } else {
                _boolean = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            return {
                string: _string,
                boolean: _boolean,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): ObjectWithEveryNullableTypeObject {
            return $$ObjectWithEveryNullableTypeObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"string":';
            if (typeof input.string === "string") {
                json += serializeString(input.string);
            } else {
                json += "null";
            }
            json += ',"boolean":';
            json += `${input.boolean}`;
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += "null";
            }
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`string=${input.string}`);
            queryParts.push(`boolean=${input.boolean}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            return queryParts.join("&");
        },
    };

export type ObjectWithEveryNullableTypeDiscriminator =
    | ObjectWithEveryNullableTypeDiscriminatorA
    | ObjectWithEveryNullableTypeDiscriminatorB;
export const $$ObjectWithEveryNullableTypeDiscriminator: ArriModelValidator<ObjectWithEveryNullableTypeDiscriminator> =
    {
        new(): ObjectWithEveryNullableTypeDiscriminator {
            return $$ObjectWithEveryNullableTypeDiscriminatorA.new();
        },
        validate(input): input is ObjectWithEveryNullableTypeDiscriminator {
            if (!isObject(input)) {
                return false;
            }
            if (typeof input.type !== "string") {
                return false;
            }
            switch (input.type) {
                case "A":
                    return $$ObjectWithEveryNullableTypeDiscriminatorA.validate(
                        input,
                    );
                case "B":
                    return $$ObjectWithEveryNullableTypeDiscriminatorB.validate(
                        input,
                    );
                default:
                    return false;
            }
        },
        fromJson(input): ObjectWithEveryNullableTypeDiscriminator {
            switch (input.type) {
                case "A":
                    return $$ObjectWithEveryNullableTypeDiscriminatorA.fromJson(
                        input,
                    );
                case "B":
                    return $$ObjectWithEveryNullableTypeDiscriminatorB.fromJson(
                        input,
                    );
                default:
                    return $$ObjectWithEveryNullableTypeDiscriminatorA.new();
            }
        },
        fromJsonString(input): ObjectWithEveryNullableTypeDiscriminator {
            return $$ObjectWithEveryNullableTypeDiscriminator.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            switch (input.type) {
                case "A":
                    return $$ObjectWithEveryNullableTypeDiscriminatorA.toJsonString(
                        input,
                    );
                case "B":
                    return $$ObjectWithEveryNullableTypeDiscriminatorB.toJsonString(
                        input,
                    );
                default:
                    throw new Error(`Unhandled case "${(input as any).type}"`);
            }
        },
        toUrlQueryString(input): string {
            switch (input.type) {
                case "A":
                    return $$ObjectWithEveryNullableTypeDiscriminatorA.toUrlQueryString(
                        input,
                    );
                case "B":
                    return $$ObjectWithEveryNullableTypeDiscriminatorB.toUrlQueryString(
                        input,
                    );
                default:
                    throw new Error("Unhandled case");
            }
        },
    };
export interface ObjectWithEveryNullableTypeDiscriminatorA {
    type: "A";
    title: string | null;
}
const $$ObjectWithEveryNullableTypeDiscriminatorA: ArriModelValidator<ObjectWithEveryNullableTypeDiscriminatorA> =
    {
        new(): ObjectWithEveryNullableTypeDiscriminatorA {
            return {
                type: "A",
                title: null,
            };
        },
        validate(input): input is ObjectWithEveryNullableTypeDiscriminatorA {
            return (
                isObject(input) &&
                input.type === "A" &&
                (typeof input.title === "string" || input.title === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableTypeDiscriminatorA {
            const _type = "A";
            let _title: string | null;
            if (typeof input.title === "string") {
                _title = input.title;
            } else {
                _title = null;
            }
            return {
                type: _type,
                title: _title,
            };
        },
        fromJsonString(input): ObjectWithEveryNullableTypeDiscriminatorA {
            return $$ObjectWithEveryNullableTypeDiscriminatorA.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"type":"A"';
            json += ',"title":';
            if (typeof input.title === "string") {
                json += serializeString(input.title);
            } else {
                json += "null";
            }
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push("type=A");
            queryParts.push(`title=${input.title}`);
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryNullableTypeDiscriminatorB {
    type: "B";
    title: string | null;
    description: string | null;
}
const $$ObjectWithEveryNullableTypeDiscriminatorB: ArriModelValidator<ObjectWithEveryNullableTypeDiscriminatorB> =
    {
        new(): ObjectWithEveryNullableTypeDiscriminatorB {
            return {
                type: "B",
                title: null,
                description: null,
            };
        },
        validate(input): input is ObjectWithEveryNullableTypeDiscriminatorB {
            return (
                isObject(input) &&
                input.type === "B" &&
                (typeof input.title === "string" || input.title === null) &&
                (typeof input.description === "string" ||
                    input.description === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableTypeDiscriminatorB {
            const _type = "B";
            let _title: string | null;
            if (typeof input.title === "string") {
                _title = input.title;
            } else {
                _title = null;
            }
            let _description: string | null;
            if (typeof input.description === "string") {
                _description = input.description;
            } else {
                _description = null;
            }
            return {
                type: _type,
                title: _title,
                description: _description,
            };
        },
        fromJsonString(input): ObjectWithEveryNullableTypeDiscriminatorB {
            return $$ObjectWithEveryNullableTypeDiscriminatorB.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"type":"B"';
            json += ',"title":';
            if (typeof input.title === "string") {
                json += serializeString(input.title);
            } else {
                json += "null";
            }
            json += ',"description":';
            if (typeof input.description === "string") {
                json += serializeString(input.description);
            } else {
                json += "null";
            }
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push("type=B");
            queryParts.push(`title=${input.title}`);
            queryParts.push(`description=${input.description}`);
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryNullableTypeNestedObject {
    id: string | null;
    timestamp: Date | null;
    data: ObjectWithEveryNullableTypeNestedObjectData | null;
}
export const $$ObjectWithEveryNullableTypeNestedObject: ArriModelValidator<ObjectWithEveryNullableTypeNestedObject> =
    {
        new(): ObjectWithEveryNullableTypeNestedObject {
            return {
                id: null,
                timestamp: null,
                data: null,
            };
        },
        validate(input): input is ObjectWithEveryNullableTypeNestedObject {
            return (
                isObject(input) &&
                (typeof input.id === "string" || input.id === null) &&
                (input.timestamp instanceof Date || input.timestamp === null) &&
                ($$ObjectWithEveryNullableTypeNestedObjectData.validate(
                    input.data,
                ) ||
                    input.data === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableTypeNestedObject {
            let _id: string | null;
            if (typeof input.id === "string") {
                _id = input.id;
            } else {
                _id = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            let _data: ObjectWithEveryNullableTypeNestedObjectData | null;
            if (isObject(input.data)) {
                _data = $$ObjectWithEveryNullableTypeNestedObjectData.fromJson(
                    input.data,
                );
            } else {
                _data = null;
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): ObjectWithEveryNullableTypeNestedObject {
            return $$ObjectWithEveryNullableTypeNestedObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"id":';
            if (typeof input.id === "string") {
                json += serializeString(input.id);
            } else {
                json += "null";
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += "null";
            }
            json += ',"data":';
            if (input.data !== null) {
                json +=
                    $$ObjectWithEveryNullableTypeNestedObjectData.toJsonString(
                        input.data,
                    );
            } else {
                json += "null";
            }
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            console.warn(
                "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableTypeNestedObject/data.",
            );
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryNullableTypeNestedObjectData {
    id: string | null;
    timestamp: Date | null;
    data: ObjectWithEveryNullableTypeNestedObjectDataData | null;
}
export const $$ObjectWithEveryNullableTypeNestedObjectData: ArriModelValidator<ObjectWithEveryNullableTypeNestedObjectData> =
    {
        new(): ObjectWithEveryNullableTypeNestedObjectData {
            return {
                id: null,
                timestamp: null,
                data: null,
            };
        },
        validate(input): input is ObjectWithEveryNullableTypeNestedObjectData {
            return (
                isObject(input) &&
                (typeof input.id === "string" || input.id === null) &&
                (input.timestamp instanceof Date || input.timestamp === null) &&
                ($$ObjectWithEveryNullableTypeNestedObjectDataData.validate(
                    input.data,
                ) ||
                    input.data === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableTypeNestedObjectData {
            let _id: string | null;
            if (typeof input.id === "string") {
                _id = input.id;
            } else {
                _id = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            let _data: ObjectWithEveryNullableTypeNestedObjectDataData | null;
            if (isObject(input.data)) {
                _data =
                    $$ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
                        input.data,
                    );
            } else {
                _data = null;
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): ObjectWithEveryNullableTypeNestedObjectData {
            return $$ObjectWithEveryNullableTypeNestedObjectData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"id":';
            if (typeof input.id === "string") {
                json += serializeString(input.id);
            } else {
                json += "null";
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += "null";
            }
            json += ',"data":';
            if (input.data !== null) {
                json +=
                    $$ObjectWithEveryNullableTypeNestedObjectDataData.toJsonString(
                        input.data,
                    );
            } else {
                json += "null";
            }
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            console.warn(
                "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableTypeNestedObjectData/data.",
            );
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryNullableTypeNestedObjectDataData {
    id: string | null;
    timestamp: Date | null;
}
export const $$ObjectWithEveryNullableTypeNestedObjectDataData: ArriModelValidator<ObjectWithEveryNullableTypeNestedObjectDataData> =
    {
        new(): ObjectWithEveryNullableTypeNestedObjectDataData {
            return {
                id: null,
                timestamp: null,
            };
        },
        validate(
            input,
        ): input is ObjectWithEveryNullableTypeNestedObjectDataData {
            return (
                isObject(input) &&
                (typeof input.id === "string" || input.id === null) &&
                (input.timestamp instanceof Date || input.timestamp === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableTypeNestedObjectDataData {
            let _id: string | null;
            if (typeof input.id === "string") {
                _id = input.id;
            } else {
                _id = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): ObjectWithEveryNullableTypeNestedObjectDataData {
            return $$ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"id":';
            if (typeof input.id === "string") {
                json += serializeString(input.id);
            } else {
                json += "null";
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += "null";
            }
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryNullableTypeNestedArrayelementelement {
    id: string | null;
    timestamp: Date | null;
}
export const $$ObjectWithEveryNullableTypeNestedArrayelementelement: ArriModelValidator<ObjectWithEveryNullableTypeNestedArrayelementelement> =
    {
        new(): ObjectWithEveryNullableTypeNestedArrayelementelement {
            return {
                id: null,
                timestamp: null,
            };
        },
        validate(
            input,
        ): input is ObjectWithEveryNullableTypeNestedArrayelementelement {
            return (
                isObject(input) &&
                (typeof input.id === "string" || input.id === null) &&
                (input.timestamp instanceof Date || input.timestamp === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableTypeNestedArrayelementelement {
            let _id: string | null;
            if (typeof input.id === "string") {
                _id = input.id;
            } else {
                _id = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(
            input,
        ): ObjectWithEveryNullableTypeNestedArrayelementelement {
            return $$ObjectWithEveryNullableTypeNestedArrayelementelement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"id":';
            if (typeof input.id === "string") {
                json += serializeString(input.id);
            } else {
                json += "null";
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += "null";
            }
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryOptionalType {
    any?: any;
    boolean?: boolean;
    string?: string;
    timestamp?: Date;
    float32?: number;
    float64?: number;
    int8?: number;
    uint8?: number;
    int16?: number;
    uint16?: number;
    int32?: number;
    uint32?: number;
    int64?: bigint;
    uint64?: bigint;
    enumerator?: ObjectWithEveryOptionalTypeEnumerator;
    array?: boolean[];
    object?: ObjectWithEveryOptionalTypeObject;
    record?: Record<string, boolean>;
    discriminator?: ObjectWithEveryOptionalTypeDiscriminator;
    nestedObject?: ObjectWithEveryOptionalTypeNestedObject;
    nestedArray?: ObjectWithEveryOptionalTypeNestedArrayelementelement[][];
}
export const $$ObjectWithEveryOptionalType: ArriModelValidator<ObjectWithEveryOptionalType> =
    {
        new(): ObjectWithEveryOptionalType {
            return {};
        },
        validate(input): input is ObjectWithEveryOptionalType {
            return (
                isObject(input) &&
                (true || typeof input.any === "undefined") &&
                (typeof input.boolean === "boolean" ||
                    typeof input.boolean === "undefined") &&
                (typeof input.string === "string" ||
                    typeof input.string === "undefined") &&
                (input.timestamp instanceof Date ||
                    typeof input.timestamp === "undefined") &&
                (typeof input.float32 === "number" ||
                    typeof input.float32 === "undefined") &&
                (typeof input.float64 === "number" ||
                    typeof input.float64 === "undefined") &&
                ((typeof input.int8 === "number" &&
                    Number.isInteger(input.int8) &&
                    input.int8 >= INT8_MIN &&
                    input.int8 <= INT8_MAX) ||
                    typeof input.int8 === "undefined") &&
                ((typeof input.uint8 === "number" &&
                    Number.isInteger(input.uint8) &&
                    input.uint8 >= 0 &&
                    input.uint8 <= UINT8_MAX) ||
                    typeof input.uint8 === "undefined") &&
                ((typeof input.int16 === "number" &&
                    Number.isInteger(input.int16) &&
                    input.int16 >= INT16_MIN &&
                    input.int16 <= INT16_MAX) ||
                    typeof input.int16 === "undefined") &&
                ((typeof input.uint16 === "number" &&
                    Number.isInteger(input.uint16) &&
                    input.uint16 >= 0 &&
                    input.uint16 <= UINT16_MAX) ||
                    typeof input.uint16 === "undefined") &&
                ((typeof input.int32 === "number" &&
                    Number.isInteger(input.int32) &&
                    input.int32 >= INT32_MIN &&
                    input.int32 <= INT32_MAX) ||
                    typeof input.int32 === "undefined") &&
                ((typeof input.uint32 === "number" &&
                    Number.isInteger(input.uint32) &&
                    input.uint32 >= 0 &&
                    input.uint32 <= UINT32_MAX) ||
                    typeof input.uint32 === "undefined") &&
                ((typeof input.int64 === "bigint" &&
                    input.int64 >= INT64_MIN &&
                    input.int64 <= INT64_MAX) ||
                    typeof input.int64 === "undefined") &&
                ((typeof input.uint64 === "bigint" &&
                    input.uint64 >= BigInt(0) &&
                    input.uint64 <= UINT64_MAX) ||
                    typeof input.uint64 === "undefined") &&
                ($$ObjectWithEveryOptionalTypeEnumerator.validate(
                    input.enumerator,
                ) ||
                    typeof input.enumerator === "undefined") &&
                ((Array.isArray(input.array) &&
                    input.array.every(
                        (_element) => typeof _element === "boolean",
                    )) ||
                    typeof input.array === "undefined") &&
                ($$ObjectWithEveryOptionalTypeObject.validate(input.object) ||
                    typeof input.object === "undefined") &&
                ((isObject(input.record) &&
                    Object.values(input.record).every(
                        (_value) => typeof _value === "boolean",
                    )) ||
                    typeof input.record === "undefined") &&
                ($$ObjectWithEveryOptionalTypeDiscriminator.validate(
                    input.discriminator,
                ) ||
                    typeof input.discriminator === "undefined") &&
                ($$ObjectWithEveryOptionalTypeNestedObject.validate(
                    input.nestedObject,
                ) ||
                    typeof input.nestedObject === "undefined") &&
                ((Array.isArray(input.nestedArray) &&
                    input.nestedArray.every(
                        (_element) =>
                            Array.isArray(_element) &&
                            _element.every((_element) =>
                                $$ObjectWithEveryOptionalTypeNestedArrayelementelement.validate(
                                    _element,
                                ),
                            ),
                    )) ||
                    typeof input.nestedArray === "undefined")
            );
        },
        fromJson(input): ObjectWithEveryOptionalType {
            let _any: any | undefined;
            if (typeof input.any !== "undefined") {
                _any = input.any;
            }
            let _boolean: boolean | undefined;
            if (typeof input.boolean !== "undefined") {
                if (typeof input.boolean === "boolean") {
                    _boolean = input.boolean;
                } else {
                    _boolean = false;
                }
            }
            let _string: string | undefined;
            if (typeof input.string !== "undefined") {
                if (typeof input.string === "string") {
                    _string = input.string;
                } else {
                    _string = "";
                }
            }
            let _timestamp: Date | undefined;
            if (typeof input.timestamp !== "undefined") {
                if (typeof input.timestamp === "string") {
                    _timestamp = new Date(input.timestamp);
                } else if (input.timestamp instanceof Date) {
                    _timestamp = input.timestamp;
                } else {
                    _timestamp = new Date();
                }
            }
            let _float32: number | undefined;
            if (typeof input.float32 !== "undefined") {
                if (typeof input.float32 === "number") {
                    _float32 = input.float32;
                } else {
                    _float32 = 0;
                }
            }
            let _float64: number | undefined;
            if (typeof input.float64 !== "undefined") {
                if (typeof input.float64 === "number") {
                    _float64 = input.float64;
                } else {
                    _float64 = 0;
                }
            }
            let _int8: number | undefined;
            if (typeof input.int8 !== "undefined") {
                if (
                    typeof input.int8 === "number" &&
                    Number.isInteger(input.int8) &&
                    input.int8 >= INT8_MIN &&
                    input.int8 <= INT8_MAX
                ) {
                    _int8 = input.int8;
                } else {
                    _int8 = 0;
                }
            }
            let _uint8: number | undefined;
            if (typeof input.uint8 !== "undefined") {
                if (
                    typeof input.uint8 === "number" &&
                    Number.isInteger(input.uint8) &&
                    input.uint8 >= 0 &&
                    input.uint8 <= UINT8_MAX
                ) {
                    _uint8 = input.uint8;
                } else {
                    _uint8 = 0;
                }
            }
            let _int16: number | undefined;
            if (typeof input.int16 !== "undefined") {
                if (
                    typeof input.int16 === "number" &&
                    Number.isInteger(input.int16) &&
                    input.int16 >= INT16_MIN &&
                    input.int16 <= INT16_MAX
                ) {
                    _int16 = input.int16;
                } else {
                    _int16 = 0;
                }
            }
            let _uint16: number | undefined;
            if (typeof input.uint16 !== "undefined") {
                if (
                    typeof input.uint16 === "number" &&
                    Number.isInteger(input.uint16) &&
                    input.uint16 >= 0 &&
                    input.uint16 <= UINT16_MAX
                ) {
                    _uint16 = input.uint16;
                } else {
                    _uint16 = 0;
                }
            }
            let _int32: number | undefined;
            if (typeof input.int32 !== "undefined") {
                if (
                    typeof input.int32 === "number" &&
                    Number.isInteger(input.int32) &&
                    input.int32 >= INT32_MIN &&
                    input.int32 <= INT32_MAX
                ) {
                    _int32 = input.int32;
                } else {
                    _int32 = 0;
                }
            }
            let _uint32: number | undefined;
            if (typeof input.uint32 !== "undefined") {
                if (
                    typeof input.uint32 === "number" &&
                    Number.isInteger(input.uint32) &&
                    input.uint32 >= 0 &&
                    input.uint32 <= UINT32_MAX
                ) {
                    _uint32 = input.uint32;
                } else {
                    _uint32 = 0;
                }
            }
            let _int64: bigint | undefined;
            if (typeof input.int64 !== "undefined") {
                if (typeof input.int64 === "string") {
                    _int64 = BigInt(input.int64);
                } else if (typeof input.int64 === "bigint") {
                    _int64 = input.int64;
                } else {
                    _int64 = BigInt(0);
                }
            }
            let _uint64: bigint | undefined;
            if (typeof input.uint64 !== "undefined") {
                if (
                    typeof input.uint64 === "string" &&
                    BigInt(input.uint64) >= BigInt(0)
                ) {
                    _uint64 = BigInt(input.uint64);
                } else if (
                    typeof input.uint64 === "bigint" &&
                    input.uint64 >= BigInt(0)
                ) {
                    _uint64 = input.uint64;
                } else {
                    _uint64 = BigInt(0);
                }
            }
            let _enumerator: ObjectWithEveryOptionalTypeEnumerator | undefined;
            if (typeof input.enumerator !== "undefined") {
                if (typeof input.enumerator === "string") {
                    _enumerator =
                        $$ObjectWithEveryOptionalTypeEnumerator.fromSerialValue(
                            input.enumerator,
                        );
                } else {
                    _enumerator = $$ObjectWithEveryOptionalTypeEnumerator.new();
                }
            }
            let _array: boolean[] | undefined;
            if (typeof input.array !== "undefined") {
                if (Array.isArray(input.array)) {
                    _array = [];
                    for (const _arrayEl of input.array) {
                        let _arrayElValue: boolean;
                        if (typeof _arrayEl === "boolean") {
                            _arrayElValue = _arrayEl;
                        } else {
                            _arrayElValue = false;
                        }
                        _array.push(_arrayElValue);
                    }
                } else {
                    _array = [];
                }
            }
            let _object: ObjectWithEveryOptionalTypeObject | undefined;
            if (typeof input.object !== "undefined") {
                if (isObject(input.object)) {
                    _object = $$ObjectWithEveryOptionalTypeObject.fromJson(
                        input.object,
                    );
                } else {
                    _object = $$ObjectWithEveryOptionalTypeObject.new();
                }
            }
            let _record: Record<string, boolean> | undefined;
            if (typeof input.record !== "undefined") {
                if (isObject(input.record)) {
                    _record = {};
                    for (const [_key, _value] of Object.entries(input.record)) {
                        let _recordValue: boolean;
                        if (typeof _value === "boolean") {
                            _recordValue = _value;
                        } else {
                            _recordValue = false;
                        }
                        _record[_key] = _recordValue;
                    }
                } else {
                    _record = {};
                }
            }
            let _discriminator:
                | ObjectWithEveryOptionalTypeDiscriminator
                | undefined;
            if (typeof input.discriminator !== "undefined") {
                if (isObject(input.discriminator)) {
                    _discriminator =
                        $$ObjectWithEveryOptionalTypeDiscriminator.fromJson(
                            input.discriminator,
                        );
                } else {
                    _discriminator =
                        $$ObjectWithEveryOptionalTypeDiscriminator.new();
                }
            }
            let _nestedObject:
                | ObjectWithEveryOptionalTypeNestedObject
                | undefined;
            if (typeof input.nestedObject !== "undefined") {
                if (isObject(input.nestedObject)) {
                    _nestedObject =
                        $$ObjectWithEveryOptionalTypeNestedObject.fromJson(
                            input.nestedObject,
                        );
                } else {
                    _nestedObject =
                        $$ObjectWithEveryOptionalTypeNestedObject.new();
                }
            }
            let _nestedArray:
                | ObjectWithEveryOptionalTypeNestedArrayelementelement[][]
                | undefined;
            if (typeof input.nestedArray !== "undefined") {
                if (Array.isArray(input.nestedArray)) {
                    _nestedArray = [];
                    for (const _nestedArrayEl of input.nestedArray) {
                        let _nestedArrayElValue: ObjectWithEveryOptionalTypeNestedArrayelementelement[];
                        if (Array.isArray(_nestedArrayEl)) {
                            _nestedArrayElValue = [];
                            for (const _nestedArrayElValueEl of _nestedArrayEl) {
                                let _nestedArrayElValueElValue: ObjectWithEveryOptionalTypeNestedArrayelementelement;
                                if (isObject(_nestedArrayElValueEl)) {
                                    _nestedArrayElValueElValue =
                                        $$ObjectWithEveryOptionalTypeNestedArrayelementelement.fromJson(
                                            _nestedArrayElValueEl,
                                        );
                                } else {
                                    _nestedArrayElValueElValue =
                                        $$ObjectWithEveryOptionalTypeNestedArrayelementelement.new();
                                }
                                _nestedArrayElValue.push(
                                    _nestedArrayElValueElValue,
                                );
                            }
                        } else {
                            _nestedArrayElValue = [];
                        }
                        _nestedArray.push(_nestedArrayElValue);
                    }
                } else {
                    _nestedArray = [];
                }
            }
            return {
                any: _any,
                boolean: _boolean,
                string: _string,
                timestamp: _timestamp,
                float32: _float32,
                float64: _float64,
                int8: _int8,
                uint8: _uint8,
                int16: _int16,
                uint16: _uint16,
                int32: _int32,
                uint32: _uint32,
                int64: _int64,
                uint64: _uint64,
                enumerator: _enumerator,
                array: _array,
                object: _object,
                record: _record,
                discriminator: _discriminator,
                nestedObject: _nestedObject,
                nestedArray: _nestedArray,
            };
        },
        fromJsonString(input): ObjectWithEveryOptionalType {
            return $$ObjectWithEveryOptionalType.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = "{";
            let _hasKey = false;
            if (typeof input.any !== "undefined") {
                if (_hasKey) json += ",";
                json += '"any":';
                json += JSON.stringify(input.any);
                _hasKey = true;
            }
            if (typeof input.boolean !== "undefined") {
                if (_hasKey) json += ",";
                json += '"boolean":';
                json += `${input.boolean}`;
                _hasKey = true;
            }
            if (typeof input.string !== "undefined") {
                if (_hasKey) json += ",";
                json += '"string":';
                json += serializeString(input.string);
                _hasKey = true;
            }
            if (typeof input.timestamp !== "undefined") {
                if (_hasKey) json += ",";
                json += '"timestamp":';
                json += `"${input.timestamp.toISOString()}"`;
                _hasKey = true;
            }
            if (typeof input.float32 !== "undefined") {
                if (_hasKey) json += ",";
                json += '"float32":';
                json += `${input.float32}`;
                _hasKey = true;
            }
            if (typeof input.float64 !== "undefined") {
                if (_hasKey) json += ",";
                json += '"float64":';
                json += `${input.float64}`;
                _hasKey = true;
            }
            if (typeof input.int8 !== "undefined") {
                if (_hasKey) json += ",";
                json += '"int8":';
                json += `${input.int8}`;
                _hasKey = true;
            }
            if (typeof input.uint8 !== "undefined") {
                if (_hasKey) json += ",";
                json += '"uint8":';
                json += `${input.uint8}`;
                _hasKey = true;
            }
            if (typeof input.int16 !== "undefined") {
                if (_hasKey) json += ",";
                json += '"int16":';
                json += `${input.int16}`;
                _hasKey = true;
            }
            if (typeof input.uint16 !== "undefined") {
                if (_hasKey) json += ",";
                json += '"uint16":';
                json += `${input.uint16}`;
                _hasKey = true;
            }
            if (typeof input.int32 !== "undefined") {
                if (_hasKey) json += ",";
                json += '"int32":';
                json += `${input.int32}`;
                _hasKey = true;
            }
            if (typeof input.uint32 !== "undefined") {
                if (_hasKey) json += ",";
                json += '"uint32":';
                json += `${input.uint32}`;
                _hasKey = true;
            }
            if (typeof input.int64 !== "undefined") {
                if (_hasKey) json += ",";
                json += '"int64":';
                json += `"${input.int64}"`;
                _hasKey = true;
            }
            if (typeof input.uint64 !== "undefined") {
                if (_hasKey) json += ",";
                json += '"uint64":';
                json += `"${input.uint64}"`;
                _hasKey = true;
            }
            if (typeof input.enumerator !== "undefined") {
                if (_hasKey) json += ",";
                json += '"enumerator":';
                json += `"${input.enumerator}"`;
                _hasKey = true;
            }
            if (typeof input.array !== "undefined") {
                if (_hasKey) json += ",";
                json += '"array":';
                json += "[";
                for (let i = 0; i < input.array.length; i++) {
                    if (i !== 0) json += ",";
                    const _inputArrayEl = input.array[i];
                    json += `${_inputArrayEl}`;
                }
                json += "]";
                _hasKey = true;
            }
            if (typeof input.object !== "undefined") {
                if (_hasKey) json += ",";
                json += '"object":';
                json += $$ObjectWithEveryOptionalTypeObject.toJsonString(
                    input.object,
                );
                _hasKey = true;
            }
            if (typeof input.record !== "undefined") {
                if (_hasKey) json += ",";
                json += '"record":';
                json += "{";
                let _recordPropertyCount = 0;
                for (const [_key, _value] of Object.entries(input.record)) {
                    if (_recordPropertyCount !== 0) {
                        json += ",";
                    }
                    json += `"${_key}":`;
                    json += `${_value}`;
                    _recordPropertyCount++;
                }
                json += "}";

                _hasKey = true;
            }
            if (typeof input.discriminator !== "undefined") {
                if (_hasKey) json += ",";
                json += '"discriminator":';
                json += $$ObjectWithEveryOptionalTypeDiscriminator.toJsonString(
                    input.discriminator,
                );
                _hasKey = true;
            }
            if (typeof input.nestedObject !== "undefined") {
                if (_hasKey) json += ",";
                json += '"nestedObject":';
                json += $$ObjectWithEveryOptionalTypeNestedObject.toJsonString(
                    input.nestedObject,
                );
                _hasKey = true;
            }
            if (typeof input.nestedArray !== "undefined") {
                if (_hasKey) json += ",";
                json += '"nestedArray":';
                json += "[";
                for (let i = 0; i < input.nestedArray.length; i++) {
                    if (i !== 0) json += ",";
                    const _inputNestedArrayEl = input.nestedArray[i];
                    json += "[";
                    for (let i = 0; i < _inputNestedArrayEl.length; i++) {
                        if (i !== 0) json += ",";
                        const _inputNestedArrayElEl = _inputNestedArrayEl[i];
                        json +=
                            $$ObjectWithEveryOptionalTypeNestedArrayelementelement.toJsonString(
                                _inputNestedArrayElEl,
                            );
                    }
                    json += "]";
                }
                json += "]";
                _hasKey = true;
            }
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            if (typeof input.any !== "undefined") {
                console.warn(
                    "[WARNING] Cannot serialize any's to query string. Skipping property at /ObjectWithEveryOptionalType/any.",
                );
            }
            if (typeof input.boolean !== "undefined") {
                queryParts.push(`boolean=${input.boolean}`);
            }
            if (typeof input.string !== "undefined") {
                queryParts.push(`string=${input.string}`);
            }
            if (typeof input.timestamp !== "undefined") {
                queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            }
            if (typeof input.float32 !== "undefined") {
                queryParts.push(`float32=${input.float32}`);
            }
            if (typeof input.float64 !== "undefined") {
                queryParts.push(`float64=${input.float64}`);
            }
            if (typeof input.int8 !== "undefined") {
                queryParts.push(`int8=${input.int8}`);
            }
            if (typeof input.uint8 !== "undefined") {
                queryParts.push(`uint8=${input.uint8}`);
            }
            if (typeof input.int16 !== "undefined") {
                queryParts.push(`int16=${input.int16}`);
            }
            if (typeof input.uint16 !== "undefined") {
                queryParts.push(`uint16=${input.uint16}`);
            }
            if (typeof input.int32 !== "undefined") {
                queryParts.push(`int32=${input.int32}`);
            }
            if (typeof input.uint32 !== "undefined") {
                queryParts.push(`uint32=${input.uint32}`);
            }
            if (typeof input.int64 !== "undefined") {
                queryParts.push(`int64=${input.int64}`);
            }
            if (typeof input.uint64 !== "undefined") {
                queryParts.push(`uint64=${input.uint64}`);
            }
            if (typeof input.enumerator !== "undefined") {
                queryParts.push(`enumerator=${input.enumerator}`);
            }
            if (typeof input.array !== "undefined") {
                console.warn(
                    "[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryOptionalType/array.",
                );
            }
            if (typeof input.object !== "undefined") {
                console.warn(
                    "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalType/object.",
                );
            }
            if (typeof input.record !== "undefined") {
                console.warn(
                    "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalType/record.",
                );
            }
            if (typeof input.discriminator !== "undefined") {
                console.warn(
                    "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalType/discriminator.",
                );
            }
            if (typeof input.nestedObject !== "undefined") {
                console.warn(
                    "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalType/nestedObject.",
                );
            }
            if (typeof input.nestedArray !== "undefined") {
                console.warn(
                    "[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryOptionalType/nestedArray.",
                );
            }
            return queryParts.join("&");
        },
    };

export type ObjectWithEveryOptionalTypeEnumerator =
    (typeof $$ObjectWithEveryOptionalTypeEnumeratorValues)[number];
const $$ObjectWithEveryOptionalTypeEnumeratorValues = ["A", "B", "C"] as const;
export const $$ObjectWithEveryOptionalTypeEnumerator: ArriEnumValidator<ObjectWithEveryOptionalTypeEnumerator> =
    {
        new(): ObjectWithEveryOptionalTypeEnumerator {
            return $$ObjectWithEveryOptionalTypeEnumeratorValues[0];
        },
        validate(input): input is ObjectWithEveryOptionalTypeEnumerator {
            return (
                typeof input === "string" &&
                $$ObjectWithEveryOptionalTypeEnumeratorValues.includes(
                    input as any,
                )
            );
        },
        values: $$ObjectWithEveryOptionalTypeEnumeratorValues,
        fromSerialValue(input): ObjectWithEveryOptionalTypeEnumerator {
            if (
                $$ObjectWithEveryOptionalTypeEnumeratorValues.includes(
                    input as any,
                )
            ) {
                return input as ObjectWithEveryOptionalTypeEnumerator;
            }
            if (
                $$ObjectWithEveryOptionalTypeEnumeratorValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as ObjectWithEveryOptionalTypeEnumerator;
            }
            if (
                $$ObjectWithEveryOptionalTypeEnumeratorValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as ObjectWithEveryOptionalTypeEnumerator;
            }
            return "A";
        },
    };

export interface ObjectWithEveryOptionalTypeObject {
    string: string;
    boolean: boolean;
    timestamp: Date;
}
export const $$ObjectWithEveryOptionalTypeObject: ArriModelValidator<ObjectWithEveryOptionalTypeObject> =
    {
        new(): ObjectWithEveryOptionalTypeObject {
            return {
                string: "",
                boolean: false,
                timestamp: new Date(),
            };
        },
        validate(input): input is ObjectWithEveryOptionalTypeObject {
            return (
                isObject(input) &&
                typeof input.string === "string" &&
                typeof input.boolean === "boolean" &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): ObjectWithEveryOptionalTypeObject {
            let _string: string;
            if (typeof input.string === "string") {
                _string = input.string;
            } else {
                _string = "";
            }
            let _boolean: boolean;
            if (typeof input.boolean === "boolean") {
                _boolean = input.boolean;
            } else {
                _boolean = false;
            }
            let _timestamp: Date;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                string: _string,
                boolean: _boolean,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): ObjectWithEveryOptionalTypeObject {
            return $$ObjectWithEveryOptionalTypeObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"string":';
            json += serializeString(input.string);
            json += ',"boolean":';
            json += `${input.boolean}`;
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`string=${input.string}`);
            queryParts.push(`boolean=${input.boolean}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join("&");
        },
    };

export type ObjectWithEveryOptionalTypeDiscriminator =
    | ObjectWithEveryOptionalTypeDiscriminatorA
    | ObjectWithEveryOptionalTypeDiscriminatorB;
export const $$ObjectWithEveryOptionalTypeDiscriminator: ArriModelValidator<ObjectWithEveryOptionalTypeDiscriminator> =
    {
        new(): ObjectWithEveryOptionalTypeDiscriminator {
            return $$ObjectWithEveryOptionalTypeDiscriminatorA.new();
        },
        validate(input): input is ObjectWithEveryOptionalTypeDiscriminator {
            if (!isObject(input)) {
                return false;
            }
            if (typeof input.type !== "string") {
                return false;
            }
            switch (input.type) {
                case "A":
                    return $$ObjectWithEveryOptionalTypeDiscriminatorA.validate(
                        input,
                    );
                case "B":
                    return $$ObjectWithEveryOptionalTypeDiscriminatorB.validate(
                        input,
                    );
                default:
                    return false;
            }
        },
        fromJson(input): ObjectWithEveryOptionalTypeDiscriminator {
            switch (input.type) {
                case "A":
                    return $$ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
                        input,
                    );
                case "B":
                    return $$ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
                        input,
                    );
                default:
                    return $$ObjectWithEveryOptionalTypeDiscriminatorA.new();
            }
        },
        fromJsonString(input): ObjectWithEveryOptionalTypeDiscriminator {
            return $$ObjectWithEveryOptionalTypeDiscriminator.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            switch (input.type) {
                case "A":
                    return $$ObjectWithEveryOptionalTypeDiscriminatorA.toJsonString(
                        input,
                    );
                case "B":
                    return $$ObjectWithEveryOptionalTypeDiscriminatorB.toJsonString(
                        input,
                    );
                default:
                    throw new Error(`Unhandled case "${(input as any).type}"`);
            }
        },
        toUrlQueryString(input): string {
            switch (input.type) {
                case "A":
                    return $$ObjectWithEveryOptionalTypeDiscriminatorA.toUrlQueryString(
                        input,
                    );
                case "B":
                    return $$ObjectWithEveryOptionalTypeDiscriminatorB.toUrlQueryString(
                        input,
                    );
                default:
                    throw new Error("Unhandled case");
            }
        },
    };
export interface ObjectWithEveryOptionalTypeDiscriminatorA {
    type: "A";
    title: string;
}
const $$ObjectWithEveryOptionalTypeDiscriminatorA: ArriModelValidator<ObjectWithEveryOptionalTypeDiscriminatorA> =
    {
        new(): ObjectWithEveryOptionalTypeDiscriminatorA {
            return {
                type: "A",
                title: "",
            };
        },
        validate(input): input is ObjectWithEveryOptionalTypeDiscriminatorA {
            return (
                isObject(input) &&
                input.type === "A" &&
                typeof input.title === "string"
            );
        },
        fromJson(input): ObjectWithEveryOptionalTypeDiscriminatorA {
            const _type = "A";
            let _title: string;
            if (typeof input.title === "string") {
                _title = input.title;
            } else {
                _title = "";
            }
            return {
                type: _type,
                title: _title,
            };
        },
        fromJsonString(input): ObjectWithEveryOptionalTypeDiscriminatorA {
            return $$ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"type":"A"';
            json += ',"title":';
            json += serializeString(input.title);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push("type=A");
            queryParts.push(`title=${input.title}`);
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryOptionalTypeDiscriminatorB {
    type: "B";
    title: string;
    description: string;
}
const $$ObjectWithEveryOptionalTypeDiscriminatorB: ArriModelValidator<ObjectWithEveryOptionalTypeDiscriminatorB> =
    {
        new(): ObjectWithEveryOptionalTypeDiscriminatorB {
            return {
                type: "B",
                title: "",
                description: "",
            };
        },
        validate(input): input is ObjectWithEveryOptionalTypeDiscriminatorB {
            return (
                isObject(input) &&
                input.type === "B" &&
                typeof input.title === "string" &&
                typeof input.description === "string"
            );
        },
        fromJson(input): ObjectWithEveryOptionalTypeDiscriminatorB {
            const _type = "B";
            let _title: string;
            if (typeof input.title === "string") {
                _title = input.title;
            } else {
                _title = "";
            }
            let _description: string;
            if (typeof input.description === "string") {
                _description = input.description;
            } else {
                _description = "";
            }
            return {
                type: _type,
                title: _title,
                description: _description,
            };
        },
        fromJsonString(input): ObjectWithEveryOptionalTypeDiscriminatorB {
            return $$ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"type":"B"';
            json += ',"title":';
            json += serializeString(input.title);
            json += ',"description":';
            json += serializeString(input.description);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push("type=B");
            queryParts.push(`title=${input.title}`);
            queryParts.push(`description=${input.description}`);
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryOptionalTypeNestedObject {
    id: string;
    timestamp: Date;
    data: ObjectWithEveryOptionalTypeNestedObjectData;
}
export const $$ObjectWithEveryOptionalTypeNestedObject: ArriModelValidator<ObjectWithEveryOptionalTypeNestedObject> =
    {
        new(): ObjectWithEveryOptionalTypeNestedObject {
            return {
                id: "",
                timestamp: new Date(),
                data: $$ObjectWithEveryOptionalTypeNestedObjectData.new(),
            };
        },
        validate(input): input is ObjectWithEveryOptionalTypeNestedObject {
            return (
                isObject(input) &&
                typeof input.id === "string" &&
                input.timestamp instanceof Date &&
                $$ObjectWithEveryOptionalTypeNestedObjectData.validate(
                    input.data,
                )
            );
        },
        fromJson(input): ObjectWithEveryOptionalTypeNestedObject {
            let _id: string;
            if (typeof input.id === "string") {
                _id = input.id;
            } else {
                _id = "";
            }
            let _timestamp: Date;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            let _data: ObjectWithEveryOptionalTypeNestedObjectData;
            if (isObject(input.data)) {
                _data = $$ObjectWithEveryOptionalTypeNestedObjectData.fromJson(
                    input.data,
                );
            } else {
                _data = $$ObjectWithEveryOptionalTypeNestedObjectData.new();
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): ObjectWithEveryOptionalTypeNestedObject {
            return $$ObjectWithEveryOptionalTypeNestedObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += ',"data":';
            json += $$ObjectWithEveryOptionalTypeNestedObjectData.toJsonString(
                input.data,
            );
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            console.warn(
                "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalTypeNestedObject/data.",
            );
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryOptionalTypeNestedObjectData {
    id: string;
    timestamp: Date;
    data: ObjectWithEveryOptionalTypeNestedObjectDataData;
}
export const $$ObjectWithEveryOptionalTypeNestedObjectData: ArriModelValidator<ObjectWithEveryOptionalTypeNestedObjectData> =
    {
        new(): ObjectWithEveryOptionalTypeNestedObjectData {
            return {
                id: "",
                timestamp: new Date(),
                data: $$ObjectWithEveryOptionalTypeNestedObjectDataData.new(),
            };
        },
        validate(input): input is ObjectWithEveryOptionalTypeNestedObjectData {
            return (
                isObject(input) &&
                typeof input.id === "string" &&
                input.timestamp instanceof Date &&
                $$ObjectWithEveryOptionalTypeNestedObjectDataData.validate(
                    input.data,
                )
            );
        },
        fromJson(input): ObjectWithEveryOptionalTypeNestedObjectData {
            let _id: string;
            if (typeof input.id === "string") {
                _id = input.id;
            } else {
                _id = "";
            }
            let _timestamp: Date;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            let _data: ObjectWithEveryOptionalTypeNestedObjectDataData;
            if (isObject(input.data)) {
                _data =
                    $$ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
                        input.data,
                    );
            } else {
                _data = $$ObjectWithEveryOptionalTypeNestedObjectDataData.new();
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): ObjectWithEveryOptionalTypeNestedObjectData {
            return $$ObjectWithEveryOptionalTypeNestedObjectData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += ',"data":';
            json +=
                $$ObjectWithEveryOptionalTypeNestedObjectDataData.toJsonString(
                    input.data,
                );
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            console.warn(
                "[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalTypeNestedObjectData/data.",
            );
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryOptionalTypeNestedObjectDataData {
    id: string;
    timestamp: Date;
}
export const $$ObjectWithEveryOptionalTypeNestedObjectDataData: ArriModelValidator<ObjectWithEveryOptionalTypeNestedObjectDataData> =
    {
        new(): ObjectWithEveryOptionalTypeNestedObjectDataData {
            return {
                id: "",
                timestamp: new Date(),
            };
        },
        validate(
            input,
        ): input is ObjectWithEveryOptionalTypeNestedObjectDataData {
            return (
                isObject(input) &&
                typeof input.id === "string" &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): ObjectWithEveryOptionalTypeNestedObjectDataData {
            let _id: string;
            if (typeof input.id === "string") {
                _id = input.id;
            } else {
                _id = "";
            }
            let _timestamp: Date;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): ObjectWithEveryOptionalTypeNestedObjectDataData {
            return $$ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join("&");
        },
    };

export interface ObjectWithEveryOptionalTypeNestedArrayelementelement {
    id: string;
    timestamp: Date;
}
export const $$ObjectWithEveryOptionalTypeNestedArrayelementelement: ArriModelValidator<ObjectWithEveryOptionalTypeNestedArrayelementelement> =
    {
        new(): ObjectWithEveryOptionalTypeNestedArrayelementelement {
            return {
                id: "",
                timestamp: new Date(),
            };
        },
        validate(
            input,
        ): input is ObjectWithEveryOptionalTypeNestedArrayelementelement {
            return (
                isObject(input) &&
                typeof input.id === "string" &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): ObjectWithEveryOptionalTypeNestedArrayelementelement {
            let _id: string;
            if (typeof input.id === "string") {
                _id = input.id;
            } else {
                _id = "";
            }
            let _timestamp: Date;
            if (typeof input.timestamp === "string") {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(
            input,
        ): ObjectWithEveryOptionalTypeNestedArrayelementelement {
            return $$ObjectWithEveryOptionalTypeNestedArrayelementelement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join("&");
        },
    };

export interface RecursiveObject {
    left: RecursiveObject | null;
    right: RecursiveObject | null;
    value: string;
}
export const $$RecursiveObject: ArriModelValidator<RecursiveObject> = {
    new(): RecursiveObject {
        return {
            left: null,
            right: null,
            value: "",
        };
    },
    validate(input): input is RecursiveObject {
        return (
            isObject(input) &&
            ($$RecursiveObject.validate(input.left) || input.left === null) &&
            ($$RecursiveObject.validate(input.right) || input.right === null) &&
            typeof input.value === "string"
        );
    },
    fromJson(input): RecursiveObject {
        let _left: RecursiveObject | null;
        if (isObject(input.left)) {
            _left = $$RecursiveObject.fromJson(input.left);
        } else {
            _left = null;
        }
        let _right: RecursiveObject | null;
        if (isObject(input.right)) {
            _right = $$RecursiveObject.fromJson(input.right);
        } else {
            _right = null;
        }
        let _value: string;
        if (typeof input.value === "string") {
            _value = input.value;
        } else {
            _value = "";
        }
        return {
            left: _left,
            right: _right,
            value: _value,
        };
    },
    fromJsonString(input): RecursiveObject {
        return $$RecursiveObject.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"left":';
        if (input.left !== null) {
            json += $$RecursiveObject.toJsonString(input.left);
        } else {
            json += "null";
        }
        json += ',"right":';
        if (input.right !== null) {
            json += $$RecursiveObject.toJsonString(input.right);
        } else {
            json += "null";
        }
        json += ',"value":';
        json += serializeString(input.value);
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        console.warn(
            "[WARNING] Nested objects cannot be serialized to query string. Ignoring property at /RecursiveObject/left.",
        );
        console.warn(
            "[WARNING] Nested objects cannot be serialized to query string. Ignoring property at /RecursiveObject/right.",
        );
        queryParts.push(`value=${input.value}`);
        return queryParts.join("&");
    },
};

export type RecursiveUnion =
    | RecursiveUnionChild
    | RecursiveUnionChildren
    | RecursiveUnionText
    | RecursiveUnionShape;
export const $$RecursiveUnion: ArriModelValidator<RecursiveUnion> = {
    new(): RecursiveUnion {
        return $$RecursiveUnionChild.new();
    },
    validate(input): input is RecursiveUnion {
        if (!isObject(input)) {
            return false;
        }
        if (typeof input.type !== "string") {
            return false;
        }
        switch (input.type) {
            case "CHILD":
                return $$RecursiveUnionChild.validate(input);
            case "CHILDREN":
                return $$RecursiveUnionChildren.validate(input);
            case "TEXT":
                return $$RecursiveUnionText.validate(input);
            case "SHAPE":
                return $$RecursiveUnionShape.validate(input);
            default:
                return false;
        }
    },
    fromJson(input): RecursiveUnion {
        switch (input.type) {
            case "CHILD":
                return $$RecursiveUnionChild.fromJson(input);
            case "CHILDREN":
                return $$RecursiveUnionChildren.fromJson(input);
            case "TEXT":
                return $$RecursiveUnionText.fromJson(input);
            case "SHAPE":
                return $$RecursiveUnionShape.fromJson(input);
            default:
                return $$RecursiveUnionChild.new();
        }
    },
    fromJsonString(input): RecursiveUnion {
        return $$RecursiveUnion.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        switch (input.type) {
            case "CHILD":
                return $$RecursiveUnionChild.toJsonString(input);
            case "CHILDREN":
                return $$RecursiveUnionChildren.toJsonString(input);
            case "TEXT":
                return $$RecursiveUnionText.toJsonString(input);
            case "SHAPE":
                return $$RecursiveUnionShape.toJsonString(input);
            default:
                throw new Error(`Unhandled case "${(input as any).type}"`);
        }
    },
    toUrlQueryString(input): string {
        switch (input.type) {
            case "CHILD":
                return $$RecursiveUnionChild.toUrlQueryString(input);
            case "CHILDREN":
                return $$RecursiveUnionChildren.toUrlQueryString(input);
            case "TEXT":
                return $$RecursiveUnionText.toUrlQueryString(input);
            case "SHAPE":
                return $$RecursiveUnionShape.toUrlQueryString(input);
            default:
                throw new Error("Unhandled case");
        }
    },
};
/**
 * Child node
 */
export interface RecursiveUnionChild {
    type: "CHILD";
    data: RecursiveUnion;
}
const $$RecursiveUnionChild: ArriModelValidator<RecursiveUnionChild> = {
    new(): RecursiveUnionChild {
        return {
            type: "CHILD",
            data: RecursiveUnion.new(),
        };
    },
    validate(input): input is RecursiveUnionChild {
        return (
            isObject(input) &&
            input.type === "CHILD" &&
            $$RecursiveUnion.validate(input.data)
        );
    },
    fromJson(input): RecursiveUnionChild {
        const _type = "CHILD";
        let _data: RecursiveUnion;
        if (isObject(input.data)) {
            _data = $$RecursiveUnion.fromJson(input.data);
        } else {
            _data = RecursiveUnion.new();
        }
        return {
            type: _type,
            data: _data,
        };
    },
    fromJsonString(input): RecursiveUnionChild {
        return $$RecursiveUnionChild.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"type":"CHILD"';
        json += ',"data":';
        json += $$RecursiveUnion.toJsonString(input.data);
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push("type=CHILD");
        console.warn(
            "[WARNING] Nested objects cannot be serialized to query string. Ignoring property at /RecursiveUnionChild/data.",
        );
        return queryParts.join("&");
    },
};

/**
 * List of children node
 */
export interface RecursiveUnionChildren {
    type: "CHILDREN";
    data: RecursiveUnion[];
}
const $$RecursiveUnionChildren: ArriModelValidator<RecursiveUnionChildren> = {
    new(): RecursiveUnionChildren {
        return {
            type: "CHILDREN",
            data: [],
        };
    },
    validate(input): input is RecursiveUnionChildren {
        return (
            isObject(input) &&
            input.type === "CHILDREN" &&
            Array.isArray(input.data) &&
            input.data.every((_element) => $$RecursiveUnion.validate(_element))
        );
    },
    fromJson(input): RecursiveUnionChildren {
        const _type = "CHILDREN";
        let _data: RecursiveUnion[];
        if (Array.isArray(input.data)) {
            _data = [];
            for (const _dataEl of input.data) {
                let _dataElValue: RecursiveUnion;
                if (isObject(_dataEl)) {
                    _dataElValue = $$RecursiveUnion.fromJson(_dataEl);
                } else {
                    _dataElValue = RecursiveUnion.new();
                }
                _data.push(_dataElValue);
            }
        } else {
            _data = [];
        }
        return {
            type: _type,
            data: _data,
        };
    },
    fromJsonString(input): RecursiveUnionChildren {
        return $$RecursiveUnionChildren.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"type":"CHILDREN"';
        json += ',"data":';
        json += "[";
        for (let i = 0; i < input.data.length; i++) {
            if (i !== 0) json += ",";
            const _inputDataEl = input.data[i];
            json += $$RecursiveUnion.toJsonString(_inputDataEl);
        }
        json += "]";
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push("type=CHILDREN");
        console.warn(
            "[WARNING] Cannot serialize arrays to query string. Skipping property at /RecursiveUnionChildren/data.",
        );
        return queryParts.join("&");
    },
};

/**
 * Text node
 */
export interface RecursiveUnionText {
    type: "TEXT";
    data: string;
}
const $$RecursiveUnionText: ArriModelValidator<RecursiveUnionText> = {
    new(): RecursiveUnionText {
        return {
            type: "TEXT",
            data: "",
        };
    },
    validate(input): input is RecursiveUnionText {
        return (
            isObject(input) &&
            input.type === "TEXT" &&
            typeof input.data === "string"
        );
    },
    fromJson(input): RecursiveUnionText {
        const _type = "TEXT";
        let _data: string;
        if (typeof input.data === "string") {
            _data = input.data;
        } else {
            _data = "";
        }
        return {
            type: _type,
            data: _data,
        };
    },
    fromJsonString(input): RecursiveUnionText {
        return $$RecursiveUnionText.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"type":"TEXT"';
        json += ',"data":';
        json += serializeString(input.data);
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push("type=TEXT");
        queryParts.push(`data=${input.data}`);
        return queryParts.join("&");
    },
};

/**
 * Shape node
 */
export interface RecursiveUnionShape {
    type: "SHAPE";
    data: RecursiveUnionShapeData;
}
const $$RecursiveUnionShape: ArriModelValidator<RecursiveUnionShape> = {
    new(): RecursiveUnionShape {
        return {
            type: "SHAPE",
            data: $$RecursiveUnionShapeData.new(),
        };
    },
    validate(input): input is RecursiveUnionShape {
        return (
            isObject(input) &&
            input.type === "SHAPE" &&
            $$RecursiveUnionShapeData.validate(input.data)
        );
    },
    fromJson(input): RecursiveUnionShape {
        const _type = "SHAPE";
        let _data: RecursiveUnionShapeData;
        if (isObject(input.data)) {
            _data = $$RecursiveUnionShapeData.fromJson(input.data);
        } else {
            _data = $$RecursiveUnionShapeData.new();
        }
        return {
            type: _type,
            data: _data,
        };
    },
    fromJsonString(input): RecursiveUnionShape {
        return $$RecursiveUnionShape.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"type":"SHAPE"';
        json += ',"data":';
        json += $$RecursiveUnionShapeData.toJsonString(input.data);
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push("type=SHAPE");
        console.warn(
            "[WARNING] Cannot serialize nested objects to query string. Skipping property at /RecursiveUnionShape/data.",
        );
        return queryParts.join("&");
    },
};

export interface RecursiveUnionShapeData {
    width: number;
    height: number;
    color: string;
}
export const $$RecursiveUnionShapeData: ArriModelValidator<RecursiveUnionShapeData> =
    {
        new(): RecursiveUnionShapeData {
            return {
                width: 0,
                height: 0,
                color: "",
            };
        },
        validate(input): input is RecursiveUnionShapeData {
            return (
                isObject(input) &&
                typeof input.width === "number" &&
                typeof input.height === "number" &&
                typeof input.color === "string"
            );
        },
        fromJson(input): RecursiveUnionShapeData {
            let _width: number;
            if (typeof input.width === "number") {
                _width = input.width;
            } else {
                _width = 0;
            }
            let _height: number;
            if (typeof input.height === "number") {
                _height = input.height;
            } else {
                _height = 0;
            }
            let _color: string;
            if (typeof input.color === "string") {
                _color = input.color;
            } else {
                _color = "";
            }
            return {
                width: _width,
                height: _height,
                color: _color,
            };
        },
        fromJsonString(input): RecursiveUnionShapeData {
            return $$RecursiveUnionShapeData.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = "{";
            json += '"width":';
            json += `${input.width}`;
            json += ',"height":';
            json += `${input.height}`;
            json += ',"color":';
            json += serializeString(input.color);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`width=${input.width}`);
            queryParts.push(`height=${input.height}`);
            queryParts.push(`color=${input.color}`);
            return queryParts.join("&");
        },
    };

export interface AutoReconnectParams {
    messageCount: number;
}
export const $$AutoReconnectParams: ArriModelValidator<AutoReconnectParams> = {
    new(): AutoReconnectParams {
        return {
            messageCount: 0,
        };
    },
    validate(input): input is AutoReconnectParams {
        return (
            isObject(input) &&
            typeof input.messageCount === "number" &&
            Number.isInteger(input.messageCount) &&
            input.messageCount >= 0 &&
            input.messageCount <= UINT8_MAX
        );
    },
    fromJson(input): AutoReconnectParams {
        let _messageCount: number;
        if (
            typeof input.messageCount === "number" &&
            Number.isInteger(input.messageCount) &&
            input.messageCount >= 0 &&
            input.messageCount <= UINT8_MAX
        ) {
            _messageCount = input.messageCount;
        } else {
            _messageCount = 0;
        }
        return {
            messageCount: _messageCount,
        };
    },
    fromJsonString(input): AutoReconnectParams {
        return $$AutoReconnectParams.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"messageCount":';
        json += `${input.messageCount}`;
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`messageCount=${input.messageCount}`);
        return queryParts.join("&");
    },
};

export interface AutoReconnectResponse {
    count: number;
    message: string;
}
export const $$AutoReconnectResponse: ArriModelValidator<AutoReconnectResponse> =
    {
        new(): AutoReconnectResponse {
            return {
                count: 0,
                message: "",
            };
        },
        validate(input): input is AutoReconnectResponse {
            return (
                isObject(input) &&
                typeof input.count === "number" &&
                Number.isInteger(input.count) &&
                input.count >= 0 &&
                input.count <= UINT8_MAX &&
                typeof input.message === "string"
            );
        },
        fromJson(input): AutoReconnectResponse {
            let _count: number;
            if (
                typeof input.count === "number" &&
                Number.isInteger(input.count) &&
                input.count >= 0 &&
                input.count <= UINT8_MAX
            ) {
                _count = input.count;
            } else {
                _count = 0;
            }
            let _message: string;
            if (typeof input.message === "string") {
                _message = input.message;
            } else {
                _message = "";
            }
            return {
                count: _count,
                message: _message,
            };
        },
        fromJsonString(input): AutoReconnectResponse {
            return $$AutoReconnectResponse.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = "{";
            json += '"count":';
            json += `${input.count}`;
            json += ',"message":';
            json += serializeString(input.message);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`count=${input.count}`);
            queryParts.push(`message=${input.message}`);
            return queryParts.join("&");
        },
    };

export interface StreamConnectionErrorTestParams {
    statusCode: number;
    statusMessage: string;
}
export const $$StreamConnectionErrorTestParams: ArriModelValidator<StreamConnectionErrorTestParams> =
    {
        new(): StreamConnectionErrorTestParams {
            return {
                statusCode: 0,
                statusMessage: "",
            };
        },
        validate(input): input is StreamConnectionErrorTestParams {
            return (
                isObject(input) &&
                typeof input.statusCode === "number" &&
                Number.isInteger(input.statusCode) &&
                input.statusCode >= INT32_MIN &&
                input.statusCode <= INT32_MAX &&
                typeof input.statusMessage === "string"
            );
        },
        fromJson(input): StreamConnectionErrorTestParams {
            let _statusCode: number;
            if (
                typeof input.statusCode === "number" &&
                Number.isInteger(input.statusCode) &&
                input.statusCode >= INT32_MIN &&
                input.statusCode <= INT32_MAX
            ) {
                _statusCode = input.statusCode;
            } else {
                _statusCode = 0;
            }
            let _statusMessage: string;
            if (typeof input.statusMessage === "string") {
                _statusMessage = input.statusMessage;
            } else {
                _statusMessage = "";
            }
            return {
                statusCode: _statusCode,
                statusMessage: _statusMessage,
            };
        },
        fromJsonString(input): StreamConnectionErrorTestParams {
            return $$StreamConnectionErrorTestParams.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"statusCode":';
            json += `${input.statusCode}`;
            json += ',"statusMessage":';
            json += serializeString(input.statusMessage);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`statusCode=${input.statusCode}`);
            queryParts.push(`statusMessage=${input.statusMessage}`);
            return queryParts.join("&");
        },
    };

export interface StreamConnectionErrorTestResponse {
    message: string;
}
export const $$StreamConnectionErrorTestResponse: ArriModelValidator<StreamConnectionErrorTestResponse> =
    {
        new(): StreamConnectionErrorTestResponse {
            return {
                message: "",
            };
        },
        validate(input): input is StreamConnectionErrorTestResponse {
            return isObject(input) && typeof input.message === "string";
        },
        fromJson(input): StreamConnectionErrorTestResponse {
            let _message: string;
            if (typeof input.message === "string") {
                _message = input.message;
            } else {
                _message = "";
            }
            return {
                message: _message,
            };
        },
        fromJsonString(input): StreamConnectionErrorTestResponse {
            return $$StreamConnectionErrorTestResponse.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"message":';
            json += serializeString(input.message);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`message=${input.message}`);
            return queryParts.join("&");
        },
    };

export interface StreamLargeObjectsResponse {
    numbers: number[];
    objects: StreamLargeObjectsResponseObjectselement[];
}
export const $$StreamLargeObjectsResponse: ArriModelValidator<StreamLargeObjectsResponse> =
    {
        new(): StreamLargeObjectsResponse {
            return {
                numbers: [],
                objects: [],
            };
        },
        validate(input): input is StreamLargeObjectsResponse {
            return (
                isObject(input) &&
                Array.isArray(input.numbers) &&
                input.numbers.every(
                    (_element) => typeof _element === "number",
                ) &&
                Array.isArray(input.objects) &&
                input.objects.every((_element) =>
                    $$StreamLargeObjectsResponseObjectselement.validate(
                        _element,
                    ),
                )
            );
        },
        fromJson(input): StreamLargeObjectsResponse {
            let _numbers: number[];
            if (Array.isArray(input.numbers)) {
                _numbers = [];
                for (const _numbersEl of input.numbers) {
                    let _numbersElValue: number;
                    if (typeof _numbersEl === "number") {
                        _numbersElValue = _numbersEl;
                    } else {
                        _numbersElValue = 0;
                    }
                    _numbers.push(_numbersElValue);
                }
            } else {
                _numbers = [];
            }
            let _objects: StreamLargeObjectsResponseObjectselement[];
            if (Array.isArray(input.objects)) {
                _objects = [];
                for (const _objectsEl of input.objects) {
                    let _objectsElValue: StreamLargeObjectsResponseObjectselement;
                    if (isObject(_objectsEl)) {
                        _objectsElValue =
                            $$StreamLargeObjectsResponseObjectselement.fromJson(
                                _objectsEl,
                            );
                    } else {
                        _objectsElValue =
                            $$StreamLargeObjectsResponseObjectselement.new();
                    }
                    _objects.push(_objectsElValue);
                }
            } else {
                _objects = [];
            }
            return {
                numbers: _numbers,
                objects: _objects,
            };
        },
        fromJsonString(input): StreamLargeObjectsResponse {
            return $$StreamLargeObjectsResponse.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = "{";
            json += '"numbers":';
            json += "[";
            for (let i = 0; i < input.numbers.length; i++) {
                if (i !== 0) json += ",";
                const _inputNumbersEl = input.numbers[i];
                json += `${_inputNumbersEl}`;
            }
            json += "]";
            json += ',"objects":';
            json += "[";
            for (let i = 0; i < input.objects.length; i++) {
                if (i !== 0) json += ",";
                const _inputObjectsEl = input.objects[i];
                json +=
                    $$StreamLargeObjectsResponseObjectselement.toJsonString(
                        _inputObjectsEl,
                    );
            }
            json += "]";
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            console.warn(
                "[WARNING] Cannot serialize arrays to query string. Skipping property at /StreamLargeObjectsResponse/numbers.",
            );
            console.warn(
                "[WARNING] Cannot serialize arrays to query string. Skipping property at /StreamLargeObjectsResponse/objects.",
            );
            return queryParts.join("&");
        },
    };

export interface StreamLargeObjectsResponseObjectselement {
    id: string;
    name: string;
    email: string;
}
export const $$StreamLargeObjectsResponseObjectselement: ArriModelValidator<StreamLargeObjectsResponseObjectselement> =
    {
        new(): StreamLargeObjectsResponseObjectselement {
            return {
                id: "",
                name: "",
                email: "",
            };
        },
        validate(input): input is StreamLargeObjectsResponseObjectselement {
            return (
                isObject(input) &&
                typeof input.id === "string" &&
                typeof input.name === "string" &&
                typeof input.email === "string"
            );
        },
        fromJson(input): StreamLargeObjectsResponseObjectselement {
            let _id: string;
            if (typeof input.id === "string") {
                _id = input.id;
            } else {
                _id = "";
            }
            let _name: string;
            if (typeof input.name === "string") {
                _name = input.name;
            } else {
                _name = "";
            }
            let _email: string;
            if (typeof input.email === "string") {
                _email = input.email;
            } else {
                _email = "";
            }
            return {
                id: _id,
                name: _name,
                email: _email,
            };
        },
        fromJsonString(input): StreamLargeObjectsResponseObjectselement {
            return $$StreamLargeObjectsResponseObjectselement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"id":';
            json += serializeString(input.id);
            json += ',"name":';
            json += serializeString(input.name);
            json += ',"email":';
            json += serializeString(input.email);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`name=${input.name}`);
            queryParts.push(`email=${input.email}`);
            return queryParts.join("&");
        },
    };

export interface ChatMessageParams {
    channelId: string;
}
export const $$ChatMessageParams: ArriModelValidator<ChatMessageParams> = {
    new(): ChatMessageParams {
        return {
            channelId: "",
        };
    },
    validate(input): input is ChatMessageParams {
        return isObject(input) && typeof input.channelId === "string";
    },
    fromJson(input): ChatMessageParams {
        let _channelId: string;
        if (typeof input.channelId === "string") {
            _channelId = input.channelId;
        } else {
            _channelId = "";
        }
        return {
            channelId: _channelId,
        };
    },
    fromJsonString(input): ChatMessageParams {
        return $$ChatMessageParams.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"channelId":';
        json += serializeString(input.channelId);
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`channelId=${input.channelId}`);
        return queryParts.join("&");
    },
};

export type ChatMessage = ChatMessageText | ChatMessageImage | ChatMessageUrl;
export const $$ChatMessage: ArriModelValidator<ChatMessage> = {
    new(): ChatMessage {
        return $$ChatMessageText.new();
    },
    validate(input): input is ChatMessage {
        if (!isObject(input)) {
            return false;
        }
        if (typeof input.messageType !== "string") {
            return false;
        }
        switch (input.messageType) {
            case "TEXT":
                return $$ChatMessageText.validate(input);
            case "IMAGE":
                return $$ChatMessageImage.validate(input);
            case "URL":
                return $$ChatMessageUrl.validate(input);
            default:
                return false;
        }
    },
    fromJson(input): ChatMessage {
        switch (input.messageType) {
            case "TEXT":
                return $$ChatMessageText.fromJson(input);
            case "IMAGE":
                return $$ChatMessageImage.fromJson(input);
            case "URL":
                return $$ChatMessageUrl.fromJson(input);
            default:
                return $$ChatMessageText.new();
        }
    },
    fromJsonString(input): ChatMessage {
        return $$ChatMessage.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        switch (input.messageType) {
            case "TEXT":
                return $$ChatMessageText.toJsonString(input);
            case "IMAGE":
                return $$ChatMessageImage.toJsonString(input);
            case "URL":
                return $$ChatMessageUrl.toJsonString(input);
            default:
                throw new Error(
                    `Unhandled case "${(input as any).messageType}"`,
                );
        }
    },
    toUrlQueryString(input): string {
        switch (input.messageType) {
            case "TEXT":
                return $$ChatMessageText.toUrlQueryString(input);
            case "IMAGE":
                return $$ChatMessageImage.toUrlQueryString(input);
            case "URL":
                return $$ChatMessageUrl.toUrlQueryString(input);
            default:
                throw new Error("Unhandled case");
        }
    },
};
export interface ChatMessageText {
    messageType: "TEXT";
    id: string;
    channelId: string;
    userId: string;
    date: Date;
    text: string;
}
const $$ChatMessageText: ArriModelValidator<ChatMessageText> = {
    new(): ChatMessageText {
        return {
            messageType: "TEXT",
            id: "",
            channelId: "",
            userId: "",
            date: new Date(),
            text: "",
        };
    },
    validate(input): input is ChatMessageText {
        return (
            isObject(input) &&
            input.messageType === "TEXT" &&
            typeof input.id === "string" &&
            typeof input.channelId === "string" &&
            typeof input.userId === "string" &&
            input.date instanceof Date &&
            typeof input.text === "string"
        );
    },
    fromJson(input): ChatMessageText {
        const _messageType = "TEXT";
        let _id: string;
        if (typeof input.id === "string") {
            _id = input.id;
        } else {
            _id = "";
        }
        let _channelId: string;
        if (typeof input.channelId === "string") {
            _channelId = input.channelId;
        } else {
            _channelId = "";
        }
        let _userId: string;
        if (typeof input.userId === "string") {
            _userId = input.userId;
        } else {
            _userId = "";
        }
        let _date: Date;
        if (typeof input.date === "string") {
            _date = new Date(input.date);
        } else if (input.date instanceof Date) {
            _date = input.date;
        } else {
            _date = new Date();
        }
        let _text: string;
        if (typeof input.text === "string") {
            _text = input.text;
        } else {
            _text = "";
        }
        return {
            messageType: _messageType,
            id: _id,
            channelId: _channelId,
            userId: _userId,
            date: _date,
            text: _text,
        };
    },
    fromJsonString(input): ChatMessageText {
        return $$ChatMessageText.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"messageType":"TEXT"';
        json += ',"id":';
        json += serializeString(input.id);
        json += ',"channelId":';
        json += serializeString(input.channelId);
        json += ',"userId":';
        json += serializeString(input.userId);
        json += ',"date":';
        json += `"${input.date.toISOString()}"`;
        json += ',"text":';
        json += serializeString(input.text);
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push("messageType=TEXT");
        queryParts.push(`id=${input.id}`);
        queryParts.push(`channelId=${input.channelId}`);
        queryParts.push(`userId=${input.userId}`);
        queryParts.push(`date=${input.date.toISOString()}`);
        queryParts.push(`text=${input.text}`);
        return queryParts.join("&");
    },
};

export interface ChatMessageImage {
    messageType: "IMAGE";
    id: string;
    channelId: string;
    userId: string;
    date: Date;
    image: string;
}
const $$ChatMessageImage: ArriModelValidator<ChatMessageImage> = {
    new(): ChatMessageImage {
        return {
            messageType: "IMAGE",
            id: "",
            channelId: "",
            userId: "",
            date: new Date(),
            image: "",
        };
    },
    validate(input): input is ChatMessageImage {
        return (
            isObject(input) &&
            input.messageType === "IMAGE" &&
            typeof input.id === "string" &&
            typeof input.channelId === "string" &&
            typeof input.userId === "string" &&
            input.date instanceof Date &&
            typeof input.image === "string"
        );
    },
    fromJson(input): ChatMessageImage {
        const _messageType = "IMAGE";
        let _id: string;
        if (typeof input.id === "string") {
            _id = input.id;
        } else {
            _id = "";
        }
        let _channelId: string;
        if (typeof input.channelId === "string") {
            _channelId = input.channelId;
        } else {
            _channelId = "";
        }
        let _userId: string;
        if (typeof input.userId === "string") {
            _userId = input.userId;
        } else {
            _userId = "";
        }
        let _date: Date;
        if (typeof input.date === "string") {
            _date = new Date(input.date);
        } else if (input.date instanceof Date) {
            _date = input.date;
        } else {
            _date = new Date();
        }
        let _image: string;
        if (typeof input.image === "string") {
            _image = input.image;
        } else {
            _image = "";
        }
        return {
            messageType: _messageType,
            id: _id,
            channelId: _channelId,
            userId: _userId,
            date: _date,
            image: _image,
        };
    },
    fromJsonString(input): ChatMessageImage {
        return $$ChatMessageImage.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"messageType":"IMAGE"';
        json += ',"id":';
        json += serializeString(input.id);
        json += ',"channelId":';
        json += serializeString(input.channelId);
        json += ',"userId":';
        json += serializeString(input.userId);
        json += ',"date":';
        json += `"${input.date.toISOString()}"`;
        json += ',"image":';
        json += serializeString(input.image);
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push("messageType=IMAGE");
        queryParts.push(`id=${input.id}`);
        queryParts.push(`channelId=${input.channelId}`);
        queryParts.push(`userId=${input.userId}`);
        queryParts.push(`date=${input.date.toISOString()}`);
        queryParts.push(`image=${input.image}`);
        return queryParts.join("&");
    },
};

export interface ChatMessageUrl {
    messageType: "URL";
    id: string;
    channelId: string;
    userId: string;
    date: Date;
    url: string;
}
const $$ChatMessageUrl: ArriModelValidator<ChatMessageUrl> = {
    new(): ChatMessageUrl {
        return {
            messageType: "URL",
            id: "",
            channelId: "",
            userId: "",
            date: new Date(),
            url: "",
        };
    },
    validate(input): input is ChatMessageUrl {
        return (
            isObject(input) &&
            input.messageType === "URL" &&
            typeof input.id === "string" &&
            typeof input.channelId === "string" &&
            typeof input.userId === "string" &&
            input.date instanceof Date &&
            typeof input.url === "string"
        );
    },
    fromJson(input): ChatMessageUrl {
        const _messageType = "URL";
        let _id: string;
        if (typeof input.id === "string") {
            _id = input.id;
        } else {
            _id = "";
        }
        let _channelId: string;
        if (typeof input.channelId === "string") {
            _channelId = input.channelId;
        } else {
            _channelId = "";
        }
        let _userId: string;
        if (typeof input.userId === "string") {
            _userId = input.userId;
        } else {
            _userId = "";
        }
        let _date: Date;
        if (typeof input.date === "string") {
            _date = new Date(input.date);
        } else if (input.date instanceof Date) {
            _date = input.date;
        } else {
            _date = new Date();
        }
        let _url: string;
        if (typeof input.url === "string") {
            _url = input.url;
        } else {
            _url = "";
        }
        return {
            messageType: _messageType,
            id: _id,
            channelId: _channelId,
            userId: _userId,
            date: _date,
            url: _url,
        };
    },
    fromJsonString(input): ChatMessageUrl {
        return $$ChatMessageUrl.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"messageType":"URL"';
        json += ',"id":';
        json += serializeString(input.id);
        json += ',"channelId":';
        json += serializeString(input.channelId);
        json += ',"userId":';
        json += serializeString(input.userId);
        json += ',"date":';
        json += `"${input.date.toISOString()}"`;
        json += ',"url":';
        json += serializeString(input.url);
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push("messageType=URL");
        queryParts.push(`id=${input.id}`);
        queryParts.push(`channelId=${input.channelId}`);
        queryParts.push(`userId=${input.userId}`);
        queryParts.push(`date=${input.date.toISOString()}`);
        queryParts.push(`url=${input.url}`);
        return queryParts.join("&");
    },
};

export interface TestsStreamRetryWithNewCredentialsResponse {
    message: string;
}
export const $$TestsStreamRetryWithNewCredentialsResponse: ArriModelValidator<TestsStreamRetryWithNewCredentialsResponse> =
    {
        new(): TestsStreamRetryWithNewCredentialsResponse {
            return {
                message: "",
            };
        },
        validate(input): input is TestsStreamRetryWithNewCredentialsResponse {
            return isObject(input) && typeof input.message === "string";
        },
        fromJson(input): TestsStreamRetryWithNewCredentialsResponse {
            let _message: string;
            if (typeof input.message === "string") {
                _message = input.message;
            } else {
                _message = "";
            }
            return {
                message: _message,
            };
        },
        fromJsonString(input): TestsStreamRetryWithNewCredentialsResponse {
            return $$TestsStreamRetryWithNewCredentialsResponse.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"message":';
            json += serializeString(input.message);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`message=${input.message}`);
            return queryParts.join("&");
        },
    };

export type WsMessageParams =
    | WsMessageParamsCreateEntity
    | WsMessageParamsUpdateEntity
    | WsMessageParamsDisconnect;
export const $$WsMessageParams: ArriModelValidator<WsMessageParams> = {
    new(): WsMessageParams {
        return $$WsMessageParamsCreateEntity.new();
    },
    validate(input): input is WsMessageParams {
        if (!isObject(input)) {
            return false;
        }
        if (typeof input.type !== "string") {
            return false;
        }
        switch (input.type) {
            case "CREATE_ENTITY":
                return $$WsMessageParamsCreateEntity.validate(input);
            case "UPDATE_ENTITY":
                return $$WsMessageParamsUpdateEntity.validate(input);
            case "DISCONNECT":
                return $$WsMessageParamsDisconnect.validate(input);
            default:
                return false;
        }
    },
    fromJson(input): WsMessageParams {
        switch (input.type) {
            case "CREATE_ENTITY":
                return $$WsMessageParamsCreateEntity.fromJson(input);
            case "UPDATE_ENTITY":
                return $$WsMessageParamsUpdateEntity.fromJson(input);
            case "DISCONNECT":
                return $$WsMessageParamsDisconnect.fromJson(input);
            default:
                return $$WsMessageParamsCreateEntity.new();
        }
    },
    fromJsonString(input): WsMessageParams {
        return $$WsMessageParams.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        switch (input.type) {
            case "CREATE_ENTITY":
                return $$WsMessageParamsCreateEntity.toJsonString(input);
            case "UPDATE_ENTITY":
                return $$WsMessageParamsUpdateEntity.toJsonString(input);
            case "DISCONNECT":
                return $$WsMessageParamsDisconnect.toJsonString(input);
            default:
                throw new Error(`Unhandled case "${(input as any).type}"`);
        }
    },
    toUrlQueryString(input): string {
        switch (input.type) {
            case "CREATE_ENTITY":
                return $$WsMessageParamsCreateEntity.toUrlQueryString(input);
            case "UPDATE_ENTITY":
                return $$WsMessageParamsUpdateEntity.toUrlQueryString(input);
            case "DISCONNECT":
                return $$WsMessageParamsDisconnect.toUrlQueryString(input);
            default:
                throw new Error("Unhandled case");
        }
    },
};
export interface WsMessageParamsCreateEntity {
    type: "CREATE_ENTITY";
    entityId: string;
    x: number;
    y: number;
}
const $$WsMessageParamsCreateEntity: ArriModelValidator<WsMessageParamsCreateEntity> =
    {
        new(): WsMessageParamsCreateEntity {
            return {
                type: "CREATE_ENTITY",
                entityId: "",
                x: 0,
                y: 0,
            };
        },
        validate(input): input is WsMessageParamsCreateEntity {
            return (
                isObject(input) &&
                input.type === "CREATE_ENTITY" &&
                typeof input.entityId === "string" &&
                typeof input.x === "number" &&
                typeof input.y === "number"
            );
        },
        fromJson(input): WsMessageParamsCreateEntity {
            const _type = "CREATE_ENTITY";
            let _entityId: string;
            if (typeof input.entityId === "string") {
                _entityId = input.entityId;
            } else {
                _entityId = "";
            }
            let _x: number;
            if (typeof input.x === "number") {
                _x = input.x;
            } else {
                _x = 0;
            }
            let _y: number;
            if (typeof input.y === "number") {
                _y = input.y;
            } else {
                _y = 0;
            }
            return {
                type: _type,
                entityId: _entityId,
                x: _x,
                y: _y,
            };
        },
        fromJsonString(input): WsMessageParamsCreateEntity {
            return $$WsMessageParamsCreateEntity.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = "{";
            json += '"type":"CREATE_ENTITY"';
            json += ',"entityId":';
            json += serializeString(input.entityId);
            json += ',"x":';
            json += `${input.x}`;
            json += ',"y":';
            json += `${input.y}`;
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push("type=CREATE_ENTITY");
            queryParts.push(`entityId=${input.entityId}`);
            queryParts.push(`x=${input.x}`);
            queryParts.push(`y=${input.y}`);
            return queryParts.join("&");
        },
    };

export interface WsMessageParamsUpdateEntity {
    type: "UPDATE_ENTITY";
    entityId: string;
    x: number;
    y: number;
}
const $$WsMessageParamsUpdateEntity: ArriModelValidator<WsMessageParamsUpdateEntity> =
    {
        new(): WsMessageParamsUpdateEntity {
            return {
                type: "UPDATE_ENTITY",
                entityId: "",
                x: 0,
                y: 0,
            };
        },
        validate(input): input is WsMessageParamsUpdateEntity {
            return (
                isObject(input) &&
                input.type === "UPDATE_ENTITY" &&
                typeof input.entityId === "string" &&
                typeof input.x === "number" &&
                typeof input.y === "number"
            );
        },
        fromJson(input): WsMessageParamsUpdateEntity {
            const _type = "UPDATE_ENTITY";
            let _entityId: string;
            if (typeof input.entityId === "string") {
                _entityId = input.entityId;
            } else {
                _entityId = "";
            }
            let _x: number;
            if (typeof input.x === "number") {
                _x = input.x;
            } else {
                _x = 0;
            }
            let _y: number;
            if (typeof input.y === "number") {
                _y = input.y;
            } else {
                _y = 0;
            }
            return {
                type: _type,
                entityId: _entityId,
                x: _x,
                y: _y,
            };
        },
        fromJsonString(input): WsMessageParamsUpdateEntity {
            return $$WsMessageParamsUpdateEntity.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = "{";
            json += '"type":"UPDATE_ENTITY"';
            json += ',"entityId":';
            json += serializeString(input.entityId);
            json += ',"x":';
            json += `${input.x}`;
            json += ',"y":';
            json += `${input.y}`;
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push("type=UPDATE_ENTITY");
            queryParts.push(`entityId=${input.entityId}`);
            queryParts.push(`x=${input.x}`);
            queryParts.push(`y=${input.y}`);
            return queryParts.join("&");
        },
    };

export interface WsMessageParamsDisconnect {
    type: "DISCONNECT";
    reason: string;
}
const $$WsMessageParamsDisconnect: ArriModelValidator<WsMessageParamsDisconnect> =
    {
        new(): WsMessageParamsDisconnect {
            return {
                type: "DISCONNECT",
                reason: "",
            };
        },
        validate(input): input is WsMessageParamsDisconnect {
            return (
                isObject(input) &&
                input.type === "DISCONNECT" &&
                typeof input.reason === "string"
            );
        },
        fromJson(input): WsMessageParamsDisconnect {
            const _type = "DISCONNECT";
            let _reason: string;
            if (typeof input.reason === "string") {
                _reason = input.reason;
            } else {
                _reason = "";
            }
            return {
                type: _type,
                reason: _reason,
            };
        },
        fromJsonString(input): WsMessageParamsDisconnect {
            return $$WsMessageParamsDisconnect.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = "{";
            json += '"type":"DISCONNECT"';
            json += ',"reason":';
            json += serializeString(input.reason);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push("type=DISCONNECT");
            queryParts.push(`reason=${input.reason}`);
            return queryParts.join("&");
        },
    };

export type WsMessageResponse =
    | WsMessageResponseEntityCreated
    | WsMessageResponseEntityUpdated;
export const $$WsMessageResponse: ArriModelValidator<WsMessageResponse> = {
    new(): WsMessageResponse {
        return $$WsMessageResponseEntityCreated.new();
    },
    validate(input): input is WsMessageResponse {
        if (!isObject(input)) {
            return false;
        }
        if (typeof input.type !== "string") {
            return false;
        }
        switch (input.type) {
            case "ENTITY_CREATED":
                return $$WsMessageResponseEntityCreated.validate(input);
            case "ENTITY_UPDATED":
                return $$WsMessageResponseEntityUpdated.validate(input);
            default:
                return false;
        }
    },
    fromJson(input): WsMessageResponse {
        switch (input.type) {
            case "ENTITY_CREATED":
                return $$WsMessageResponseEntityCreated.fromJson(input);
            case "ENTITY_UPDATED":
                return $$WsMessageResponseEntityUpdated.fromJson(input);
            default:
                return $$WsMessageResponseEntityCreated.new();
        }
    },
    fromJsonString(input): WsMessageResponse {
        return $$WsMessageResponse.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        switch (input.type) {
            case "ENTITY_CREATED":
                return $$WsMessageResponseEntityCreated.toJsonString(input);
            case "ENTITY_UPDATED":
                return $$WsMessageResponseEntityUpdated.toJsonString(input);
            default:
                throw new Error(`Unhandled case "${(input as any).type}"`);
        }
    },
    toUrlQueryString(input): string {
        switch (input.type) {
            case "ENTITY_CREATED":
                return $$WsMessageResponseEntityCreated.toUrlQueryString(input);
            case "ENTITY_UPDATED":
                return $$WsMessageResponseEntityUpdated.toUrlQueryString(input);
            default:
                throw new Error("Unhandled case");
        }
    },
};
export interface WsMessageResponseEntityCreated {
    type: "ENTITY_CREATED";
    entityId: string;
    x: number;
    y: number;
}
const $$WsMessageResponseEntityCreated: ArriModelValidator<WsMessageResponseEntityCreated> =
    {
        new(): WsMessageResponseEntityCreated {
            return {
                type: "ENTITY_CREATED",
                entityId: "",
                x: 0,
                y: 0,
            };
        },
        validate(input): input is WsMessageResponseEntityCreated {
            return (
                isObject(input) &&
                input.type === "ENTITY_CREATED" &&
                typeof input.entityId === "string" &&
                typeof input.x === "number" &&
                typeof input.y === "number"
            );
        },
        fromJson(input): WsMessageResponseEntityCreated {
            const _type = "ENTITY_CREATED";
            let _entityId: string;
            if (typeof input.entityId === "string") {
                _entityId = input.entityId;
            } else {
                _entityId = "";
            }
            let _x: number;
            if (typeof input.x === "number") {
                _x = input.x;
            } else {
                _x = 0;
            }
            let _y: number;
            if (typeof input.y === "number") {
                _y = input.y;
            } else {
                _y = 0;
            }
            return {
                type: _type,
                entityId: _entityId,
                x: _x,
                y: _y,
            };
        },
        fromJsonString(input): WsMessageResponseEntityCreated {
            return $$WsMessageResponseEntityCreated.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = "{";
            json += '"type":"ENTITY_CREATED"';
            json += ',"entityId":';
            json += serializeString(input.entityId);
            json += ',"x":';
            json += `${input.x}`;
            json += ',"y":';
            json += `${input.y}`;
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push("type=ENTITY_CREATED");
            queryParts.push(`entityId=${input.entityId}`);
            queryParts.push(`x=${input.x}`);
            queryParts.push(`y=${input.y}`);
            return queryParts.join("&");
        },
    };

export interface WsMessageResponseEntityUpdated {
    type: "ENTITY_UPDATED";
    entityId: string;
    x: number;
    y: number;
}
const $$WsMessageResponseEntityUpdated: ArriModelValidator<WsMessageResponseEntityUpdated> =
    {
        new(): WsMessageResponseEntityUpdated {
            return {
                type: "ENTITY_UPDATED",
                entityId: "",
                x: 0,
                y: 0,
            };
        },
        validate(input): input is WsMessageResponseEntityUpdated {
            return (
                isObject(input) &&
                input.type === "ENTITY_UPDATED" &&
                typeof input.entityId === "string" &&
                typeof input.x === "number" &&
                typeof input.y === "number"
            );
        },
        fromJson(input): WsMessageResponseEntityUpdated {
            const _type = "ENTITY_UPDATED";
            let _entityId: string;
            if (typeof input.entityId === "string") {
                _entityId = input.entityId;
            } else {
                _entityId = "";
            }
            let _x: number;
            if (typeof input.x === "number") {
                _x = input.x;
            } else {
                _x = 0;
            }
            let _y: number;
            if (typeof input.y === "number") {
                _y = input.y;
            } else {
                _y = 0;
            }
            return {
                type: _type,
                entityId: _entityId,
                x: _x,
                y: _y,
            };
        },
        fromJsonString(input): WsMessageResponseEntityUpdated {
            return $$WsMessageResponseEntityUpdated.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = "{";
            json += '"type":"ENTITY_UPDATED"';
            json += ',"entityId":';
            json += serializeString(input.entityId);
            json += ',"x":';
            json += `${input.x}`;
            json += ',"y":';
            json += `${input.y}`;
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push("type=ENTITY_UPDATED");
            queryParts.push(`entityId=${input.entityId}`);
            queryParts.push(`x=${input.x}`);
            queryParts.push(`y=${input.y}`);
            return queryParts.join("&");
        },
    };

export interface UsersWatchUserParams {
    userId: string;
}
export const $$UsersWatchUserParams: ArriModelValidator<UsersWatchUserParams> =
    {
        new(): UsersWatchUserParams {
            return {
                userId: "",
            };
        },
        validate(input): input is UsersWatchUserParams {
            return isObject(input) && typeof input.userId === "string";
        },
        fromJson(input): UsersWatchUserParams {
            let _userId: string;
            if (typeof input.userId === "string") {
                _userId = input.userId;
            } else {
                _userId = "";
            }
            return {
                userId: _userId,
            };
        },
        fromJsonString(input): UsersWatchUserParams {
            return $$UsersWatchUserParams.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = "{";
            json += '"userId":';
            json += serializeString(input.userId);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`userId=${input.userId}`);
            return queryParts.join("&");
        },
    };

export interface UsersWatchUserResponse {
    id: string;
    role: UsersWatchUserResponseRole;
    photo: UserPhoto | null;
    createdAt: Date;
    numFollowers: number;
    settings: UserSettings;
    recentNotifications: UsersWatchUserResponseRecentNotificationselement[];
    bookmarks: Record<string, UsersWatchUserResponseBookmarksvalue>;
    metadata: Record<string, any>;
    randomList: any[];
    bio?: string;
}
export const $$UsersWatchUserResponse: ArriModelValidator<UsersWatchUserResponse> =
    {
        new(): UsersWatchUserResponse {
            return {
                id: "",
                role: $$UsersWatchUserResponseRole.new(),
                photo: null,
                createdAt: new Date(),
                numFollowers: 0,
                settings: $$UserSettings.new(),
                recentNotifications: [],
                bookmarks: {},
                metadata: {},
                randomList: [],
            };
        },
        validate(input): input is UsersWatchUserResponse {
            return (
                isObject(input) &&
                typeof input.id === "string" &&
                $$UsersWatchUserResponseRole.validate(input.role) &&
                ($$UserPhoto.validate(input.photo) || input.photo === null) &&
                input.createdAt instanceof Date &&
                typeof input.numFollowers === "number" &&
                Number.isInteger(input.numFollowers) &&
                input.numFollowers >= INT32_MIN &&
                input.numFollowers <= INT32_MAX &&
                $$UserSettings.validate(input.settings) &&
                Array.isArray(input.recentNotifications) &&
                input.recentNotifications.every((_element) =>
                    $$UsersWatchUserResponseRecentNotificationselement.validate(
                        _element,
                    ),
                ) &&
                isObject(input.bookmarks) &&
                Object.values(input.bookmarks).every((_value) =>
                    $$UsersWatchUserResponseBookmarksvalue.validate(_value),
                ) &&
                isObject(input.metadata) &&
                Object.values(input.metadata).every((_value) => true) &&
                Array.isArray(input.randomList) &&
                input.randomList.every((_element) => true) &&
                (typeof input.bio === "string" ||
                    typeof input.bio === "undefined")
            );
        },
        fromJson(input): UsersWatchUserResponse {
            let _id: string;
            if (typeof input.id === "string") {
                _id = input.id;
            } else {
                _id = "";
            }
            let _role: UsersWatchUserResponseRole;
            if (typeof input.role === "string") {
                _role = $$UsersWatchUserResponseRole.fromSerialValue(
                    input.role,
                );
            } else {
                _role = $$UsersWatchUserResponseRole.new();
            }
            let _photo: UserPhoto | null;
            if (isObject(input.photo)) {
                _photo = $$UserPhoto.fromJson(input.photo);
            } else {
                _photo = null;
            }
            let _createdAt: Date;
            if (typeof input.createdAt === "string") {
                _createdAt = new Date(input.createdAt);
            } else if (input.createdAt instanceof Date) {
                _createdAt = input.createdAt;
            } else {
                _createdAt = new Date();
            }
            let _numFollowers: number;
            if (
                typeof input.numFollowers === "number" &&
                Number.isInteger(input.numFollowers) &&
                input.numFollowers >= INT32_MIN &&
                input.numFollowers <= INT32_MAX
            ) {
                _numFollowers = input.numFollowers;
            } else {
                _numFollowers = 0;
            }
            let _settings: UserSettings;
            if (isObject(input.settings)) {
                _settings = $$UserSettings.fromJson(input.settings);
            } else {
                _settings = $$UserSettings.new();
            }
            let _recentNotifications: UsersWatchUserResponseRecentNotificationselement[];
            if (Array.isArray(input.recentNotifications)) {
                _recentNotifications = [];
                for (const _recentNotificationsEl of input.recentNotifications) {
                    let _recentNotificationsElValue: UsersWatchUserResponseRecentNotificationselement;
                    if (isObject(_recentNotificationsEl)) {
                        _recentNotificationsElValue =
                            $$UsersWatchUserResponseRecentNotificationselement.fromJson(
                                _recentNotificationsEl,
                            );
                    } else {
                        _recentNotificationsElValue =
                            $$UsersWatchUserResponseRecentNotificationselement.new();
                    }
                    _recentNotifications.push(_recentNotificationsElValue);
                }
            } else {
                _recentNotifications = [];
            }
            let _bookmarks: Record<
                string,
                UsersWatchUserResponseBookmarksvalue
            >;
            if (isObject(input.bookmarks)) {
                _bookmarks = {};
                for (const [_key, _value] of Object.entries(input.bookmarks)) {
                    let _bookmarksValue: UsersWatchUserResponseBookmarksvalue;
                    if (typeof _value === "boolean") {
                        _bookmarksValue = _value;
                    } else {
                        _bookmarksValue = false;
                    }
                    _bookmarks[_key] = _bookmarksValue;
                }
            } else {
                _bookmarks = {};
            }
            let _metadata: Record<string, any>;
            if (isObject(input.metadata)) {
                _metadata = {};
                for (const [_key, _value] of Object.entries(input.metadata)) {
                    let _metadataValue: any;
                    if (typeof _value === "boolean") {
                        _metadataValue = _value;
                    } else {
                        _metadataValue = false;
                    }
                    _metadata[_key] = _metadataValue;
                }
            } else {
                _metadata = {};
            }
            let _randomList: any[];
            if (Array.isArray(input.randomList)) {
                _randomList = [];
                for (const _randomListEl of input.randomList) {
                    let _randomListElValue: any;
                    _randomListElValue = _randomListEl;
                    _randomList.push(_randomListElValue);
                }
            } else {
                _randomList = [];
            }
            let _bio: string | undefined;
            if (typeof input.bio !== "undefined") {
                if (typeof input.bio === "string") {
                    _bio = input.bio;
                } else {
                    _bio = "";
                }
            }
            return {
                id: _id,
                role: _role,
                photo: _photo,
                createdAt: _createdAt,
                numFollowers: _numFollowers,
                settings: _settings,
                recentNotifications: _recentNotifications,
                bookmarks: _bookmarks,
                metadata: _metadata,
                randomList: _randomList,
                bio: _bio,
            };
        },
        fromJsonString(input): UsersWatchUserResponse {
            return $$UsersWatchUserResponse.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = "{";
            json += '"id":';
            json += serializeString(input.id);
            json += ',"role":';
            json += `"${input.role}"`;
            json += ',"photo":';
            if (input.photo !== null) {
                json += $$UserPhoto.toJsonString(input.photo);
            } else {
                json += "null";
            }
            json += ',"createdAt":';
            json += `"${input.createdAt.toISOString()}"`;
            json += ',"numFollowers":';
            json += `${input.numFollowers}`;
            json += ',"settings":';
            json += $$UserSettings.toJsonString(input.settings);
            json += ',"recentNotifications":';
            json += "[";
            for (let i = 0; i < input.recentNotifications.length; i++) {
                if (i !== 0) json += ",";
                const _inputRecentNotificationsEl =
                    input.recentNotifications[i];
                json +=
                    $$UsersWatchUserResponseRecentNotificationselement.toJsonString(
                        _inputRecentNotificationsEl,
                    );
            }
            json += "]";
            json += ',"bookmarks":';
            json += "{";
            let _bookmarksPropertyCount = 0;
            for (const [_key, _value] of Object.entries(input.bookmarks)) {
                if (_bookmarksPropertyCount !== 0) {
                    json += ",";
                }
                json += `"${_key}":`;
                json +=
                    $$UsersWatchUserResponseBookmarksvalue.toJsonString(_value);
                _bookmarksPropertyCount++;
            }
            json += "}";

            json += ',"metadata":';
            json += "{";
            let _metadataPropertyCount = 0;
            for (const [_key, _value] of Object.entries(input.metadata)) {
                if (_metadataPropertyCount !== 0) {
                    json += ",";
                }
                json += `"${_key}":`;
                json += JSON.stringify(_value);
                _metadataPropertyCount++;
            }
            json += "}";

            json += ',"randomList":';
            json += "[";
            for (let i = 0; i < input.randomList.length; i++) {
                if (i !== 0) json += ",";
                const _inputRandomListEl = input.randomList[i];
                json += JSON.stringify(_inputRandomListEl);
            }
            json += "]";
            if (typeof input.bio !== "undefined") {
                json += `,"bio":`;
                json += serializeString(input.bio);
            }
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`role=${input.role}`);
            console.warn(
                "[WARNING] Cannot serialize nested objects to query string. Skipping property at /UsersWatchUserResponse/photo.",
            );
            queryParts.push(`createdAt=${input.createdAt.toISOString()}`);
            queryParts.push(`numFollowers=${input.numFollowers}`);
            console.warn(
                "[WARNING] Cannot serialize nested objects to query string. Skipping property at /UsersWatchUserResponse/settings.",
            );
            console.warn(
                "[WARNING] Cannot serialize arrays to query string. Skipping property at /UsersWatchUserResponse/recentNotifications.",
            );
            console.warn(
                "[WARNING] Cannot serialize nested objects to query string. Skipping property at /UsersWatchUserResponse/bookmarks.",
            );
            console.warn(
                "[WARNING] Cannot serialize nested objects to query string. Skipping property at /UsersWatchUserResponse/metadata.",
            );
            console.warn(
                "[WARNING] Cannot serialize arrays to query string. Skipping property at /UsersWatchUserResponse/randomList.",
            );
            if (typeof input.bio !== "undefined") {
                queryParts.push(`bio=${input.bio}`);
            }
            return queryParts.join("&");
        },
    };

export type UsersWatchUserResponseRole =
    (typeof $$UsersWatchUserResponseRoleValues)[number];
const $$UsersWatchUserResponseRoleValues = ["standard", "admin"] as const;
export const $$UsersWatchUserResponseRole: ArriEnumValidator<UsersWatchUserResponseRole> =
    {
        new(): UsersWatchUserResponseRole {
            return $$UsersWatchUserResponseRoleValues[0];
        },
        validate(input): input is UsersWatchUserResponseRole {
            return (
                typeof input === "string" &&
                $$UsersWatchUserResponseRoleValues.includes(input as any)
            );
        },
        values: $$UsersWatchUserResponseRoleValues,
        fromSerialValue(input): UsersWatchUserResponseRole {
            if ($$UsersWatchUserResponseRoleValues.includes(input as any)) {
                return input as UsersWatchUserResponseRole;
            }
            if (
                $$UsersWatchUserResponseRoleValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as UsersWatchUserResponseRole;
            }
            if (
                $$UsersWatchUserResponseRoleValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as UsersWatchUserResponseRole;
            }
            return "standard";
        },
    };

/**
 * A profile picture
 */
export interface UserPhoto {
    url: string;
    width: number;
    height: number;
    bytes: bigint;
    nanoseconds: bigint;
}
export const $$UserPhoto: ArriModelValidator<UserPhoto> = {
    new(): UserPhoto {
        return {
            url: "",
            width: 0,
            height: 0,
            bytes: BigInt(0),
            nanoseconds: BigInt(0),
        };
    },
    validate(input): input is UserPhoto {
        return (
            isObject(input) &&
            typeof input.url === "string" &&
            typeof input.width === "number" &&
            typeof input.height === "number" &&
            typeof input.bytes === "bigint" &&
            input.bytes >= INT64_MIN &&
            input.bytes <= INT64_MAX &&
            typeof input.nanoseconds === "bigint" &&
            input.nanoseconds >= BigInt(0) &&
            input.nanoseconds <= UINT64_MAX
        );
    },
    fromJson(input): UserPhoto {
        let _url: string;
        if (typeof input.url === "string") {
            _url = input.url;
        } else {
            _url = "";
        }
        let _width: number;
        if (typeof input.width === "number") {
            _width = input.width;
        } else {
            _width = 0;
        }
        let _height: number;
        if (typeof input.height === "number") {
            _height = input.height;
        } else {
            _height = 0;
        }
        let _bytes: bigint;
        if (typeof input.bytes === "string") {
            _bytes = BigInt(input.bytes);
        } else if (typeof input.bytes === "bigint") {
            _bytes = input.bytes;
        } else {
            _bytes = BigInt(0);
        }
        let _nanoseconds: bigint;
        if (
            typeof input.nanoseconds === "string" &&
            BigInt(input.nanoseconds) >= BigInt(0)
        ) {
            _nanoseconds = BigInt(input.nanoseconds);
        } else if (
            typeof input.nanoseconds === "bigint" &&
            input.nanoseconds >= BigInt(0)
        ) {
            _nanoseconds = input.nanoseconds;
        } else {
            _nanoseconds = BigInt(0);
        }
        return {
            url: _url,
            width: _width,
            height: _height,
            bytes: _bytes,
            nanoseconds: _nanoseconds,
        };
    },
    fromJsonString(input): UserPhoto {
        return $$UserPhoto.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"url":';
        json += serializeString(input.url);
        json += ',"width":';
        json += `${input.width}`;
        json += ',"height":';
        json += `${input.height}`;
        json += ',"bytes":';
        json += `"${input.bytes}"`;
        json += ',"nanoseconds":';
        json += `"${input.nanoseconds}"`;
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`url=${input.url}`);
        queryParts.push(`width=${input.width}`);
        queryParts.push(`height=${input.height}`);
        queryParts.push(`bytes=${input.bytes}`);
        queryParts.push(`nanoseconds=${input.nanoseconds}`);
        return queryParts.join("&");
    },
};

export interface UserSettings {
    notificationsEnabled: boolean;
    preferredTheme: UserSettingsPreferredTheme;
}
export const $$UserSettings: ArriModelValidator<UserSettings> = {
    new(): UserSettings {
        return {
            notificationsEnabled: false,
            preferredTheme: $$UserSettingsPreferredTheme.new(),
        };
    },
    validate(input): input is UserSettings {
        return (
            isObject(input) &&
            typeof input.notificationsEnabled === "boolean" &&
            $$UserSettingsPreferredTheme.validate(input.preferredTheme)
        );
    },
    fromJson(input): UserSettings {
        let _notificationsEnabled: boolean;
        if (typeof input.notificationsEnabled === "boolean") {
            _notificationsEnabled = input.notificationsEnabled;
        } else {
            _notificationsEnabled = false;
        }
        let _preferredTheme: UserSettingsPreferredTheme;
        if (typeof input.preferredTheme === "string") {
            _preferredTheme = $$UserSettingsPreferredTheme.fromSerialValue(
                input.preferredTheme,
            );
        } else {
            _preferredTheme = $$UserSettingsPreferredTheme.new();
        }
        return {
            notificationsEnabled: _notificationsEnabled,
            preferredTheme: _preferredTheme,
        };
    },
    fromJsonString(input): UserSettings {
        return $$UserSettings.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = "{";
        json += '"notificationsEnabled":';
        json += `${input.notificationsEnabled}`;
        json += ',"preferredTheme":';
        json += `"${input.preferredTheme}"`;
        json += "}";
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`notificationsEnabled=${input.notificationsEnabled}`);
        queryParts.push(`preferredTheme=${input.preferredTheme}`);
        return queryParts.join("&");
    },
};

export type UserSettingsPreferredTheme =
    (typeof $$UserSettingsPreferredThemeValues)[number];
const $$UserSettingsPreferredThemeValues = [
    "dark-mode",
    "light-mode",
    "system",
] as const;
export const $$UserSettingsPreferredTheme: ArriEnumValidator<UserSettingsPreferredTheme> =
    {
        new(): UserSettingsPreferredTheme {
            return $$UserSettingsPreferredThemeValues[0];
        },
        validate(input): input is UserSettingsPreferredTheme {
            return (
                typeof input === "string" &&
                $$UserSettingsPreferredThemeValues.includes(input as any)
            );
        },
        values: $$UserSettingsPreferredThemeValues,
        fromSerialValue(input): UserSettingsPreferredTheme {
            if ($$UserSettingsPreferredThemeValues.includes(input as any)) {
                return input as UserSettingsPreferredTheme;
            }
            if (
                $$UserSettingsPreferredThemeValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as UserSettingsPreferredTheme;
            }
            if (
                $$UserSettingsPreferredThemeValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as UserSettingsPreferredTheme;
            }
            return "dark-mode";
        },
    };

export type UsersWatchUserResponseRecentNotificationselement =
    | UsersWatchUserResponseRecentNotificationselementPostLike
    | UsersWatchUserResponseRecentNotificationselementPostComment;
export const $$UsersWatchUserResponseRecentNotificationselement: ArriModelValidator<UsersWatchUserResponseRecentNotificationselement> =
    {
        new(): UsersWatchUserResponseRecentNotificationselement {
            return $$UsersWatchUserResponseRecentNotificationselementPostLike.new();
        },
        validate(
            input,
        ): input is UsersWatchUserResponseRecentNotificationselement {
            if (!isObject(input)) {
                return false;
            }
            if (typeof input.notificationType !== "string") {
                return false;
            }
            switch (input.notificationType) {
                case "POST_LIKE":
                    return $$UsersWatchUserResponseRecentNotificationselementPostLike.validate(
                        input,
                    );
                case "POST_COMMENT":
                    return $$UsersWatchUserResponseRecentNotificationselementPostComment.validate(
                        input,
                    );
                default:
                    return false;
            }
        },
        fromJson(input): UsersWatchUserResponseRecentNotificationselement {
            switch (input.notificationType) {
                case "POST_LIKE":
                    return $$UsersWatchUserResponseRecentNotificationselementPostLike.fromJson(
                        input,
                    );
                case "POST_COMMENT":
                    return $$UsersWatchUserResponseRecentNotificationselementPostComment.fromJson(
                        input,
                    );
                default:
                    return $$UsersWatchUserResponseRecentNotificationselementPostLike.new();
            }
        },
        fromJsonString(
            input,
        ): UsersWatchUserResponseRecentNotificationselement {
            return $$UsersWatchUserResponseRecentNotificationselement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            switch (input.notificationType) {
                case "POST_LIKE":
                    return $$UsersWatchUserResponseRecentNotificationselementPostLike.toJsonString(
                        input,
                    );
                case "POST_COMMENT":
                    return $$UsersWatchUserResponseRecentNotificationselementPostComment.toJsonString(
                        input,
                    );
                default:
                    throw new Error(
                        `Unhandled case "${(input as any).notificationType}"`,
                    );
            }
        },
        toUrlQueryString(input): string {
            switch (input.notificationType) {
                case "POST_LIKE":
                    return $$UsersWatchUserResponseRecentNotificationselementPostLike.toUrlQueryString(
                        input,
                    );
                case "POST_COMMENT":
                    return $$UsersWatchUserResponseRecentNotificationselementPostComment.toUrlQueryString(
                        input,
                    );
                default:
                    throw new Error("Unhandled case");
            }
        },
    };
export interface UsersWatchUserResponseRecentNotificationselementPostLike {
    notificationType: "POST_LIKE";
    postId: string;
    userId: string;
}
const $$UsersWatchUserResponseRecentNotificationselementPostLike: ArriModelValidator<UsersWatchUserResponseRecentNotificationselementPostLike> =
    {
        new(): UsersWatchUserResponseRecentNotificationselementPostLike {
            return {
                notificationType: "POST_LIKE",
                postId: "",
                userId: "",
            };
        },
        validate(
            input,
        ): input is UsersWatchUserResponseRecentNotificationselementPostLike {
            return (
                isObject(input) &&
                input.notificationType === "POST_LIKE" &&
                typeof input.postId === "string" &&
                typeof input.userId === "string"
            );
        },
        fromJson(
            input,
        ): UsersWatchUserResponseRecentNotificationselementPostLike {
            const _notificationType = "POST_LIKE";
            let _postId: string;
            if (typeof input.postId === "string") {
                _postId = input.postId;
            } else {
                _postId = "";
            }
            let _userId: string;
            if (typeof input.userId === "string") {
                _userId = input.userId;
            } else {
                _userId = "";
            }
            return {
                notificationType: _notificationType,
                postId: _postId,
                userId: _userId,
            };
        },
        fromJsonString(
            input,
        ): UsersWatchUserResponseRecentNotificationselementPostLike {
            return $$UsersWatchUserResponseRecentNotificationselementPostLike.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"notificationType":"POST_LIKE"';
            json += ',"postId":';
            json += serializeString(input.postId);
            json += ',"userId":';
            json += serializeString(input.userId);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push("notificationType=POST_LIKE");
            queryParts.push(`postId=${input.postId}`);
            queryParts.push(`userId=${input.userId}`);
            return queryParts.join("&");
        },
    };

export interface UsersWatchUserResponseRecentNotificationselementPostComment {
    notificationType: "POST_COMMENT";
    postId: string;
    userId: string;
    commentText: string;
}
const $$UsersWatchUserResponseRecentNotificationselementPostComment: ArriModelValidator<UsersWatchUserResponseRecentNotificationselementPostComment> =
    {
        new(): UsersWatchUserResponseRecentNotificationselementPostComment {
            return {
                notificationType: "POST_COMMENT",
                postId: "",
                userId: "",
                commentText: "",
            };
        },
        validate(
            input,
        ): input is UsersWatchUserResponseRecentNotificationselementPostComment {
            return (
                isObject(input) &&
                input.notificationType === "POST_COMMENT" &&
                typeof input.postId === "string" &&
                typeof input.userId === "string" &&
                typeof input.commentText === "string"
            );
        },
        fromJson(
            input,
        ): UsersWatchUserResponseRecentNotificationselementPostComment {
            const _notificationType = "POST_COMMENT";
            let _postId: string;
            if (typeof input.postId === "string") {
                _postId = input.postId;
            } else {
                _postId = "";
            }
            let _userId: string;
            if (typeof input.userId === "string") {
                _userId = input.userId;
            } else {
                _userId = "";
            }
            let _commentText: string;
            if (typeof input.commentText === "string") {
                _commentText = input.commentText;
            } else {
                _commentText = "";
            }
            return {
                notificationType: _notificationType,
                postId: _postId,
                userId: _userId,
                commentText: _commentText,
            };
        },
        fromJsonString(
            input,
        ): UsersWatchUserResponseRecentNotificationselementPostComment {
            return $$UsersWatchUserResponseRecentNotificationselementPostComment.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"notificationType":"POST_COMMENT"';
            json += ',"postId":';
            json += serializeString(input.postId);
            json += ',"userId":';
            json += serializeString(input.userId);
            json += ',"commentText":';
            json += serializeString(input.commentText);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push("notificationType=POST_COMMENT");
            queryParts.push(`postId=${input.postId}`);
            queryParts.push(`userId=${input.userId}`);
            queryParts.push(`commentText=${input.commentText}`);
            return queryParts.join("&");
        },
    };

export interface UsersWatchUserResponseBookmarksvalue {
    postId: string;
    userId: string;
}
export const $$UsersWatchUserResponseBookmarksvalue: ArriModelValidator<UsersWatchUserResponseBookmarksvalue> =
    {
        new(): UsersWatchUserResponseBookmarksvalue {
            return {
                postId: "",
                userId: "",
            };
        },
        validate(input): input is UsersWatchUserResponseBookmarksvalue {
            return (
                isObject(input) &&
                typeof input.postId === "string" &&
                typeof input.userId === "string"
            );
        },
        fromJson(input): UsersWatchUserResponseBookmarksvalue {
            let _postId: string;
            if (typeof input.postId === "string") {
                _postId = input.postId;
            } else {
                _postId = "";
            }
            let _userId: string;
            if (typeof input.userId === "string") {
                _userId = input.userId;
            } else {
                _userId = "";
            }
            return {
                postId: _postId,
                userId: _userId,
            };
        },
        fromJsonString(input): UsersWatchUserResponseBookmarksvalue {
            return $$UsersWatchUserResponseBookmarksvalue.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = "{";
            json += '"postId":';
            json += serializeString(input.postId);
            json += ',"userId":';
            json += serializeString(input.userId);
            json += "}";
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`postId=${input.postId}`);
            queryParts.push(`userId=${input.userId}`);
            return queryParts.join("&");
        },
    };
