// this file was autogenerated by arri
import "dart:convert";
import "package:arri_client/arri_client.dart";

class TestClient {
  final String _baseUrl;
  late final Map<String, String> _headers;
  TestClient({
    String baseUrl = "",
    Map<String, String> headers = const {},
  }) : _baseUrl = baseUrl {
    _headers = {"client-version": "10", ...headers};
  }

  TestClientAdaptersService get adapters {
    return TestClientAdaptersService(
      baseUrl: _baseUrl,
      headers: _headers,
    );
  }

  TestClientMiscTestsService get miscTests {
    return TestClientMiscTestsService(
      baseUrl: _baseUrl,
      headers: _headers,
    );
  }

  TestClientPostsService get posts {
    return TestClientPostsService(
      baseUrl: _baseUrl,
      headers: _headers,
    );
  }

  TestClientVideosService get videos {
    return TestClientVideosService(
      baseUrl: _baseUrl,
      headers: _headers,
    );
  }
}

class TestClientAdaptersService {
  final String _baseUrl;
  late final Map<String, String> _headers;
  TestClientAdaptersService({
    String baseUrl = "",
    Map<String, String> headers = const {},
  }) : _baseUrl = baseUrl {
    _headers = {"client-version": "10", ...headers};
  }

  Future<AdaptersTypeboxAdapterResponse> typeboxAdapter(
      AdaptersTypeboxAdapterParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/adapters/typebox-adapter",
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => AdaptersTypeboxAdapterResponse.fromJson(
        json.decode(body),
      ),
    );
  }
}

class TestClientMiscTestsService {
  final String _baseUrl;
  late final Map<String, String> _headers;
  TestClientMiscTestsService({
    String baseUrl = "",
    Map<String, String> headers = const {},
  }) : _baseUrl = baseUrl {
    _headers = {"client-version": "10", ...headers};
  }

  Future<ObjectWithEveryType> sendObject(ObjectWithEveryType params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/misc-tests/send-object",
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => ObjectWithEveryType.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<MiscTestsSendObjectStreamResponse> sendObjectStream(
      MiscTestsSendObjectStreamParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/misc-tests/send-object-stream",
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => MiscTestsSendObjectStreamResponse.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<ObjectWithEveryNullableType> sendObjectWithNullableFields(
      ObjectWithEveryNullableType params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/misc-tests/send-object-with-nullable-fields",
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => ObjectWithEveryNullableType.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<ObjectWithEveryOptionalType> sendPartialObject(
      ObjectWithEveryOptionalType params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/misc-tests/send-partial-object",
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => ObjectWithEveryOptionalType.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<MiscTestsSendStreamWithErrorsResponse> sendStreamWithErrors() {
    return parsedArriRequest(
      "$_baseUrl/rpcs/misc-tests/send-stream-with-errors",
      method: HttpMethod.get,
      headers: _headers,
      params: null,
      parser: (body) => MiscTestsSendStreamWithErrorsResponse.fromJson(
        json.decode(body),
      ),
    );
  }
}

class TestClientPostsService {
  final String _baseUrl;
  late final Map<String, String> _headers;
  TestClientPostsService({
    String baseUrl = "",
    Map<String, String> headers = const {},
  }) : _baseUrl = baseUrl {
    _headers = {"client-version": "10", ...headers};
  }

  Future<Post> getPost(PostParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/posts/get-post",
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => Post.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<PostListResponse> getPosts(PostListParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/posts/get-posts",
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => PostListResponse.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<LogPostEventResponse> logEvent(PostEvent params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/posts/log-event",
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => LogPostEventResponse.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<Post> updatePost(UpdatePostParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/posts/update-post",
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => Post.fromJson(
        json.decode(body),
      ),
    );
  }
}

class TestClientVideosService {
  final String _baseUrl;
  late final Map<String, String> _headers;
  TestClientVideosService({
    String baseUrl = "",
    Map<String, String> headers = const {},
  }) : _baseUrl = baseUrl {
    _headers = {"client-version": "10", ...headers};
  }

  Future<Annotation> getAnnotation(AnnotationId params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/videos/get-annotation",
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => Annotation.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<Annotation> updateAnnotation(UpdateAnnotationParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/videos/update-annotation",
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => Annotation.fromJson(
        json.decode(body),
      ),
    );
  }
}

class AdaptersTypeboxAdapterParams {
  final String string;
  final bool boolean;
  final int integer;
  final double number;
  final AdaptersTypeboxAdapterParamsEnumField enumField;
  final AdaptersTypeboxAdapterParamsObject object;
  final List<bool> array;
  final String? optionalString;
  const AdaptersTypeboxAdapterParams({
    required this.string,
    required this.boolean,
    required this.integer,
    required this.number,
    required this.enumField,
    required this.object,
    required this.array,
    this.optionalString,
  });
  factory AdaptersTypeboxAdapterParams.fromJson(Map<String, dynamic> json) {
    return AdaptersTypeboxAdapterParams(
      string: typeFromDynamic<String>(json["string"], ""),
      boolean: typeFromDynamic<bool>(json["boolean"], false),
      integer: intFromDynamic(json["integer"], 0),
      number: doubleFromDynamic(json["number"], 0),
      enumField:
          AdaptersTypeboxAdapterParamsEnumField.fromJson(json["enumField"]),
      object: AdaptersTypeboxAdapterParamsObject.fromJson(json["object"]),
      array: json["array"] is List
          ?
          // ignore: unnecessary_cast
          (json["array"] as List)
              .map((item) => typeFromDynamic<bool>(item, false))
              .toList() as List<bool>
          : <bool>[],
      optionalString: nullableTypeFromDynamic<String>(json["optionalString"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "integer": integer,
      "number": number,
      "enumField": enumField.value,
      "object": object.toJson(),
      "array": array.map((item) => item).toList(),
    };
    if (optionalString != null) {
      result["optionalString"] = optionalString;
    }
    return result;
  }

  AdaptersTypeboxAdapterParams copyWith({
    String? string,
    bool? boolean,
    int? integer,
    double? number,
    AdaptersTypeboxAdapterParamsEnumField? enumField,
    AdaptersTypeboxAdapterParamsObject? object,
    List<bool>? array,
    String? optionalString,
  }) {
    return AdaptersTypeboxAdapterParams(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      integer: integer ?? this.integer,
      number: number ?? this.number,
      enumField: enumField ?? this.enumField,
      object: object ?? this.object,
      array: array ?? this.array,
      optionalString: optionalString ?? this.optionalString,
    );
  }
}

enum AdaptersTypeboxAdapterParamsEnumField
    implements Comparable<AdaptersTypeboxAdapterParamsEnumField> {
  a("A"),
  b("B"),
  c("C");

  const AdaptersTypeboxAdapterParamsEnumField(this.value);
  final String value;

  factory AdaptersTypeboxAdapterParamsEnumField.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return a;
  }

  @override
  compareTo(AdaptersTypeboxAdapterParamsEnumField other) =>
      name.compareTo(other.name);
}

class AdaptersTypeboxAdapterParamsObject {
  final String string;
  const AdaptersTypeboxAdapterParamsObject({
    required this.string,
  });
  factory AdaptersTypeboxAdapterParamsObject.fromJson(
      Map<String, dynamic> json) {
    return AdaptersTypeboxAdapterParamsObject(
      string: typeFromDynamic<String>(json["string"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "string": string,
    };

    return result;
  }

  AdaptersTypeboxAdapterParamsObject copyWith({
    String? string,
  }) {
    return AdaptersTypeboxAdapterParamsObject(
      string: string ?? this.string,
    );
  }
}

class AdaptersTypeboxAdapterResponse {
  final String message;
  const AdaptersTypeboxAdapterResponse({
    required this.message,
  });
  factory AdaptersTypeboxAdapterResponse.fromJson(Map<String, dynamic> json) {
    return AdaptersTypeboxAdapterResponse(
      message: typeFromDynamic<String>(json["message"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "message": message,
    };

    return result;
  }

  AdaptersTypeboxAdapterResponse copyWith({
    String? message,
  }) {
    return AdaptersTypeboxAdapterResponse(
      message: message ?? this.message,
    );
  }
}

class ObjectWithEveryType {
  final dynamic any;
  final bool boolean;
  final String string;
  final DateTime timestamp;
  final double float32;
  final double float64;
  final int int8;
  final int uint8;
  final int int16;
  final int uint16;
  final int int32;
  final int uint32;
  final BigInt int64;
  final BigInt uint64;
  final ObjectWithEveryTypeEnumerator enumerator;
  final List<bool> array;
  final ObjectWithEveryTypeObject object;
  final Map<String, bool> record;
  final ObjectWithEveryTypeDiscriminator discriminator;
  final ObjectWithEveryTypeNestedObject nestedObject;
  final List<List<ObjectWithEveryTypeNestedArrayItemItem>> nestedArray;
  const ObjectWithEveryType({
    required this.any,
    required this.boolean,
    required this.string,
    required this.timestamp,
    required this.float32,
    required this.float64,
    required this.int8,
    required this.uint8,
    required this.int16,
    required this.uint16,
    required this.int32,
    required this.uint32,
    required this.int64,
    required this.uint64,
    required this.enumerator,
    required this.array,
    required this.object,
    required this.record,
    required this.discriminator,
    required this.nestedObject,
    required this.nestedArray,
  });
  factory ObjectWithEveryType.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryType(
      any: json["any"],
      boolean: typeFromDynamic<bool>(json["boolean"], false),
      string: typeFromDynamic<String>(json["string"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      float32: doubleFromDynamic(json["float32"], 0),
      float64: doubleFromDynamic(json["float64"], 0),
      int8: intFromDynamic(json["int8"], 0),
      uint8: intFromDynamic(json["uint8"], 0),
      int16: intFromDynamic(json["int16"], 0),
      uint16: intFromDynamic(json["uint16"], 0),
      int32: intFromDynamic(json["int32"], 0),
      uint32: intFromDynamic(json["uint32"], 0),
      int64: bigIntFromDynamic(json["int64"], BigInt.zero),
      uint64: bigIntFromDynamic(json["uint64"], BigInt.zero),
      enumerator: ObjectWithEveryTypeEnumerator.fromJson(json["enumerator"]),
      array: json["array"] is List
          ?
          // ignore: unnecessary_cast
          (json["array"] as List)
              .map((item) => typeFromDynamic<bool>(item, false))
              .toList() as List<bool>
          : <bool>[],
      object: ObjectWithEveryTypeObject.fromJson(json["object"]),
      record: json["record"] is Map<String, dynamic>
          ? (json["record"] as Map<String, dynamic>).map((key, value) =>
              MapEntry(key, typeFromDynamic<bool>(value, false)))
          : <String, bool>{},
      discriminator:
          ObjectWithEveryTypeDiscriminator.fromJson(json["discriminator"]),
      nestedObject:
          ObjectWithEveryTypeNestedObject.fromJson(json["nestedObject"]),
      nestedArray: json["nestedArray"] is List
          ?
          // ignore: unnecessary_cast
          (json["nestedArray"] as List)
              .map((item) => item is List
                  ?
                  // ignore: unnecessary_cast
                  (item as List)
                      .map((item) =>
                          ObjectWithEveryTypeNestedArrayItemItem.fromJson(item))
                      .toList() as List<ObjectWithEveryTypeNestedArrayItemItem>
                  : <ObjectWithEveryTypeNestedArrayItemItem>[])
              .toList() as List<List<ObjectWithEveryTypeNestedArrayItemItem>>
          : <List<ObjectWithEveryTypeNestedArrayItemItem>>[],
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "any": any,
      "boolean": boolean,
      "string": string,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "float32": float32,
      "float64": float64,
      "int8": int8,
      "uint8": uint8,
      "int16": int16,
      "uint16": uint16,
      "int32": int32,
      "uint32": uint32,
      "int64": int64.toString(),
      "uint64": uint64.toString(),
      "enumerator": enumerator.value,
      "array": array.map((item) => item).toList(),
      "object": object.toJson(),
      "record": record.map((key, value) => MapEntry(key, value)),
      "discriminator": discriminator.toJson(),
      "nestedObject": nestedObject.toJson(),
      "nestedArray": nestedArray
          .map((item) => item.map((item) => item.toJson()).toList())
          .toList(),
    };

    return result;
  }

  ObjectWithEveryType copyWith({
    dynamic any,
    bool? boolean,
    String? string,
    DateTime? timestamp,
    double? float32,
    double? float64,
    int? int8,
    int? uint8,
    int? int16,
    int? uint16,
    int? int32,
    int? uint32,
    BigInt? int64,
    BigInt? uint64,
    ObjectWithEveryTypeEnumerator? enumerator,
    List<bool>? array,
    ObjectWithEveryTypeObject? object,
    Map<String, bool>? record,
    ObjectWithEveryTypeDiscriminator? discriminator,
    ObjectWithEveryTypeNestedObject? nestedObject,
    List<List<ObjectWithEveryTypeNestedArrayItemItem>>? nestedArray,
  }) {
    return ObjectWithEveryType(
      any: any ?? this.any,
      boolean: boolean ?? this.boolean,
      string: string ?? this.string,
      timestamp: timestamp ?? this.timestamp,
      float32: float32 ?? this.float32,
      float64: float64 ?? this.float64,
      int8: int8 ?? this.int8,
      uint8: uint8 ?? this.uint8,
      int16: int16 ?? this.int16,
      uint16: uint16 ?? this.uint16,
      int32: int32 ?? this.int32,
      uint32: uint32 ?? this.uint32,
      int64: int64 ?? this.int64,
      uint64: uint64 ?? this.uint64,
      enumerator: enumerator ?? this.enumerator,
      array: array ?? this.array,
      object: object ?? this.object,
      record: record ?? this.record,
      discriminator: discriminator ?? this.discriminator,
      nestedObject: nestedObject ?? this.nestedObject,
      nestedArray: nestedArray ?? this.nestedArray,
    );
  }
}

enum ObjectWithEveryTypeEnumerator
    implements Comparable<ObjectWithEveryTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryTypeEnumerator(this.value);
  final String value;

  factory ObjectWithEveryTypeEnumerator.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return a;
  }

  @override
  compareTo(ObjectWithEveryTypeEnumerator other) => name.compareTo(other.name);
}

class ObjectWithEveryTypeObject {
  final String string;
  final bool boolean;
  final DateTime timestamp;
  const ObjectWithEveryTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });
  factory ObjectWithEveryTypeObject.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryTypeObject(
      string: typeFromDynamic<String>(json["string"], ""),
      boolean: typeFromDynamic<bool>(json["boolean"], false),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return result;
  }

  ObjectWithEveryTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

sealed class ObjectWithEveryTypeDiscriminator {
  final String type;
  const ObjectWithEveryTypeDiscriminator({
    required this.type,
  });
  factory ObjectWithEveryTypeDiscriminator.fromJson(Map<String, dynamic> json) {
    if (json["type"] is! String) {
      throw Exception(
        "Unable to decode ObjectWithEveryTypeDiscriminator. Expected String from \"type\". Received ${json["type"]}}",
      );
    }
    switch (json["type"]) {
      case "A":
        return ObjectWithEveryTypeDiscriminatorA.fromJson(json);
      case "B":
        return ObjectWithEveryTypeDiscriminatorB.fromJson(json);
    }
    throw Exception(
      "Unable to decode ObjectWithEveryTypeDiscriminator. \"${json["type"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class ObjectWithEveryTypeDiscriminatorA
    implements ObjectWithEveryTypeDiscriminator {
  @override
  final String type = "A";
  final String title;
  const ObjectWithEveryTypeDiscriminatorA({
    required this.title,
  });
  factory ObjectWithEveryTypeDiscriminatorA.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeDiscriminatorA(
      title: typeFromDynamic<String>(json["title"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return result;
  }

  ObjectWithEveryTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return ObjectWithEveryTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }
}

class ObjectWithEveryTypeDiscriminatorB
    implements ObjectWithEveryTypeDiscriminator {
  @override
  final String type = "B";
  final String title;
  final String description;
  const ObjectWithEveryTypeDiscriminatorB({
    required this.title,
    required this.description,
  });
  factory ObjectWithEveryTypeDiscriminatorB.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeDiscriminatorB(
      title: typeFromDynamic<String>(json["title"], ""),
      description: typeFromDynamic<String>(json["description"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return result;
  }

  ObjectWithEveryTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return ObjectWithEveryTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }
}

class ObjectWithEveryTypeNestedObject {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryTypeNestedObjectData data;
  const ObjectWithEveryTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryTypeNestedObject.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryTypeNestedObject(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      data: ObjectWithEveryTypeNestedObjectData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return result;
  }

  ObjectWithEveryTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryTypeNestedObjectData? data,
  }) {
    return ObjectWithEveryTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryTypeNestedObjectData {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryTypeNestedObjectDataData data;
  const ObjectWithEveryTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryTypeNestedObjectData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeNestedObjectData(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      data: ObjectWithEveryTypeNestedObjectDataData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return result;
  }

  ObjectWithEveryTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryTypeNestedObjectDataData? data,
  }) {
    return ObjectWithEveryTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryTypeNestedObjectDataData {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeNestedObjectDataData(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return result;
  }

  ObjectWithEveryTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class ObjectWithEveryTypeNestedArrayItemItem {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryTypeNestedArrayItemItem({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryTypeNestedArrayItemItem.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeNestedArrayItemItem(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return result;
  }

  ObjectWithEveryTypeNestedArrayItemItem copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeNestedArrayItemItem(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class MiscTestsSendObjectStreamParams {
  final String channelId;
  const MiscTestsSendObjectStreamParams({
    required this.channelId,
  });
  factory MiscTestsSendObjectStreamParams.fromJson(Map<String, dynamic> json) {
    return MiscTestsSendObjectStreamParams(
      channelId: typeFromDynamic<String>(json["channelId"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "channelId": channelId,
    };

    return result;
  }

  MiscTestsSendObjectStreamParams copyWith({
    String? channelId,
  }) {
    return MiscTestsSendObjectStreamParams(
      channelId: channelId ?? this.channelId,
    );
  }
}

sealed class MiscTestsSendObjectStreamResponse {
  final String messageType;
  const MiscTestsSendObjectStreamResponse({
    required this.messageType,
  });
  factory MiscTestsSendObjectStreamResponse.fromJson(
      Map<String, dynamic> json) {
    if (json["messageType"] is! String) {
      throw Exception(
        "Unable to decode MiscTestsSendObjectStreamResponse. Expected String from \"messageType\". Received ${json["messageType"]}}",
      );
    }
    switch (json["messageType"]) {
      case "TEXT":
        return MiscTestsSendObjectStreamResponseText.fromJson(json);
      case "IMAGE":
        return MiscTestsSendObjectStreamResponseImage.fromJson(json);
      case "URL":
        return MiscTestsSendObjectStreamResponseUrl.fromJson(json);
    }
    throw Exception(
      "Unable to decode MiscTestsSendObjectStreamResponse. \"${json["messageType"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class MiscTestsSendObjectStreamResponseText
    implements MiscTestsSendObjectStreamResponse {
  @override
  final String messageType = "TEXT";
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String text;
  const MiscTestsSendObjectStreamResponseText({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.text,
  });
  factory MiscTestsSendObjectStreamResponseText.fromJson(
      Map<String, dynamic> json) {
    return MiscTestsSendObjectStreamResponseText(
      id: typeFromDynamic<String>(json["id"], ""),
      channelId: typeFromDynamic<String>(json["channelId"], ""),
      userId: typeFromDynamic<String>(json["userId"], ""),
      date: dateTimeFromDynamic(
        json["date"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      text: typeFromDynamic<String>(json["text"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "text": text,
    };

    return result;
  }

  MiscTestsSendObjectStreamResponseText copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? text,
  }) {
    return MiscTestsSendObjectStreamResponseText(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      text: text ?? this.text,
    );
  }
}

class MiscTestsSendObjectStreamResponseImage
    implements MiscTestsSendObjectStreamResponse {
  @override
  final String messageType = "IMAGE";
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String image;
  const MiscTestsSendObjectStreamResponseImage({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.image,
  });
  factory MiscTestsSendObjectStreamResponseImage.fromJson(
      Map<String, dynamic> json) {
    return MiscTestsSendObjectStreamResponseImage(
      id: typeFromDynamic<String>(json["id"], ""),
      channelId: typeFromDynamic<String>(json["channelId"], ""),
      userId: typeFromDynamic<String>(json["userId"], ""),
      date: dateTimeFromDynamic(
        json["date"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      image: typeFromDynamic<String>(json["image"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "image": image,
    };

    return result;
  }

  MiscTestsSendObjectStreamResponseImage copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? image,
  }) {
    return MiscTestsSendObjectStreamResponseImage(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      image: image ?? this.image,
    );
  }
}

class MiscTestsSendObjectStreamResponseUrl
    implements MiscTestsSendObjectStreamResponse {
  @override
  final String messageType = "URL";
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String url;
  const MiscTestsSendObjectStreamResponseUrl({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.url,
  });
  factory MiscTestsSendObjectStreamResponseUrl.fromJson(
      Map<String, dynamic> json) {
    return MiscTestsSendObjectStreamResponseUrl(
      id: typeFromDynamic<String>(json["id"], ""),
      channelId: typeFromDynamic<String>(json["channelId"], ""),
      userId: typeFromDynamic<String>(json["userId"], ""),
      date: dateTimeFromDynamic(
        json["date"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      url: typeFromDynamic<String>(json["url"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "url": url,
    };

    return result;
  }

  MiscTestsSendObjectStreamResponseUrl copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? url,
  }) {
    return MiscTestsSendObjectStreamResponseUrl(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      url: url ?? this.url,
    );
  }
}

class ObjectWithEveryNullableType {
  final dynamic any;
  final bool? boolean;
  final String? string;
  final DateTime? timestamp;
  final double? float32;
  final double? float64;
  final int? int8;
  final int? uint8;
  final int? int16;
  final int? uint16;
  final int? int32;
  final int? uint32;
  final BigInt? int64;
  final BigInt? uint64;
  final ObjectWithEveryNullableTypeEnumerator? enumerator;
  final List<bool?>? array;
  final ObjectWithEveryNullableTypeObject? object;
  final Map<String, bool?>? record;
  final ObjectWithEveryNullableTypeDiscriminator? discriminator;
  final ObjectWithEveryNullableTypeNestedObject? nestedObject;
  final List<List<ObjectWithEveryNullableTypeNestedArrayItemItem?>?>?
      nestedArray;
  const ObjectWithEveryNullableType({
    required this.any,
    required this.boolean,
    required this.string,
    required this.timestamp,
    required this.float32,
    required this.float64,
    required this.int8,
    required this.uint8,
    required this.int16,
    required this.uint16,
    required this.int32,
    required this.uint32,
    required this.int64,
    required this.uint64,
    required this.enumerator,
    required this.array,
    required this.object,
    required this.record,
    required this.discriminator,
    required this.nestedObject,
    required this.nestedArray,
  });
  factory ObjectWithEveryNullableType.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryNullableType(
      any: json["any"],
      boolean: nullableTypeFromDynamic<bool>(json["boolean"]),
      string: nullableTypeFromDynamic<String>(json["string"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
      float32: nullableDoubleFromDynamic(json["float32"]),
      float64: nullableDoubleFromDynamic(json["float64"]),
      int8: nullableIntFromDynamic(json["int8"]),
      uint8: nullableIntFromDynamic(json["uint8"]),
      int16: nullableIntFromDynamic(json["int16"]),
      uint16: nullableIntFromDynamic(json["uint16"]),
      int32: nullableIntFromDynamic(json["int32"]),
      uint32: nullableIntFromDynamic(json["uint32"]),
      int64: nullableBigIntFromDynamic(json["int64"]),
      uint64: nullableBigIntFromDynamic(json["uint64"]),
      enumerator: json["enumerator"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeEnumerator.fromJson(json["enumerator"])
          : null,
      array: json["array"] is List
          ?
          // ignore: unnecessary_cast
          (json["array"] as List)
              .map((item) => nullableTypeFromDynamic<bool>(item))
              .toList() as List<bool?>?
          : null,
      object: json["object"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeObject.fromJson(json["object"])
          : null,
      record: json["record"] is Map<String, dynamic>
          ? (json["record"] as Map<String, dynamic>).map((key, value) =>
              MapEntry(key, nullableTypeFromDynamic<bool>(value)))
          : <String, bool?>{},
      discriminator: json["discriminator"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeDiscriminator.fromJson(
              json["discriminator"])
          : null,
      nestedObject: json["nestedObject"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeNestedObject.fromJson(
              json["nestedObject"])
          : null,
      nestedArray: json["nestedArray"] is List
          ?
          // ignore: unnecessary_cast
          (json["nestedArray"] as List)
                  .map((item) => item is List
                      ?
                      // ignore: unnecessary_cast
                      (item as List)
                              .map((item) => item is Map<String, dynamic>
                                  ? ObjectWithEveryNullableTypeNestedArrayItemItem
                                      .fromJson(item)
                                  : null)
                              .toList()
                          as List<ObjectWithEveryNullableTypeNestedArrayItemItem?>?
                      : null)
                  .toList()
              as List<List<ObjectWithEveryNullableTypeNestedArrayItemItem?>?>?
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "any": any,
      "boolean": boolean,
      "string": string,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "float32": float32,
      "float64": float64,
      "int8": int8,
      "uint8": uint8,
      "int16": int16,
      "uint16": uint16,
      "int32": int32,
      "uint32": uint32,
      "int64": int64?.toString(),
      "uint64": uint64?.toString(),
      "enumerator": enumerator?.value,
      "array": array?.map((item) => item).toList(),
      "object": object?.toJson(),
      "record": record?.map((key, value) => MapEntry(key, value)),
      "discriminator": discriminator?.toJson(),
      "nestedObject": nestedObject?.toJson(),
      "nestedArray": nestedArray
          ?.map((item) => item?.map((item) => item?.toJson()).toList())
          .toList(),
    };

    return result;
  }

  ObjectWithEveryNullableType copyWith({
    dynamic any,
    bool? boolean,
    String? string,
    DateTime? timestamp,
    double? float32,
    double? float64,
    int? int8,
    int? uint8,
    int? int16,
    int? uint16,
    int? int32,
    int? uint32,
    BigInt? int64,
    BigInt? uint64,
    ObjectWithEveryNullableTypeEnumerator? enumerator,
    List<bool?>? array,
    ObjectWithEveryNullableTypeObject? object,
    Map<String, bool?>? record,
    ObjectWithEveryNullableTypeDiscriminator? discriminator,
    ObjectWithEveryNullableTypeNestedObject? nestedObject,
    List<List<ObjectWithEveryNullableTypeNestedArrayItemItem?>?>? nestedArray,
  }) {
    return ObjectWithEveryNullableType(
      any: any ?? this.any,
      boolean: boolean ?? this.boolean,
      string: string ?? this.string,
      timestamp: timestamp ?? this.timestamp,
      float32: float32 ?? this.float32,
      float64: float64 ?? this.float64,
      int8: int8 ?? this.int8,
      uint8: uint8 ?? this.uint8,
      int16: int16 ?? this.int16,
      uint16: uint16 ?? this.uint16,
      int32: int32 ?? this.int32,
      uint32: uint32 ?? this.uint32,
      int64: int64 ?? this.int64,
      uint64: uint64 ?? this.uint64,
      enumerator: enumerator ?? this.enumerator,
      array: array ?? this.array,
      object: object ?? this.object,
      record: record ?? this.record,
      discriminator: discriminator ?? this.discriminator,
      nestedObject: nestedObject ?? this.nestedObject,
      nestedArray: nestedArray ?? this.nestedArray,
    );
  }
}

enum ObjectWithEveryNullableTypeEnumerator
    implements Comparable<ObjectWithEveryNullableTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryNullableTypeEnumerator(this.value);
  final String value;

  factory ObjectWithEveryNullableTypeEnumerator.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return a;
  }

  @override
  compareTo(ObjectWithEveryNullableTypeEnumerator other) =>
      name.compareTo(other.name);
}

class ObjectWithEveryNullableTypeObject {
  final String? string;
  final bool? boolean;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });
  factory ObjectWithEveryNullableTypeObject.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeObject(
      string: nullableTypeFromDynamic<String>(json["string"]),
      boolean: nullableTypeFromDynamic<bool>(json["boolean"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return result;
  }

  ObjectWithEveryNullableTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryNullableTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

sealed class ObjectWithEveryNullableTypeDiscriminator {
  final String type;
  const ObjectWithEveryNullableTypeDiscriminator({
    required this.type,
  });
  factory ObjectWithEveryNullableTypeDiscriminator.fromJson(
      Map<String, dynamic> json) {
    if (json["type"] is! String) {
      throw Exception(
        "Unable to decode ObjectWithEveryNullableTypeDiscriminator. Expected String from \"type\". Received ${json["type"]}}",
      );
    }
    switch (json["type"]) {
      case "A":
        return ObjectWithEveryNullableTypeDiscriminatorA.fromJson(json);
      case "B":
        return ObjectWithEveryNullableTypeDiscriminatorB.fromJson(json);
    }
    throw Exception(
      "Unable to decode ObjectWithEveryNullableTypeDiscriminator. \"${json["type"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class ObjectWithEveryNullableTypeDiscriminatorA
    implements ObjectWithEveryNullableTypeDiscriminator {
  @override
  final String type = "A";
  final String? title;
  const ObjectWithEveryNullableTypeDiscriminatorA({
    required this.title,
  });
  factory ObjectWithEveryNullableTypeDiscriminatorA.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeDiscriminatorA(
      title: nullableTypeFromDynamic<String>(json["title"]),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return result;
  }

  ObjectWithEveryNullableTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return ObjectWithEveryNullableTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }
}

class ObjectWithEveryNullableTypeDiscriminatorB
    implements ObjectWithEveryNullableTypeDiscriminator {
  @override
  final String type = "B";
  final String? title;
  final String? description;
  const ObjectWithEveryNullableTypeDiscriminatorB({
    required this.title,
    required this.description,
  });
  factory ObjectWithEveryNullableTypeDiscriminatorB.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeDiscriminatorB(
      title: nullableTypeFromDynamic<String>(json["title"]),
      description: nullableTypeFromDynamic<String>(json["description"]),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return result;
  }

  ObjectWithEveryNullableTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return ObjectWithEveryNullableTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }
}

class ObjectWithEveryNullableTypeNestedObject {
  final String? id;
  final DateTime? timestamp;
  final ObjectWithEveryNullableTypeNestedObjectData? data;
  const ObjectWithEveryNullableTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryNullableTypeNestedObject.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeNestedObject(
      id: nullableTypeFromDynamic<String>(json["id"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
      data: json["data"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeNestedObjectData.fromJson(json["data"])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "data": data?.toJson(),
    };

    return result;
  }

  ObjectWithEveryNullableTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryNullableTypeNestedObjectData? data,
  }) {
    return ObjectWithEveryNullableTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryNullableTypeNestedObjectData {
  final String? id;
  final DateTime? timestamp;
  final ObjectWithEveryNullableTypeNestedObjectDataData? data;
  const ObjectWithEveryNullableTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryNullableTypeNestedObjectData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeNestedObjectData(
      id: nullableTypeFromDynamic<String>(json["id"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
      data: json["data"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
              json["data"])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "data": data?.toJson(),
    };

    return result;
  }

  ObjectWithEveryNullableTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryNullableTypeNestedObjectDataData? data,
  }) {
    return ObjectWithEveryNullableTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryNullableTypeNestedObjectDataData {
  final String? id;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeNestedObjectDataData(
      id: nullableTypeFromDynamic<String>(json["id"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return result;
  }

  ObjectWithEveryNullableTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryNullableTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class ObjectWithEveryNullableTypeNestedArrayItemItem {
  final String? id;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeNestedArrayItemItem({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryNullableTypeNestedArrayItemItem.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeNestedArrayItemItem(
      id: nullableTypeFromDynamic<String>(json["id"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return result;
  }

  ObjectWithEveryNullableTypeNestedArrayItemItem copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryNullableTypeNestedArrayItemItem(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class ObjectWithEveryOptionalType {
  final dynamic any;
  final bool? boolean;
  final String? string;
  final DateTime? timestamp;
  final double? float32;
  final double? float64;
  final int? int8;
  final int? uint8;
  final int? int16;
  final int? uint16;
  final int? int32;
  final int? uint32;
  final BigInt? int64;
  final BigInt? uint64;
  final ObjectWithEveryOptionalTypeEnumerator? enumerator;
  final List<bool>? array;
  final ObjectWithEveryOptionalTypeObject? object;
  final Map<String, bool>? record;
  final ObjectWithEveryOptionalTypeDiscriminator? discriminator;
  final ObjectWithEveryOptionalTypeNestedObject? nestedObject;
  final List<List<ObjectWithEveryOptionalTypeNestedArrayItemItem>>? nestedArray;
  const ObjectWithEveryOptionalType({
    this.any,
    this.boolean,
    this.string,
    this.timestamp,
    this.float32,
    this.float64,
    this.int8,
    this.uint8,
    this.int16,
    this.uint16,
    this.int32,
    this.uint32,
    this.int64,
    this.uint64,
    this.enumerator,
    this.array,
    this.object,
    this.record,
    this.discriminator,
    this.nestedObject,
    this.nestedArray,
  });
  factory ObjectWithEveryOptionalType.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryOptionalType(
      any: json["any"],
      boolean: nullableTypeFromDynamic<bool>(json["boolean"]),
      string: nullableTypeFromDynamic<String>(json["string"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
      float32: nullableDoubleFromDynamic(json["float32"]),
      float64: nullableDoubleFromDynamic(json["float64"]),
      int8: nullableIntFromDynamic(json["int8"]),
      uint8: nullableIntFromDynamic(json["uint8"]),
      int16: nullableIntFromDynamic(json["int16"]),
      uint16: nullableIntFromDynamic(json["uint16"]),
      int32: nullableIntFromDynamic(json["int32"]),
      uint32: nullableIntFromDynamic(json["uint32"]),
      int64: nullableBigIntFromDynamic(json["int64"]),
      uint64: nullableBigIntFromDynamic(json["uint64"]),
      enumerator: json["enumerator"] is Map<String, dynamic>
          ? ObjectWithEveryOptionalTypeEnumerator.fromJson(json["enumerator"])
          : null,
      array: json["array"] is List
          ?
          // ignore: unnecessary_cast
          (json["array"] as List)
              .map((item) => typeFromDynamic<bool>(item, false))
              .toList() as List<bool>?
          : null,
      object: json["object"] is Map<String, dynamic>
          ? ObjectWithEveryOptionalTypeObject.fromJson(json["object"])
          : null,
      record: json["record"] is Map<String, dynamic>
          ? (json["record"] as Map<String, dynamic>).map((key, value) =>
              MapEntry(key, typeFromDynamic<bool>(value, false)))
          : <String, bool>{},
      discriminator: json["discriminator"] is Map<String, dynamic>
          ? ObjectWithEveryOptionalTypeDiscriminator.fromJson(
              json["discriminator"])
          : null,
      nestedObject: json["nestedObject"] is Map<String, dynamic>
          ? ObjectWithEveryOptionalTypeNestedObject.fromJson(
              json["nestedObject"])
          : null,
      nestedArray: json["nestedArray"] is List
          ?
          // ignore: unnecessary_cast
          (json["nestedArray"] as List)
                  .map((item) => item is List
                      ?
                      // ignore: unnecessary_cast
                      (item as List)
                              .map((item) =>
                                  ObjectWithEveryOptionalTypeNestedArrayItemItem
                                      .fromJson(item))
                              .toList()
                          as List<ObjectWithEveryOptionalTypeNestedArrayItemItem>
                      : <ObjectWithEveryOptionalTypeNestedArrayItemItem>[])
                  .toList()
              as List<List<ObjectWithEveryOptionalTypeNestedArrayItemItem>>?
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{};
    if (any != null) {
      result["any"] = any;
    }
    if (boolean != null) {
      result["boolean"] = boolean;
    }
    if (string != null) {
      result["string"] = string;
    }
    if (timestamp != null) {
      result["timestamp"] = timestamp?.toUtc().toIso8601String();
    }
    if (float32 != null) {
      result["float32"] = float32;
    }
    if (float64 != null) {
      result["float64"] = float64;
    }
    if (int8 != null) {
      result["int8"] = int8;
    }
    if (uint8 != null) {
      result["uint8"] = uint8;
    }
    if (int16 != null) {
      result["int16"] = int16;
    }
    if (uint16 != null) {
      result["uint16"] = uint16;
    }
    if (int32 != null) {
      result["int32"] = int32;
    }
    if (uint32 != null) {
      result["uint32"] = uint32;
    }
    if (int64 != null) {
      result["int64"] = int64?.toString();
    }
    if (uint64 != null) {
      result["uint64"] = uint64?.toString();
    }
    if (enumerator != null) {
      result["enumerator"] = enumerator?.value;
    }
    if (array != null) {
      result["array"] = array?.map((item) => item).toList();
    }
    if (object != null) {
      result["object"] = object?.toJson();
    }
    if (record != null) {
      result["record"] = record?.map((key, value) => MapEntry(key, value));
    }
    if (discriminator != null) {
      result["discriminator"] = discriminator?.toJson();
    }
    if (nestedObject != null) {
      result["nestedObject"] = nestedObject?.toJson();
    }
    if (nestedArray != null) {
      result["nestedArray"] = nestedArray
          ?.map((item) => item.map((item) => item.toJson()).toList())
          .toList();
    }
    return result;
  }

  ObjectWithEveryOptionalType copyWith({
    dynamic any,
    bool? boolean,
    String? string,
    DateTime? timestamp,
    double? float32,
    double? float64,
    int? int8,
    int? uint8,
    int? int16,
    int? uint16,
    int? int32,
    int? uint32,
    BigInt? int64,
    BigInt? uint64,
    ObjectWithEveryOptionalTypeEnumerator? enumerator,
    List<bool>? array,
    ObjectWithEveryOptionalTypeObject? object,
    Map<String, bool>? record,
    ObjectWithEveryOptionalTypeDiscriminator? discriminator,
    ObjectWithEveryOptionalTypeNestedObject? nestedObject,
    List<List<ObjectWithEveryOptionalTypeNestedArrayItemItem>>? nestedArray,
  }) {
    return ObjectWithEveryOptionalType(
      any: any ?? this.any,
      boolean: boolean ?? this.boolean,
      string: string ?? this.string,
      timestamp: timestamp ?? this.timestamp,
      float32: float32 ?? this.float32,
      float64: float64 ?? this.float64,
      int8: int8 ?? this.int8,
      uint8: uint8 ?? this.uint8,
      int16: int16 ?? this.int16,
      uint16: uint16 ?? this.uint16,
      int32: int32 ?? this.int32,
      uint32: uint32 ?? this.uint32,
      int64: int64 ?? this.int64,
      uint64: uint64 ?? this.uint64,
      enumerator: enumerator ?? this.enumerator,
      array: array ?? this.array,
      object: object ?? this.object,
      record: record ?? this.record,
      discriminator: discriminator ?? this.discriminator,
      nestedObject: nestedObject ?? this.nestedObject,
      nestedArray: nestedArray ?? this.nestedArray,
    );
  }
}

enum ObjectWithEveryOptionalTypeEnumerator
    implements Comparable<ObjectWithEveryOptionalTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryOptionalTypeEnumerator(this.value);
  final String value;

  factory ObjectWithEveryOptionalTypeEnumerator.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return a;
  }

  @override
  compareTo(ObjectWithEveryOptionalTypeEnumerator other) =>
      name.compareTo(other.name);
}

class ObjectWithEveryOptionalTypeObject {
  final String string;
  final bool boolean;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });
  factory ObjectWithEveryOptionalTypeObject.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeObject(
      string: typeFromDynamic<String>(json["string"], ""),
      boolean: typeFromDynamic<bool>(json["boolean"], false),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return result;
  }

  ObjectWithEveryOptionalTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

sealed class ObjectWithEveryOptionalTypeDiscriminator {
  final String type;
  const ObjectWithEveryOptionalTypeDiscriminator({
    required this.type,
  });
  factory ObjectWithEveryOptionalTypeDiscriminator.fromJson(
      Map<String, dynamic> json) {
    if (json["type"] is! String) {
      throw Exception(
        "Unable to decode ObjectWithEveryOptionalTypeDiscriminator. Expected String from \"type\". Received ${json["type"]}}",
      );
    }
    switch (json["type"]) {
      case "A":
        return ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(json);
      case "B":
        return ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(json);
    }
    throw Exception(
      "Unable to decode ObjectWithEveryOptionalTypeDiscriminator. \"${json["type"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class ObjectWithEveryOptionalTypeDiscriminatorA
    implements ObjectWithEveryOptionalTypeDiscriminator {
  @override
  final String type = "A";
  final String title;
  const ObjectWithEveryOptionalTypeDiscriminatorA({
    required this.title,
  });
  factory ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeDiscriminatorA(
      title: typeFromDynamic<String>(json["title"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return result;
  }

  ObjectWithEveryOptionalTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return ObjectWithEveryOptionalTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }
}

class ObjectWithEveryOptionalTypeDiscriminatorB
    implements ObjectWithEveryOptionalTypeDiscriminator {
  @override
  final String type = "B";
  final String title;
  final String description;
  const ObjectWithEveryOptionalTypeDiscriminatorB({
    required this.title,
    required this.description,
  });
  factory ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeDiscriminatorB(
      title: typeFromDynamic<String>(json["title"], ""),
      description: typeFromDynamic<String>(json["description"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return result;
  }

  ObjectWithEveryOptionalTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return ObjectWithEveryOptionalTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }
}

class ObjectWithEveryOptionalTypeNestedObject {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryOptionalTypeNestedObjectData data;
  const ObjectWithEveryOptionalTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryOptionalTypeNestedObject.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeNestedObject(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      data: ObjectWithEveryOptionalTypeNestedObjectData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return result;
  }

  ObjectWithEveryOptionalTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryOptionalTypeNestedObjectData? data,
  }) {
    return ObjectWithEveryOptionalTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryOptionalTypeNestedObjectData {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryOptionalTypeNestedObjectDataData data;
  const ObjectWithEveryOptionalTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryOptionalTypeNestedObjectData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeNestedObjectData(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      data: ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
          json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return result;
  }

  ObjectWithEveryOptionalTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryOptionalTypeNestedObjectDataData? data,
  }) {
    return ObjectWithEveryOptionalTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryOptionalTypeNestedObjectDataData {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeNestedObjectDataData(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return result;
  }

  ObjectWithEveryOptionalTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class ObjectWithEveryOptionalTypeNestedArrayItemItem {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeNestedArrayItemItem({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryOptionalTypeNestedArrayItemItem.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeNestedArrayItemItem(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return result;
  }

  ObjectWithEveryOptionalTypeNestedArrayItemItem copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeNestedArrayItemItem(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class MiscTestsSendStreamWithErrorsResponse {
  final String message;
  const MiscTestsSendStreamWithErrorsResponse({
    required this.message,
  });
  factory MiscTestsSendStreamWithErrorsResponse.fromJson(
      Map<String, dynamic> json) {
    return MiscTestsSendStreamWithErrorsResponse(
      message: typeFromDynamic<String>(json["message"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "message": message,
    };

    return result;
  }

  MiscTestsSendStreamWithErrorsResponse copyWith({
    String? message,
  }) {
    return MiscTestsSendStreamWithErrorsResponse(
      message: message ?? this.message,
    );
  }
}

class PostParams {
  final String postId;
  const PostParams({
    required this.postId,
  });
  factory PostParams.fromJson(Map<String, dynamic> json) {
    return PostParams(
      postId: typeFromDynamic<String>(json["postId"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "postId": postId,
    };

    return result;
  }

  PostParams copyWith({
    String? postId,
  }) {
    return PostParams(
      postId: postId ?? this.postId,
    );
  }
}

class Post {
  final String id;
  final String title;
  final PostType type;
  final String? description;
  final String content;
  final List<String> tags;
  final String authorId;
  final Author author;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Post({
    required this.id,
    required this.title,
    required this.type,
    required this.description,
    required this.content,
    required this.tags,
    required this.authorId,
    required this.author,
    required this.createdAt,
    required this.updatedAt,
  });
  factory Post.fromJson(Map<String, dynamic> json) {
    return Post(
      id: typeFromDynamic<String>(json["id"], ""),
      title: typeFromDynamic<String>(json["title"], ""),
      type: PostType.fromJson(json["type"]),
      description: nullableTypeFromDynamic<String>(json["description"]),
      content: typeFromDynamic<String>(json["content"], ""),
      tags: json["tags"] is List
          ?
          // ignore: unnecessary_cast
          (json["tags"] as List)
              .map((item) => typeFromDynamic<String>(item, ""))
              .toList() as List<String>
          : <String>[],
      authorId: typeFromDynamic<String>(json["authorId"], ""),
      author: Author.fromJson(json["author"]),
      createdAt: dateTimeFromDynamic(
        json["createdAt"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      updatedAt: dateTimeFromDynamic(
        json["updatedAt"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "title": title,
      "type": type.value,
      "description": description,
      "content": content,
      "tags": tags.map((item) => item).toList(),
      "authorId": authorId,
      "author": author.toJson(),
      "createdAt": createdAt.toUtc().toIso8601String(),
      "updatedAt": updatedAt.toUtc().toIso8601String(),
    };

    return result;
  }

  Post copyWith({
    String? id,
    String? title,
    PostType? type,
    String? description,
    String? content,
    List<String>? tags,
    String? authorId,
    Author? author,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      type: type ?? this.type,
      description: description ?? this.description,
      content: content ?? this.content,
      tags: tags ?? this.tags,
      authorId: authorId ?? this.authorId,
      author: author ?? this.author,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

enum PostType implements Comparable<PostType> {
  text("text"),
  image("image"),
  video("video");

  const PostType(this.value);
  final String value;

  factory PostType.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return text;
  }

  @override
  compareTo(PostType other) => name.compareTo(other.name);
}

class Author {
  final String id;
  final String name;
  final String? bio;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Author({
    required this.id,
    required this.name,
    required this.bio,
    required this.createdAt,
    required this.updatedAt,
  });
  factory Author.fromJson(Map<String, dynamic> json) {
    return Author(
      id: typeFromDynamic<String>(json["id"], ""),
      name: typeFromDynamic<String>(json["name"], ""),
      bio: nullableTypeFromDynamic<String>(json["bio"]),
      createdAt: dateTimeFromDynamic(
        json["createdAt"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      updatedAt: dateTimeFromDynamic(
        json["updatedAt"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "name": name,
      "bio": bio,
      "createdAt": createdAt.toUtc().toIso8601String(),
      "updatedAt": updatedAt.toUtc().toIso8601String(),
    };

    return result;
  }

  Author copyWith({
    String? id,
    String? name,
    String? bio,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return Author(
      id: id ?? this.id,
      name: name ?? this.name,
      bio: bio ?? this.bio,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

class PostListParams {
  final int limit;
  final PostType? type;
  const PostListParams({
    required this.limit,
    this.type,
  });
  factory PostListParams.fromJson(Map<String, dynamic> json) {
    return PostListParams(
      limit: intFromDynamic(json["limit"], 0),
      type: json["type"] is Map<String, dynamic>
          ? PostType.fromJson(json["type"])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "limit": limit,
    };
    if (type != null) {
      result["type"] = type?.value;
    }
    return result;
  }

  PostListParams copyWith({
    int? limit,
    PostType? type,
  }) {
    return PostListParams(
      limit: limit ?? this.limit,
      type: type ?? this.type,
    );
  }
}

class PostListResponse {
  final int total;
  final List<Post> items;
  const PostListResponse({
    required this.total,
    required this.items,
  });
  factory PostListResponse.fromJson(Map<String, dynamic> json) {
    return PostListResponse(
      total: intFromDynamic(json["total"], 0),
      items: json["items"] is List
          ?
          // ignore: unnecessary_cast
          (json["items"] as List).map((item) => Post.fromJson(item)).toList()
              as List<Post>
          : <Post>[],
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "total": total,
      "items": items.map((item) => item.toJson()).toList(),
    };

    return result;
  }

  PostListResponse copyWith({
    int? total,
    List<Post>? items,
  }) {
    return PostListResponse(
      total: total ?? this.total,
      items: items ?? this.items,
    );
  }
}

sealed class PostEvent {
  final String eventType;
  const PostEvent({
    required this.eventType,
  });
  factory PostEvent.fromJson(Map<String, dynamic> json) {
    if (json["eventType"] is! String) {
      throw Exception(
        "Unable to decode PostEvent. Expected String from \"eventType\". Received ${json["eventType"]}}",
      );
    }
    switch (json["eventType"]) {
      case "POST_CREATED":
        return PostEventPostCreated.fromJson(json);
      case "POST_DELETED":
        return PostEventPostDeleted.fromJson(json);
      case "POST_UPDATED":
        return PostEventPostUpdated.fromJson(json);
      case "POST_LIKED":
        return PostEventPostLiked.fromJson(json);
      case "POST_COMMENTED":
        return PostEventPostCommented.fromJson(json);
    }
    throw Exception(
      "Unable to decode PostEvent. \"${json["eventType"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class PostEventPostCreated implements PostEvent {
  @override
  final String eventType = "POST_CREATED";
  final String postId;
  final DateTime timestamp;
  const PostEventPostCreated({
    required this.postId,
    required this.timestamp,
  });
  factory PostEventPostCreated.fromJson(Map<String, dynamic> json) {
    return PostEventPostCreated(
      postId: typeFromDynamic<String>(json["postId"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "eventType": eventType,
      "postId": postId,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return result;
  }

  PostEventPostCreated copyWith({
    String? postId,
    DateTime? timestamp,
  }) {
    return PostEventPostCreated(
      postId: postId ?? this.postId,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class PostEventPostDeleted implements PostEvent {
  @override
  final String eventType = "POST_DELETED";
  final String postId;
  final DateTime timestamp;
  const PostEventPostDeleted({
    required this.postId,
    required this.timestamp,
  });
  factory PostEventPostDeleted.fromJson(Map<String, dynamic> json) {
    return PostEventPostDeleted(
      postId: typeFromDynamic<String>(json["postId"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "eventType": eventType,
      "postId": postId,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return result;
  }

  PostEventPostDeleted copyWith({
    String? postId,
    DateTime? timestamp,
  }) {
    return PostEventPostDeleted(
      postId: postId ?? this.postId,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class PostEventPostUpdated implements PostEvent {
  @override
  final String eventType = "POST_UPDATED";
  final String postId;
  final DateTime timestamp;
  final PostEventPostUpdatedData data;
  const PostEventPostUpdated({
    required this.postId,
    required this.timestamp,
    required this.data,
  });
  factory PostEventPostUpdated.fromJson(Map<String, dynamic> json) {
    return PostEventPostUpdated(
      postId: typeFromDynamic<String>(json["postId"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      data: PostEventPostUpdatedData.fromJson(json["data"]),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "eventType": eventType,
      "postId": postId,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return result;
  }

  PostEventPostUpdated copyWith({
    String? postId,
    DateTime? timestamp,
    PostEventPostUpdatedData? data,
  }) {
    return PostEventPostUpdated(
      postId: postId ?? this.postId,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class PostEventPostUpdatedData {
  final String? id;
  final String? title;
  final PostType? type;
  final String? description;
  final String? content;
  final List<String>? tags;
  final String? authorId;
  final Author? author;
  final DateTime? createdAt;
  final DateTime? updatedAt;
  const PostEventPostUpdatedData({
    this.id,
    this.title,
    this.type,
    this.description,
    this.content,
    this.tags,
    this.authorId,
    this.author,
    this.createdAt,
    this.updatedAt,
  });
  factory PostEventPostUpdatedData.fromJson(Map<String, dynamic> json) {
    return PostEventPostUpdatedData(
      id: nullableTypeFromDynamic<String>(json["id"]),
      title: nullableTypeFromDynamic<String>(json["title"]),
      type: json["type"] is Map<String, dynamic>
          ? PostType.fromJson(json["type"])
          : null,
      description: nullableTypeFromDynamic<String>(json["description"]),
      content: nullableTypeFromDynamic<String>(json["content"]),
      tags: json["tags"] is List
          ?
          // ignore: unnecessary_cast
          (json["tags"] as List)
              .map((item) => typeFromDynamic<String>(item, ""))
              .toList() as List<String>?
          : null,
      authorId: nullableTypeFromDynamic<String>(json["authorId"]),
      author: json["author"] is Map<String, dynamic>
          ? Author.fromJson(json["author"])
          : null,
      createdAt: nullableDateTimeFromDynamic(json["createdAt"]),
      updatedAt: nullableDateTimeFromDynamic(json["updatedAt"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{};
    if (id != null) {
      result["id"] = id;
    }
    if (title != null) {
      result["title"] = title;
    }
    if (type != null) {
      result["type"] = type?.value;
    }
    if (description != null) {
      result["description"] = description;
    }
    if (content != null) {
      result["content"] = content;
    }
    if (tags != null) {
      result["tags"] = tags?.map((item) => item).toList();
    }
    if (authorId != null) {
      result["authorId"] = authorId;
    }
    if (author != null) {
      result["author"] = author?.toJson();
    }
    if (createdAt != null) {
      result["createdAt"] = createdAt?.toUtc().toIso8601String();
    }
    if (updatedAt != null) {
      result["updatedAt"] = updatedAt?.toUtc().toIso8601String();
    }
    return result;
  }

  PostEventPostUpdatedData copyWith({
    String? id,
    String? title,
    PostType? type,
    String? description,
    String? content,
    List<String>? tags,
    String? authorId,
    Author? author,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return PostEventPostUpdatedData(
      id: id ?? this.id,
      title: title ?? this.title,
      type: type ?? this.type,
      description: description ?? this.description,
      content: content ?? this.content,
      tags: tags ?? this.tags,
      authorId: authorId ?? this.authorId,
      author: author ?? this.author,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

class PostEventPostLiked implements PostEvent {
  @override
  final String eventType = "POST_LIKED";
  final String postId;
  final DateTime timestamp;
  final String postLikeId;
  final int postLikeCount;
  const PostEventPostLiked({
    required this.postId,
    required this.timestamp,
    required this.postLikeId,
    required this.postLikeCount,
  });
  factory PostEventPostLiked.fromJson(Map<String, dynamic> json) {
    return PostEventPostLiked(
      postId: typeFromDynamic<String>(json["postId"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      postLikeId: typeFromDynamic<String>(json["postLikeId"], ""),
      postLikeCount: intFromDynamic(json["postLikeCount"], 0),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "eventType": eventType,
      "postId": postId,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "postLikeId": postLikeId,
      "postLikeCount": postLikeCount,
    };

    return result;
  }

  PostEventPostLiked copyWith({
    String? postId,
    DateTime? timestamp,
    String? postLikeId,
    int? postLikeCount,
  }) {
    return PostEventPostLiked(
      postId: postId ?? this.postId,
      timestamp: timestamp ?? this.timestamp,
      postLikeId: postLikeId ?? this.postLikeId,
      postLikeCount: postLikeCount ?? this.postLikeCount,
    );
  }
}

class PostEventPostCommented implements PostEvent {
  @override
  final String eventType = "POST_COMMENTED";
  final String postId;
  final DateTime timestamp;
  final String commentId;
  final String commentText;
  final int commentCount;
  const PostEventPostCommented({
    required this.postId,
    required this.timestamp,
    required this.commentId,
    required this.commentText,
    required this.commentCount,
  });
  factory PostEventPostCommented.fromJson(Map<String, dynamic> json) {
    return PostEventPostCommented(
      postId: typeFromDynamic<String>(json["postId"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      commentId: typeFromDynamic<String>(json["commentId"], ""),
      commentText: typeFromDynamic<String>(json["commentText"], ""),
      commentCount: intFromDynamic(json["commentCount"], 0),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "eventType": eventType,
      "postId": postId,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "commentId": commentId,
      "commentText": commentText,
      "commentCount": commentCount,
    };

    return result;
  }

  PostEventPostCommented copyWith({
    String? postId,
    DateTime? timestamp,
    String? commentId,
    String? commentText,
    int? commentCount,
  }) {
    return PostEventPostCommented(
      postId: postId ?? this.postId,
      timestamp: timestamp ?? this.timestamp,
      commentId: commentId ?? this.commentId,
      commentText: commentText ?? this.commentText,
      commentCount: commentCount ?? this.commentCount,
    );
  }
}

class LogPostEventResponse {
  final bool success;
  final String message;
  const LogPostEventResponse({
    required this.success,
    required this.message,
  });
  factory LogPostEventResponse.fromJson(Map<String, dynamic> json) {
    return LogPostEventResponse(
      success: typeFromDynamic<bool>(json["success"], false),
      message: typeFromDynamic<String>(json["message"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "success": success,
      "message": message,
    };

    return result;
  }

  LogPostEventResponse copyWith({
    bool? success,
    String? message,
  }) {
    return LogPostEventResponse(
      success: success ?? this.success,
      message: message ?? this.message,
    );
  }
}

class UpdatePostParams {
  final String postId;
  final UpdatePostParamsData data;
  const UpdatePostParams({
    required this.postId,
    required this.data,
  });
  factory UpdatePostParams.fromJson(Map<String, dynamic> json) {
    return UpdatePostParams(
      postId: typeFromDynamic<String>(json["postId"], ""),
      data: UpdatePostParamsData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "postId": postId,
      "data": data.toJson(),
    };

    return result;
  }

  UpdatePostParams copyWith({
    String? postId,
    UpdatePostParamsData? data,
  }) {
    return UpdatePostParams(
      postId: postId ?? this.postId,
      data: data ?? this.data,
    );
  }
}

class UpdatePostParamsData {
  final String? title;
  final String? description;
  final String? content;
  final List<String>? tags;
  const UpdatePostParamsData({
    this.title,
    this.description,
    this.content,
    this.tags,
  });
  factory UpdatePostParamsData.fromJson(Map<String, dynamic> json) {
    return UpdatePostParamsData(
      title: nullableTypeFromDynamic<String>(json["title"]),
      description: nullableTypeFromDynamic<String>(json["description"]),
      content: nullableTypeFromDynamic<String>(json["content"]),
      tags: json["tags"] is List
          ?
          // ignore: unnecessary_cast
          (json["tags"] as List)
              .map((item) => typeFromDynamic<String>(item, ""))
              .toList() as List<String>?
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{};
    if (title != null) {
      result["title"] = title;
    }
    if (description != null) {
      result["description"] = description;
    }
    if (content != null) {
      result["content"] = content;
    }
    if (tags != null) {
      result["tags"] = tags?.map((item) => item).toList();
    }
    return result;
  }

  UpdatePostParamsData copyWith({
    String? title,
    String? description,
    String? content,
    List<String>? tags,
  }) {
    return UpdatePostParamsData(
      title: title ?? this.title,
      description: description ?? this.description,
      content: content ?? this.content,
      tags: tags ?? this.tags,
    );
  }
}

class AnnotationId {
  final String id;
  final String version;
  const AnnotationId({
    required this.id,
    required this.version,
  });
  factory AnnotationId.fromJson(Map<String, dynamic> json) {
    return AnnotationId(
      id: typeFromDynamic<String>(json["id"], ""),
      version: typeFromDynamic<String>(json["version"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "version": version,
    };

    return result;
  }

  AnnotationId copyWith({
    String? id,
    String? version,
  }) {
    return AnnotationId(
      id: id ?? this.id,
      version: version ?? this.version,
    );
  }
}

class Annotation {
  final AnnotationId annotationId;
  final AssociatedId associatedId;
  final AnnotationAnnotationType annotationType;
  final int annotationTypeVersion;
  final dynamic metadata;
  final AnnotationBoxTypeRange boxTypeRange;
  const Annotation({
    required this.annotationId,
    required this.associatedId,
    required this.annotationType,
    required this.annotationTypeVersion,
    required this.metadata,
    required this.boxTypeRange,
  });
  factory Annotation.fromJson(Map<String, dynamic> json) {
    return Annotation(
      annotationId: AnnotationId.fromJson(json["annotation_id"]),
      associatedId: AssociatedId.fromJson(json["associated_id"]),
      annotationType:
          AnnotationAnnotationType.fromJson(json["annotation_type"]),
      annotationTypeVersion: intFromDynamic(json["annotation_type_version"], 0),
      metadata: json["metadata"],
      boxTypeRange: AnnotationBoxTypeRange.fromJson(json["box_type_range"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "annotation_id": annotationId.toJson(),
      "associated_id": associatedId.toJson(),
      "annotation_type": annotationType.value,
      "annotation_type_version": annotationTypeVersion,
      "metadata": metadata,
      "box_type_range": boxTypeRange.toJson(),
    };

    return result;
  }

  Annotation copyWith({
    AnnotationId? annotationId,
    AssociatedId? associatedId,
    AnnotationAnnotationType? annotationType,
    int? annotationTypeVersion,
    dynamic metadata,
    AnnotationBoxTypeRange? boxTypeRange,
  }) {
    return Annotation(
      annotationId: annotationId ?? this.annotationId,
      associatedId: associatedId ?? this.associatedId,
      annotationType: annotationType ?? this.annotationType,
      annotationTypeVersion:
          annotationTypeVersion ?? this.annotationTypeVersion,
      metadata: metadata ?? this.metadata,
      boxTypeRange: boxTypeRange ?? this.boxTypeRange,
    );
  }
}

class AssociatedId {
  final AnnotationAssociatedIdEntityType entityType;
  final String id;
  const AssociatedId({
    required this.entityType,
    required this.id,
  });
  factory AssociatedId.fromJson(Map<String, dynamic> json) {
    return AssociatedId(
      entityType:
          AnnotationAssociatedIdEntityType.fromJson(json["entity_type"]),
      id: typeFromDynamic<String>(json["id"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "entity_type": entityType.value,
      "id": id,
    };

    return result;
  }

  AssociatedId copyWith({
    AnnotationAssociatedIdEntityType? entityType,
    String? id,
  }) {
    return AssociatedId(
      entityType: entityType ?? this.entityType,
      id: id ?? this.id,
    );
  }
}

enum AnnotationAssociatedIdEntityType
    implements Comparable<AnnotationAssociatedIdEntityType> {
  movieId("MOVIE_ID"),
  showId("SHOW_ID");

  const AnnotationAssociatedIdEntityType(this.value);
  final String value;

  factory AnnotationAssociatedIdEntityType.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return movieId;
  }

  @override
  compareTo(AnnotationAssociatedIdEntityType other) =>
      name.compareTo(other.name);
}

enum AnnotationAnnotationType implements Comparable<AnnotationAnnotationType> {
  annotationBoundingbox("ANNOTATION_BOUNDINGBOX");

  const AnnotationAnnotationType(this.value);
  final String value;

  factory AnnotationAnnotationType.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return annotationBoundingbox;
  }

  @override
  compareTo(AnnotationAnnotationType other) => name.compareTo(other.name);
}

class AnnotationBoxTypeRange {
  final BigInt startTimeInNanoSec;
  final BigInt endTimeInNanoSec;
  const AnnotationBoxTypeRange({
    required this.startTimeInNanoSec,
    required this.endTimeInNanoSec,
  });
  factory AnnotationBoxTypeRange.fromJson(Map<String, dynamic> json) {
    return AnnotationBoxTypeRange(
      startTimeInNanoSec:
          bigIntFromDynamic(json["start_time_in_nano_sec"], BigInt.zero),
      endTimeInNanoSec:
          bigIntFromDynamic(json["end_time_in_nano_sec"], BigInt.zero),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "start_time_in_nano_sec": startTimeInNanoSec.toString(),
      "end_time_in_nano_sec": endTimeInNanoSec.toString(),
    };

    return result;
  }

  AnnotationBoxTypeRange copyWith({
    BigInt? startTimeInNanoSec,
    BigInt? endTimeInNanoSec,
  }) {
    return AnnotationBoxTypeRange(
      startTimeInNanoSec: startTimeInNanoSec ?? this.startTimeInNanoSec,
      endTimeInNanoSec: endTimeInNanoSec ?? this.endTimeInNanoSec,
    );
  }
}

class UpdateAnnotationParams {
  final String annotationId;
  final String annotationIdVersion;
  final UpdateAnnotationData data;
  const UpdateAnnotationParams({
    required this.annotationId,
    required this.annotationIdVersion,
    required this.data,
  });
  factory UpdateAnnotationParams.fromJson(Map<String, dynamic> json) {
    return UpdateAnnotationParams(
      annotationId: typeFromDynamic<String>(json["annotation_id"], ""),
      annotationIdVersion:
          typeFromDynamic<String>(json["annotation_id_version"], ""),
      data: UpdateAnnotationData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "annotation_id": annotationId,
      "annotation_id_version": annotationIdVersion,
      "data": data.toJson(),
    };

    return result;
  }

  UpdateAnnotationParams copyWith({
    String? annotationId,
    String? annotationIdVersion,
    UpdateAnnotationData? data,
  }) {
    return UpdateAnnotationParams(
      annotationId: annotationId ?? this.annotationId,
      annotationIdVersion: annotationIdVersion ?? this.annotationIdVersion,
      data: data ?? this.data,
    );
  }
}

class UpdateAnnotationData {
  final AssociatedId? associatedId;
  final UpdateAnnotationParamsDataAnnotationType? annotationType;
  final int? annotationTypeVersion;
  final dynamic metadata;
  final UpdateAnnotationParamsDataBoxTypeRange? boxTypeRange;
  const UpdateAnnotationData({
    this.associatedId,
    this.annotationType,
    this.annotationTypeVersion,
    this.metadata,
    this.boxTypeRange,
  });
  factory UpdateAnnotationData.fromJson(Map<String, dynamic> json) {
    return UpdateAnnotationData(
      associatedId: json["associated_id"] is Map<String, dynamic>
          ? AssociatedId.fromJson(json["associated_id"])
          : null,
      annotationType: json["annotation_type"] is Map<String, dynamic>
          ? UpdateAnnotationParamsDataAnnotationType.fromJson(
              json["annotation_type"])
          : null,
      annotationTypeVersion:
          nullableIntFromDynamic(json["annotation_type_version"]),
      metadata: json["metadata"],
      boxTypeRange: json["box_type_range"] is Map<String, dynamic>
          ? UpdateAnnotationParamsDataBoxTypeRange.fromJson(
              json["box_type_range"])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{};
    if (associatedId != null) {
      result["associated_id"] = associatedId?.toJson();
    }
    if (annotationType != null) {
      result["annotation_type"] = annotationType?.value;
    }
    if (annotationTypeVersion != null) {
      result["annotation_type_version"] = annotationTypeVersion;
    }
    if (metadata != null) {
      result["metadata"] = metadata;
    }
    if (boxTypeRange != null) {
      result["box_type_range"] = boxTypeRange?.toJson();
    }
    return result;
  }

  UpdateAnnotationData copyWith({
    AssociatedId? associatedId,
    UpdateAnnotationParamsDataAnnotationType? annotationType,
    int? annotationTypeVersion,
    dynamic metadata,
    UpdateAnnotationParamsDataBoxTypeRange? boxTypeRange,
  }) {
    return UpdateAnnotationData(
      associatedId: associatedId ?? this.associatedId,
      annotationType: annotationType ?? this.annotationType,
      annotationTypeVersion:
          annotationTypeVersion ?? this.annotationTypeVersion,
      metadata: metadata ?? this.metadata,
      boxTypeRange: boxTypeRange ?? this.boxTypeRange,
    );
  }
}

enum UpdateAnnotationParamsDataAnnotationType
    implements Comparable<UpdateAnnotationParamsDataAnnotationType> {
  annotationBoundingbox("ANNOTATION_BOUNDINGBOX");

  const UpdateAnnotationParamsDataAnnotationType(this.value);
  final String value;

  factory UpdateAnnotationParamsDataAnnotationType.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return annotationBoundingbox;
  }

  @override
  compareTo(UpdateAnnotationParamsDataAnnotationType other) =>
      name.compareTo(other.name);
}

class UpdateAnnotationParamsDataBoxTypeRange {
  final BigInt startTimeInNanoSec;
  final BigInt endTimeInNanoSec;
  const UpdateAnnotationParamsDataBoxTypeRange({
    required this.startTimeInNanoSec,
    required this.endTimeInNanoSec,
  });
  factory UpdateAnnotationParamsDataBoxTypeRange.fromJson(
      Map<String, dynamic> json) {
    return UpdateAnnotationParamsDataBoxTypeRange(
      startTimeInNanoSec:
          bigIntFromDynamic(json["start_time_in_nano_sec"], BigInt.zero),
      endTimeInNanoSec:
          bigIntFromDynamic(json["end_time_in_nano_sec"], BigInt.zero),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "start_time_in_nano_sec": startTimeInNanoSec.toString(),
      "end_time_in_nano_sec": endTimeInNanoSec.toString(),
    };

    return result;
  }

  UpdateAnnotationParamsDataBoxTypeRange copyWith({
    BigInt? startTimeInNanoSec,
    BigInt? endTimeInNanoSec,
  }) {
    return UpdateAnnotationParamsDataBoxTypeRange(
      startTimeInNanoSec: startTimeInNanoSec ?? this.startTimeInNanoSec,
      endTimeInNanoSec: endTimeInNanoSec ?? this.endTimeInNanoSec,
    );
  }
}
