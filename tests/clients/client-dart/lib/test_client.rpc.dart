// this file was autogenerated by arri
import "dart:convert";
import "package:arri_client/arri_client.dart";

class TestClient {
  final String _baseUrl;
  late final Map<String, String> _headers;
  TestClient({
    String baseUrl = "",
    Map<String, String> headers = const {},
  }) : _baseUrl = baseUrl {
    _headers = {"client-version": "9", ...headers};
  }

  TestClientPostsService get posts {
    return TestClientPostsService(
      baseUrl: _baseUrl,
      headers: _headers,
    );
  }

  TestClientVideosService get videos {
    return TestClientVideosService(
      baseUrl: _baseUrl,
      headers: _headers,
    );
  }
}

class TestClientPostsService {
  final String _baseUrl;
  late final Map<String, String> _headers;
  TestClientPostsService({
    String baseUrl = "",
    Map<String, String> headers = const {},
  }) : _baseUrl = baseUrl {
    _headers = {"client-version": "9", ...headers};
  }

  Future<Post> getPost(PostParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/posts/get-post",
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => Post.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<PostListResponse> getPosts(PostListParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/posts/get-posts",
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => PostListResponse.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<Post> updatePost(UpdatePostParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/posts/update-post",
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => Post.fromJson(
        json.decode(body),
      ),
    );
  }
}

class TestClientVideosService {
  final String _baseUrl;
  late final Map<String, String> _headers;
  TestClientVideosService({
    String baseUrl = "",
    Map<String, String> headers = const {},
  }) : _baseUrl = baseUrl {
    _headers = {"client-version": "9", ...headers};
  }

  Future<Annotation> getAnnotation(AnnotationId params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/videos/get-annotation",
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => Annotation.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<Annotation> updateAnnotation(UpdateAnnotationParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/videos/update-annotation",
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => Annotation.fromJson(
        json.decode(body),
      ),
    );
  }
}

class PostParams {
  final String postId;
  const PostParams({
    required this.postId,
  });
  factory PostParams.fromJson(Map<String, dynamic> json) {
    return PostParams(
      postId: typeFromDynamic<String>(json["postId"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "postId": postId,
    };

    return result;
  }

  PostParams copyWith({
    String? postId,
  }) {
    return PostParams(
      postId: postId ?? this.postId,
    );
  }
}

class Post {
  final String id;
  final String title;
  final PostType type;
  final String? description;
  final String content;
  final List<String> tags;
  final String authorId;
  final Author author;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Post({
    required this.id,
    required this.title,
    required this.type,
    required this.description,
    required this.content,
    required this.tags,
    required this.authorId,
    required this.author,
    required this.createdAt,
    required this.updatedAt,
  });
  factory Post.fromJson(Map<String, dynamic> json) {
    return Post(
      id: typeFromDynamic<String>(json["id"], ""),
      title: typeFromDynamic<String>(json["title"], ""),
      type: PostType.fromJson(json["type"]),
      description: nullableTypeFromDynamic<String>(json["description"]),
      content: typeFromDynamic<String>(json["content"], ""),
      tags: json["tags"] is List
          ? (json["tags"] as List)
              .map((item) => typeFromDynamic<String>(item, ""))
              .toList()
          : [],
      authorId: typeFromDynamic<String>(json["authorId"], ""),
      author: Author.fromJson(json["author"]),
      createdAt: dateTimeFromDynamic(
        json["createdAt"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      updatedAt: dateTimeFromDynamic(
        json["updatedAt"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "title": title,
      "type": type.value,
      "description": description,
      "content": content,
      "tags": tags.map((item) => item).toList(),
      "authorId": authorId,
      "author": author.toJson(),
      "createdAt": createdAt.toUtc().toIso8601String(),
      "updatedAt": updatedAt.toUtc().toIso8601String(),
    };

    return result;
  }

  Post copyWith({
    String? id,
    String? title,
    PostType? type,
    String? description,
    String? content,
    List<String>? tags,
    String? authorId,
    Author? author,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      type: type ?? this.type,
      description: description ?? this.description,
      content: content ?? this.content,
      tags: tags ?? this.tags,
      authorId: authorId ?? this.authorId,
      author: author ?? this.author,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

enum PostType implements Comparable<PostType> {
  text("text"),
  image("image"),
  video("video");

  const PostType(this.value);
  final String value;

  factory PostType.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return text;
  }

  @override
  compareTo(PostType other) => name.compareTo(other.name);
}

class Author {
  final String id;
  final String name;
  final String? bio;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Author({
    required this.id,
    required this.name,
    required this.bio,
    required this.createdAt,
    required this.updatedAt,
  });
  factory Author.fromJson(Map<String, dynamic> json) {
    return Author(
      id: typeFromDynamic<String>(json["id"], ""),
      name: typeFromDynamic<String>(json["name"], ""),
      bio: nullableTypeFromDynamic<String>(json["bio"]),
      createdAt: dateTimeFromDynamic(
        json["createdAt"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      updatedAt: dateTimeFromDynamic(
        json["updatedAt"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "name": name,
      "bio": bio,
      "createdAt": createdAt.toUtc().toIso8601String(),
      "updatedAt": updatedAt.toUtc().toIso8601String(),
    };

    return result;
  }

  Author copyWith({
    String? id,
    String? name,
    String? bio,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return Author(
      id: id ?? this.id,
      name: name ?? this.name,
      bio: bio ?? this.bio,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

class PostListParams {
  final int limit;
  final PostType? type;
  const PostListParams({
    required this.limit,
    this.type,
  });
  factory PostListParams.fromJson(Map<String, dynamic> json) {
    return PostListParams(
      limit: intFromDynamic(json["limit"], 0),
      type: json["type"] is Map<String, dynamic>
          ? PostType.fromJson(json["type"])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "limit": limit,
    };
    if (type != null) {
      result["type"] = type?.value;
    }
    return result;
  }

  PostListParams copyWith({
    int? limit,
    PostType? type,
  }) {
    return PostListParams(
      limit: limit ?? this.limit,
      type: type ?? this.type,
    );
  }
}

class PostListResponse {
  final int total;
  final List<Post> items;
  const PostListResponse({
    required this.total,
    required this.items,
  });
  factory PostListResponse.fromJson(Map<String, dynamic> json) {
    return PostListResponse(
      total: intFromDynamic(json["total"], 0),
      items: json["items"] is List
          ? (json["items"] as List).map((item) => Post.fromJson(item)).toList()
          : [],
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "total": total,
      "items": items.map((item) => item.toJson()).toList(),
    };

    return result;
  }

  PostListResponse copyWith({
    int? total,
    List<Post>? items,
  }) {
    return PostListResponse(
      total: total ?? this.total,
      items: items ?? this.items,
    );
  }
}

class UpdatePostParams {
  final String postId;
  final UpdatePostParamsData data;
  const UpdatePostParams({
    required this.postId,
    required this.data,
  });
  factory UpdatePostParams.fromJson(Map<String, dynamic> json) {
    return UpdatePostParams(
      postId: typeFromDynamic<String>(json["postId"], ""),
      data: UpdatePostParamsData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "postId": postId,
      "data": data.toJson(),
    };

    return result;
  }

  UpdatePostParams copyWith({
    String? postId,
    UpdatePostParamsData? data,
  }) {
    return UpdatePostParams(
      postId: postId ?? this.postId,
      data: data ?? this.data,
    );
  }
}

class UpdatePostParamsData {
  final String? title;
  final String? description;
  final String? content;
  final List<String>? tags;
  const UpdatePostParamsData({
    this.title,
    this.description,
    this.content,
    this.tags,
  });
  factory UpdatePostParamsData.fromJson(Map<String, dynamic> json) {
    return UpdatePostParamsData(
      title: nullableTypeFromDynamic<String>(json["title"]),
      description: nullableTypeFromDynamic<String>(json["description"]),
      content: nullableTypeFromDynamic<String>(json["content"]),
      tags: json["tags"] is List
          ? (json["tags"] as List)
              .map((item) => typeFromDynamic<String>(item, ""))
              .toList()
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{};
    if (title != null) {
      result["title"] = title;
    }
    if (description != null) {
      result["description"] = description;
    }
    if (content != null) {
      result["content"] = content;
    }
    if (tags != null) {
      result["tags"] = tags?.map((item) => item).toList();
    }
    return result;
  }

  UpdatePostParamsData copyWith({
    String? title,
    String? description,
    String? content,
    List<String>? tags,
  }) {
    return UpdatePostParamsData(
      title: title ?? this.title,
      description: description ?? this.description,
      content: content ?? this.content,
      tags: tags ?? this.tags,
    );
  }
}

class AnnotationId {
  final String id;
  final String version;
  const AnnotationId({
    required this.id,
    required this.version,
  });
  factory AnnotationId.fromJson(Map<String, dynamic> json) {
    return AnnotationId(
      id: typeFromDynamic<String>(json["id"], ""),
      version: typeFromDynamic<String>(json["version"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "id": id,
      "version": version,
    };

    return result;
  }

  AnnotationId copyWith({
    String? id,
    String? version,
  }) {
    return AnnotationId(
      id: id ?? this.id,
      version: version ?? this.version,
    );
  }
}

class Annotation {
  final AnnotationId annotationId;
  final AssociatedId associatedId;
  final AnnotationAnnotationType annotationType;
  final int annotationTypeVersion;
  final dynamic metadata;
  final AnnotationBoxTypeRange boxTypeRange;
  const Annotation({
    required this.annotationId,
    required this.associatedId,
    required this.annotationType,
    required this.annotationTypeVersion,
    required this.metadata,
    required this.boxTypeRange,
  });
  factory Annotation.fromJson(Map<String, dynamic> json) {
    return Annotation(
      annotationId: AnnotationId.fromJson(json["annotation_id"]),
      associatedId: AssociatedId.fromJson(json["associated_id"]),
      annotationType:
          AnnotationAnnotationType.fromJson(json["annotation_type"]),
      annotationTypeVersion: intFromDynamic(json["annotation_type_version"], 0),
      metadata: json["metadata"],
      boxTypeRange: AnnotationBoxTypeRange.fromJson(json["box_type_range"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "annotation_id": annotationId.toJson(),
      "associated_id": associatedId.toJson(),
      "annotation_type": annotationType.value,
      "annotation_type_version": annotationTypeVersion,
      "metadata": metadata,
      "box_type_range": boxTypeRange.toJson(),
    };

    return result;
  }

  Annotation copyWith({
    AnnotationId? annotationId,
    AssociatedId? associatedId,
    AnnotationAnnotationType? annotationType,
    int? annotationTypeVersion,
    dynamic metadata,
    AnnotationBoxTypeRange? boxTypeRange,
  }) {
    return Annotation(
      annotationId: annotationId ?? this.annotationId,
      associatedId: associatedId ?? this.associatedId,
      annotationType: annotationType ?? this.annotationType,
      annotationTypeVersion:
          annotationTypeVersion ?? this.annotationTypeVersion,
      metadata: metadata ?? this.metadata,
      boxTypeRange: boxTypeRange ?? this.boxTypeRange,
    );
  }
}

class AssociatedId {
  final AnnotationAssociatedIdEntityType entityType;
  final String id;
  const AssociatedId({
    required this.entityType,
    required this.id,
  });
  factory AssociatedId.fromJson(Map<String, dynamic> json) {
    return AssociatedId(
      entityType:
          AnnotationAssociatedIdEntityType.fromJson(json["entity_type"]),
      id: typeFromDynamic<String>(json["id"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "entity_type": entityType.value,
      "id": id,
    };

    return result;
  }

  AssociatedId copyWith({
    AnnotationAssociatedIdEntityType? entityType,
    String? id,
  }) {
    return AssociatedId(
      entityType: entityType ?? this.entityType,
      id: id ?? this.id,
    );
  }
}

enum AnnotationAssociatedIdEntityType
    implements Comparable<AnnotationAssociatedIdEntityType> {
  mOVIEID("MOVIE_ID"),
  sHOWID("SHOW_ID");

  const AnnotationAssociatedIdEntityType(this.value);
  final String value;

  factory AnnotationAssociatedIdEntityType.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return mOVIEID;
  }

  @override
  compareTo(AnnotationAssociatedIdEntityType other) =>
      name.compareTo(other.name);
}

enum AnnotationAnnotationType implements Comparable<AnnotationAnnotationType> {
  aNNOTATIONBOUNDINGBOX("ANNOTATION_BOUNDINGBOX");

  const AnnotationAnnotationType(this.value);
  final String value;

  factory AnnotationAnnotationType.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return aNNOTATIONBOUNDINGBOX;
  }

  @override
  compareTo(AnnotationAnnotationType other) => name.compareTo(other.name);
}

class AnnotationBoxTypeRange {
  final BigInt startTimeInNanoSec;
  final BigInt endTimeInNanoSec;
  const AnnotationBoxTypeRange({
    required this.startTimeInNanoSec,
    required this.endTimeInNanoSec,
  });
  factory AnnotationBoxTypeRange.fromJson(Map<String, dynamic> json) {
    return AnnotationBoxTypeRange(
      startTimeInNanoSec:
          bigIntFromDynamic(json["start_time_in_nano_sec"], BigInt.zero),
      endTimeInNanoSec:
          bigIntFromDynamic(json["end_time_in_nano_sec"], BigInt.zero),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "start_time_in_nano_sec": startTimeInNanoSec.toString(),
      "end_time_in_nano_sec": endTimeInNanoSec.toString(),
    };

    return result;
  }

  AnnotationBoxTypeRange copyWith({
    BigInt? startTimeInNanoSec,
    BigInt? endTimeInNanoSec,
  }) {
    return AnnotationBoxTypeRange(
      startTimeInNanoSec: startTimeInNanoSec ?? this.startTimeInNanoSec,
      endTimeInNanoSec: endTimeInNanoSec ?? this.endTimeInNanoSec,
    );
  }
}

class UpdateAnnotationParams {
  final String annotationId;
  final String annotationIdVersion;
  final UpdateAnnotationData data;
  const UpdateAnnotationParams({
    required this.annotationId,
    required this.annotationIdVersion,
    required this.data,
  });
  factory UpdateAnnotationParams.fromJson(Map<String, dynamic> json) {
    return UpdateAnnotationParams(
      annotationId: typeFromDynamic<String>(json["annotation_id"], ""),
      annotationIdVersion:
          typeFromDynamic<String>(json["annotation_id_version"], ""),
      data: UpdateAnnotationData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "annotation_id": annotationId,
      "annotation_id_version": annotationIdVersion,
      "data": data.toJson(),
    };

    return result;
  }

  UpdateAnnotationParams copyWith({
    String? annotationId,
    String? annotationIdVersion,
    UpdateAnnotationData? data,
  }) {
    return UpdateAnnotationParams(
      annotationId: annotationId ?? this.annotationId,
      annotationIdVersion: annotationIdVersion ?? this.annotationIdVersion,
      data: data ?? this.data,
    );
  }
}

class UpdateAnnotationData {
  final AssociatedId? associatedId;
  final UpdateAnnotationParamsDataAnnotationType? annotationType;
  final int? annotationTypeVersion;
  final dynamic metadata;
  final UpdateAnnotationParamsDataBoxTypeRange? boxTypeRange;
  const UpdateAnnotationData({
    this.associatedId,
    this.annotationType,
    this.annotationTypeVersion,
    this.metadata,
    this.boxTypeRange,
  });
  factory UpdateAnnotationData.fromJson(Map<String, dynamic> json) {
    return UpdateAnnotationData(
      associatedId: json["associated_id"] is Map<String, dynamic>
          ? AssociatedId.fromJson(json["associated_id"])
          : null,
      annotationType: json["annotation_type"] is Map<String, dynamic>
          ? UpdateAnnotationParamsDataAnnotationType.fromJson(
              json["annotation_type"])
          : null,
      annotationTypeVersion:
          nullableIntFromDynamic(json["annotation_type_version"]),
      metadata: json["metadata"],
      boxTypeRange: json["box_type_range"] is Map<String, dynamic>
          ? UpdateAnnotationParamsDataBoxTypeRange.fromJson(
              json["box_type_range"])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{};
    if (associatedId != null) {
      result["associated_id"] = associatedId?.toJson();
    }
    if (annotationType != null) {
      result["annotation_type"] = annotationType?.value;
    }
    if (annotationTypeVersion != null) {
      result["annotation_type_version"] = annotationTypeVersion;
    }
    if (metadata != null) {
      result["metadata"] = metadata;
    }
    if (boxTypeRange != null) {
      result["box_type_range"] = boxTypeRange?.toJson();
    }
    return result;
  }

  UpdateAnnotationData copyWith({
    AssociatedId? associatedId,
    UpdateAnnotationParamsDataAnnotationType? annotationType,
    int? annotationTypeVersion,
    dynamic metadata,
    UpdateAnnotationParamsDataBoxTypeRange? boxTypeRange,
  }) {
    return UpdateAnnotationData(
      associatedId: associatedId ?? this.associatedId,
      annotationType: annotationType ?? this.annotationType,
      annotationTypeVersion:
          annotationTypeVersion ?? this.annotationTypeVersion,
      metadata: metadata ?? this.metadata,
      boxTypeRange: boxTypeRange ?? this.boxTypeRange,
    );
  }
}

enum UpdateAnnotationParamsDataAnnotationType
    implements Comparable<UpdateAnnotationParamsDataAnnotationType> {
  aNNOTATIONBOUNDINGBOX("ANNOTATION_BOUNDINGBOX");

  const UpdateAnnotationParamsDataAnnotationType(this.value);
  final String value;

  factory UpdateAnnotationParamsDataAnnotationType.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return aNNOTATIONBOUNDINGBOX;
  }

  @override
  compareTo(UpdateAnnotationParamsDataAnnotationType other) =>
      name.compareTo(other.name);
}

class UpdateAnnotationParamsDataBoxTypeRange {
  final BigInt startTimeInNanoSec;
  final BigInt endTimeInNanoSec;
  const UpdateAnnotationParamsDataBoxTypeRange({
    required this.startTimeInNanoSec,
    required this.endTimeInNanoSec,
  });
  factory UpdateAnnotationParamsDataBoxTypeRange.fromJson(
      Map<String, dynamic> json) {
    return UpdateAnnotationParamsDataBoxTypeRange(
      startTimeInNanoSec:
          bigIntFromDynamic(json["start_time_in_nano_sec"], BigInt.zero),
      endTimeInNanoSec:
          bigIntFromDynamic(json["end_time_in_nano_sec"], BigInt.zero),
    );
  }

  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      "start_time_in_nano_sec": startTimeInNanoSec.toString(),
      "end_time_in_nano_sec": endTimeInNanoSec.toString(),
    };

    return result;
  }

  UpdateAnnotationParamsDataBoxTypeRange copyWith({
    BigInt? startTimeInNanoSec,
    BigInt? endTimeInNanoSec,
  }) {
    return UpdateAnnotationParamsDataBoxTypeRange(
      startTimeInNanoSec: startTimeInNanoSec ?? this.startTimeInNanoSec,
      endTimeInNanoSec: endTimeInNanoSec ?? this.endTimeInNanoSec,
    );
  }
}
