import { execSync } from "child_process";
import { writeFileSync } from "fs";
import {
    type ServiceDefinition,
    isRpcDefinition,
    type RpcDefinition,
    type SchemaFormProperties,
    type SchemaFormType,
    isTypeForm,
    type Schema,
    isPropertiesForm,
    isElementsForm,
    isEnumForm,
    isValuesForm,
    isDiscriminatorForm,
    type AppDefinition,
    unflattenProcedures,
    isServiceDefinition,
} from "arri-codegen-utils";
import { a } from "packages/arri-validate/dist";
import { camelCase, pascalCase } from "scule";
import { defineClientGeneratorPlugin } from "./plugin";

export interface DartClientGeneratorOptions {
    clientName: string;
    outputFile: string;
}

export const dartClientGenerator = defineClientGeneratorPlugin(
    (options: DartClientGeneratorOptions) => {
        return {
            generator: async (def) => {
                if (!options.clientName) {
                    throw new Error(
                        'Missing "clientName" cannot generate dart client',
                    );
                }
                if (!options.outputFile) {
                    throw new Error(
                        'Missing "outputFile" cannot generate dart client',
                    );
                }
                const numProcedures = Object.keys(def.procedures).length;
                if (numProcedures <= 0) {
                    console.warn(
                        "No procedures found in definition file. Dart client will not be generated",
                    );
                }
                const result = createDartClient(def, options);
                writeFileSync(options.outputFile, result);
                try {
                    execSync(`dart format ${options.outputFile}`);
                } catch (err) {
                    console.error("Error formatting dart client", err);
                }
            },
            options,
        };
    },
);

export function createDartClient(
    def: AppDefinition,
    opts: DartClientGeneratorOptions,
): string {
    const services = unflattenProcedures(def.procedures);
    const rpcParts: string[] = [];
    const serviceGetterParts: string[] = [];
    const serviceParts: string[] = [];
    const modelParts: string[] = [];

    Object.keys(services).forEach((key) => {
        const item = services[key];
        if (isRpcDefinition(item)) {
            const rpc = dartRpcFromDefinition(key, item, opts);
            rpcParts.push(rpc);
            return;
        }
        if (isServiceDefinition(item)) {
            const serviceName: string = pascalCase(`${opts.clientName}_${key}`);
            const service = dartServiceFromDefinition(serviceName, item, opts);
            serviceParts.push(service);
            serviceGetterParts.push(`${serviceName}Service get ${key} {
  return ${serviceName}Service(
    baseUrl: _baseUrl, 
    headers: _headers,
  );
}`);
        }
    });

    Object.keys(def.models).forEach((key) => {
        const item = def.models[key];
        const result = dartClassFromJtdSchema(key, item, false);
        modelParts.push(result.content);
    });

    return `// this file was autogenerated by arri
import 'dart:convert';
import 'package:arri_client/arri_client.dart';

class ${opts.clientName} {
  final String _baseUrl;
  final Map<String, String> _headers;
  const ${opts.clientName}({
    String baseUrl = "",
    Map<String, String> headers = const {},
  })  : _baseUrl = baseUrl,
  _headers = headers;
  ${rpcParts.join("\n  ")}
  ${serviceGetterParts.join("\n  ")}
}

${serviceParts.join("\n")}

${modelParts.join("\n")}
`;
}

export function dartServiceFromDefinition(
    name: string,
    def: ServiceDefinition,
    opts: DartClientGeneratorOptions,
) {
    const rpcParts: string[] = [];
    const subServiceParts: Array<{
        name: string;
        key: string;
        content: string;
    }> = [];
    const serviceName = `${name}`;
    Object.keys(def).forEach((key) => {
        const item = def[key];
        if (isRpcDefinition(item)) {
            rpcParts.push(dartRpcFromDefinition(key, item, opts));
            return;
        }
        const nameParts = name.split("Service");
        nameParts.pop();
        const subServiceName = pascalCase(
            `${nameParts.join("")}_${key}_Service`,
        );
        const subService = dartServiceFromDefinition(
            subServiceName,
            item,
            opts,
        );
        subServiceParts.push({
            name: subServiceName,
            key,
            content: subService,
        });
    });
    return `class ${serviceName}Service {
  final String _baseUrl;
  final Map<String, String> _headers;
  const ${serviceName}Service({
    String baseUrl = "",
    Map<String, String> headers = const {},
  })  : _baseUrl = baseUrl,
  _headers = headers;
  ${subServiceParts
      .map(
          (sub) => `${sub.name} get ${sub.key} {
    return ${sub.name}(
        baseUrl: _baseUrl,
        headers: _headers,
    );
  }`,
      )
      .join("\n")}
  ${rpcParts.join("\n  ")}
}
${subServiceParts.map((sub) => sub.content).join("\n")}
`;
}

export function dartRpcFromDefinition(
    key: string,
    def: RpcDefinition,
    opts: DartClientGeneratorOptions,
): string {
    let returnType:
        | `Future<String>`
        | "Future<int>"
        | "Future<number>"
        | "Future<void>"
        | `Future<${string}>` = `Future<String>`;
    let returnTypeName = "String";
    if (def.response) {
        returnType = `Future<${pascalCase(def.response)}>`;
        returnTypeName = pascalCase(def.response);
    } else {
        returnType = "Future<void>";
    }
    let paramsInput = "";
    if (def.params) {
        paramsInput = `${pascalCase(def.params)} params`;
    }
    let responseParser: string = "(body) => body;";
    switch (returnType) {
        case "Future<String>":
            break;
        case "Future<int>":
            responseParser = `(body) => Int.parse(body)`;
            break;
        case "Future<double>":
            responseParser = `(body) => Double.parse(body)`;
            break;
        case "Future<void>":
            responseParser = `(body) {}`;
            break;
        case "Future<bool>":
            responseParser = `(body) {
                        switch(body) {
                            case "true":
                            case "1":
                                return true;
                            case "false":
                            case "0":
                            default:
                                return false;
                        }
                    }`;
            break;
        default:
            responseParser = `(body) => ${returnTypeName}.fromJson(
                json.decode(body),
            )`;
            break;
    }
    return `${returnType} ${key}(${paramsInput}) {
    return parsedArriRequest(
      "$_baseUrl${def.path}",
      method: HttpMethod.${def.method},
      headers: _headers,
      params: ${paramsInput.length ? `params.toJson()` : "null"},
      parser: ${responseParser},
    );
  }`;
}

export function dartTypeFromJtdSchema(
    /**
     * location in the tree i.e User.reviews.id
     */
    nodePath: string,
    def: Schema,
    isOptional: boolean,
): DartProperty {
    if (isTypeForm(def)) {
        return dartScalarFromJtdScalar(nodePath, def, isOptional);
    }
    if (isPropertiesForm(def)) {
        return dartClassFromJtdSchema(nodePath, def, isOptional);
    }
    if (isElementsForm(def)) {
        // handle arrays
    }
    if (isEnumForm(def)) {
        // handle enum
    }
    if (isValuesForm(def)) {
        // handle records/maps
    }
    if (isDiscriminatorForm(def)) {
        // handle discriminated unions
    }
    return dartDynamicFromAny(nodePath, a.any(), true);
}

export function dartClassFromJtdSchema(
    nodePath: string,
    def: SchemaFormProperties,
    isOptional: boolean,
): DartProperty {
    const jsonKey = nodePath.split(".").pop() ?? "";
    const key = camelCase(jsonKey);
    let className = def.metadata?.id ? pascalCase(def.metadata.id) : undefined;
    if (!className) {
        className = pascalCase(nodePath.split(".").join("_"));
    }
    const properties: { key: string; templates: DartProperty }[] = [];
    const optionalProperties: { key: string; templates: DartProperty }[] = [];
    const subContentParts: string[] = [];
    if (!def.properties) {
        return {
            typeName: "",
            fieldTemplate: "",
            constructorTemplate: "",
            fromJsonTemplate: "",
            toJsonTemplate: "",
            content: "",
        };
    }

    for (const key of Object.keys(def.properties ?? {})) {
        const keyPath = `${nodePath}.${key}`;
        const prop = def.properties[key];
        const mappedProp = dartTypeFromJtdSchema(keyPath, prop, false);
        properties.push({
            key,
            templates: mappedProp,
        });
        if (mappedProp?.content) {
            subContentParts.push(mappedProp.content);
        }
    }
    if (def.optionalProperties) {
        for (const key of Object.keys(def.optionalProperties ?? {})) {
            const keyPath = `${nodePath}.${key}`;
            const prop = def.optionalProperties[key];
            const mappedProp = dartTypeFromJtdSchema(keyPath, prop, true);
            optionalProperties.push({ key, templates: mappedProp });
            if (mappedProp?.content) {
                subContentParts.push(mappedProp.content);
            }
        }
    }
    const fieldParts: string[] = [];
    const constructorParts: string[] = [];
    const fromJsonParts: string[] = [];
    for (const prop of properties) {
        fieldParts.push(prop.templates.fieldTemplate);
        constructorParts.push(prop.templates.constructorTemplate);
        fromJsonParts.push(
            `${camelCase(prop.key)}: ${prop.templates.fromJsonTemplate}`,
        );
    }
    for (const prop of optionalProperties) {
        fieldParts.push(prop.templates.fieldTemplate);
        constructorParts.push(prop.templates.constructorTemplate);
        fromJsonParts.push(
            `${camelCase(prop.key)}: ${prop.templates.fromJsonTemplate}`,
        );
    }
    const content = `class ${className} {
    ${fieldParts.join(";\n  ")};
  const ${className}({
    ${constructorParts.join(",\n    ")},
  });
  factory ${className}.fromJson(Map<String, dynamic> json) {
    return ${className}(
      ${fromJsonParts.join(",\n      ")},
    );
  }
  static List<${className}> fromJsonList(List<dynamic> json) {
    return json.map((item) => ${className}.fromJson(item)).toList();
  }
  Map<String, dynamic> toJson() {
    final result = <String, dynamic>{
      ${properties
          .map((prop) => `"${prop.key}": ${prop.templates.toJsonTemplate}`)
          .join(",\n      ")},
    };
    ${optionalProperties
        .map(
            (prop) => `if (${camelCase(prop.key)} != null) {
      result["${prop.key}"] = ${prop.templates.toJsonTemplate};
    }`,
        )
        .join("\n")}
    return result;
  }
}
}
${subContentParts.join("\n")}

`;
    const isNullable = def.nullable ?? isOptional;
    return {
        typeName: className,
        fieldTemplate: isNullable
            ? `final ${className}? ${key}`
            : `final ${className} ${key}`,
        constructorTemplate: isOptional
            ? `this.${key}`
            : `required this.${key}`,
        fromJsonTemplate: isOptional
            ? `json["${jsonKey}"] is Map<String, dynamic> ? ${className}.fromJson(json["${jsonKey}"]) : null`
            : `${className}.fromJson(json["${jsonKey}"])`,
        toJsonTemplate: `${key}${isNullable ? "?" : ""}.toJson()`,
        content,
    };
}

interface DartProperty {
    typeName: string;
    fieldTemplate: string;
    constructorTemplate: string;
    fromJsonTemplate: string;
    toJsonTemplate: string;
    content: string;
}

function dartDynamicFromAny(
    nodePath: string,
    def: Schema,
    isOptional = false,
): DartProperty {
    const jsonKey = nodePath.split(".").pop() ?? "";
    const key = camelCase(jsonKey);
    return {
        typeName: "dynamic",
        fieldTemplate: `final dynamic ${key}`,
        constructorTemplate: isOptional
            ? `this.${key}`
            : `required this.${key}`,
        fromJsonTemplate: `json["${jsonKey}"]`,
        toJsonTemplate: key,
        content: "",
    };
}

function dartScalarFromJtdScalar(
    nodePath: string,
    def: SchemaFormType,
    isOptional = false,
): DartProperty {
    const isNullable = isOptional || (def.nullable ?? false);
    const jsonKey = nodePath.split(".").pop() ?? "";
    const key = camelCase(jsonKey);
    const defaultInitializationTemplate = isOptional
        ? `this.${key}`
        : `required this.${key}`;
    const defaultToJsonTemplate = key;
    switch (def.type) {
        case "boolean":
            if (isNullable) {
                return {
                    typeName: "bool?",
                    fieldTemplate: `final bool? ${key}`,
                    constructorTemplate: defaultInitializationTemplate,
                    fromJsonTemplate: `nullableTypeFromDynamic<bool>(json["${jsonKey}"])`,
                    toJsonTemplate: defaultToJsonTemplate,
                    content: "",
                };
            }
            return {
                typeName: "bool",
                fieldTemplate: `final bool ${key}`,
                constructorTemplate: defaultInitializationTemplate,
                fromJsonTemplate: `typeFromDynamic<bool>(json["${jsonKey}"], false)`,
                toJsonTemplate: defaultToJsonTemplate,
                content: "",
            };
        case "float32":
        case "float64":
            if (isNullable) {
                return {
                    typeName: "double?",
                    fieldTemplate: `final double? ${key}`,
                    constructorTemplate: defaultInitializationTemplate,
                    fromJsonTemplate: `nullableDoubleFromDynamic(json["${jsonKey}"])`,
                    toJsonTemplate: defaultToJsonTemplate,
                    content: "",
                };
            }
            return {
                typeName: "double",
                fieldTemplate: `final double ${key}`,
                constructorTemplate: defaultInitializationTemplate,
                fromJsonTemplate: `doubleFromDynamic(json["${jsonKey}"], 0)`,
                toJsonTemplate: defaultToJsonTemplate,
                content: "",
            };
        case "int16":
        case "int32":
        case "int8":
        case "uint16":
        case "uint32":
        case "uint8":
            if (isNullable) {
                return {
                    typeName: "int?",
                    fieldTemplate: `final int? ${key}`,
                    constructorTemplate: defaultInitializationTemplate,
                    fromJsonTemplate: `nullableIntFromDynamic(json["${jsonKey}"])`,
                    toJsonTemplate: defaultToJsonTemplate,
                    content: "",
                };
            }
            return {
                typeName: "int",
                fieldTemplate: `final int ${key}`,
                constructorTemplate: defaultInitializationTemplate,
                fromJsonTemplate: `intFromDynamic(json["${jsonKey}"], 0)`,
                toJsonTemplate: defaultToJsonTemplate,
                content: "",
            };
        case "timestamp":
            if (isNullable) {
                return {
                    typeName: "DateTime?",
                    fieldTemplate: `final DateTime? ${key}`,
                    constructorTemplate: defaultInitializationTemplate,
                    fromJsonTemplate: `nullableDateTimeFromDynamic(json["${jsonKey}"])`,
                    toJsonTemplate: `${key}?.toUtc().toIso8601String()`,
                    content: "",
                };
            }
            return {
                typeName: "DateTime",
                fieldTemplate: `final DateTime ${key}`,
                constructorTemplate: defaultInitializationTemplate,
                fromJsonTemplate: `dateTimeFromDynamic(json["${jsonKey}"], DateTime.fromMillisecondsSinceEpoch(0))`,
                toJsonTemplate: `${key}.toUtc().toIso8601String()`,
                content: "",
            };
        case "string":
            if (isNullable) {
                return {
                    typeName: "String?",
                    fieldTemplate: `final String? ${key}`,
                    constructorTemplate: defaultInitializationTemplate,
                    fromJsonTemplate: `nullableTypeFromDynamic<String>(json["${jsonKey}"])`,
                    toJsonTemplate: defaultToJsonTemplate,
                    content: "",
                };
            }
            return {
                typeName: "String",
                fieldTemplate: `final String ${key}`,
                constructorTemplate: defaultInitializationTemplate,
                fromJsonTemplate: `typeFromDynamic<String>(json["${jsonKey}"], "")`,
                toJsonTemplate: defaultToJsonTemplate,
                content: "",
            };
        default:
            return {
                typeName: "dynamic",
                fieldTemplate: `final dynamic ${key}`,
                constructorTemplate: defaultInitializationTemplate,
                fromJsonTemplate: `json["${jsonKey}"]`,
                toJsonTemplate: defaultToJsonTemplate,
                content: "",
            };
    }
}
