// this file was autogenerated by arri
// ignore_for_file: type=lint
import "dart:convert";
import "package:arri_client/arri_client.dart";
import "package:http/http.dart" as http;

class TestClient {
  final http.Client? _httpClient;
  final String _baseUrl;
  late final Map<String, String> _headers;
  TestClient({
    http.Client? httpClient,
    String baseUrl = "",
    Map<String, String> headers = const {},
  })  : _httpClient = httpClient,
        _baseUrl = baseUrl {
    _headers = {"client-version": "10", ...headers};
  }

  TestClientAdaptersService get adapters {
    return TestClientAdaptersService(
      httpClient: _httpClient,
      baseUrl: _baseUrl,
      headers: _headers,
    );
  }

  TestClientMiscTestsService get miscTests {
    return TestClientMiscTestsService(
      httpClient: _httpClient,
      baseUrl: _baseUrl,
      headers: _headers,
    );
  }

  TestClientPostsService get posts {
    return TestClientPostsService(
      httpClient: _httpClient,
      baseUrl: _baseUrl,
      headers: _headers,
    );
  }

  TestClientVideosService get videos {
    return TestClientVideosService(
      httpClient: _httpClient,
      baseUrl: _baseUrl,
      headers: _headers,
    );
  }
}

class TestClientAdaptersService {
  final http.Client? _httpClient;
  final String _baseUrl;
  late final Map<String, String> _headers;
  TestClientAdaptersService({
    http.Client? httpClient,
    String baseUrl = "",
    Map<String, String> headers = const {},
  })  : _httpClient = httpClient,
        _baseUrl = baseUrl {
    _headers = {"client-version": "10", ...headers};
  }

  Future<AdaptersTypeboxAdapterResponse> typeboxAdapter(
      AdaptersTypeboxAdapterParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/adapters/typebox-adapter",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => AdaptersTypeboxAdapterResponse.fromJson(
        json.decode(body),
      ),
    );
  }
}

class TestClientMiscTestsService {
  final http.Client? _httpClient;
  final String _baseUrl;
  late final Map<String, String> _headers;
  TestClientMiscTestsService({
    http.Client? httpClient,
    String baseUrl = "",
    Map<String, String> headers = const {},
  })  : _httpClient = httpClient,
        _baseUrl = baseUrl {
    _headers = {"client-version": "10", ...headers};
  }

  /// This RPC is no longer supported
  @deprecated
  Future<void> deprecatedRpc(DeprecatedRpcParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/misc-tests/deprecated-rpc",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) {},
    );
  }

  Future<ObjectWithEveryType> sendObject(ObjectWithEveryType params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/misc-tests/send-object",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => ObjectWithEveryType.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<ObjectWithEveryNullableType> sendObjectWithNullableFields(
      ObjectWithEveryNullableType params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/misc-tests/send-object-with-nullable-fields",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => ObjectWithEveryNullableType.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<ObjectWithEveryOptionalType> sendPartialObject(
      ObjectWithEveryOptionalType params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/misc-tests/send-partial-object",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => ObjectWithEveryOptionalType.fromJson(
        json.decode(body),
      ),
    );
  }

  EventSource<AutoReconnectResponse> streamAutoReconnect(
    AutoReconnectParams params, {
    SseHookOnData<AutoReconnectResponse>? onData,
    SseHookOnError<AutoReconnectResponse>? onError,
    SseHookOnConnectionError<AutoReconnectResponse>? onConnectionError,
    SseHookOnOpen<AutoReconnectResponse>? onOpen,
    SseHookOnClose<AutoReconnectResponse>? onClose,
    String? lastEventId,
  }) {
    return parsedArriSseRequest<AutoReconnectResponse>(
      "$_baseUrl/rpcs/misc-tests/stream-auto-reconnect",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => AutoReconnectResponse.fromJson(
        json.decode(body),
      ),
      onData: onData,
      onError: onError,
      onConnectionError: onConnectionError,
      onOpen: onOpen,
      onClose: onClose,
      lastEventId: lastEventId,
    );
  }

  EventSource<StreamConnectionErrorTestResponse> streamConnectionErrorTest(
    StreamConnectionErrorTestParams params, {
    SseHookOnData<StreamConnectionErrorTestResponse>? onData,
    SseHookOnError<StreamConnectionErrorTestResponse>? onError,
    SseHookOnConnectionError<StreamConnectionErrorTestResponse>?
        onConnectionError,
    SseHookOnOpen<StreamConnectionErrorTestResponse>? onOpen,
    SseHookOnClose<StreamConnectionErrorTestResponse>? onClose,
    String? lastEventId,
  }) {
    return parsedArriSseRequest<StreamConnectionErrorTestResponse>(
      "$_baseUrl/rpcs/misc-tests/stream-connection-error-test",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => StreamConnectionErrorTestResponse.fromJson(
        json.decode(body),
      ),
      onData: onData,
      onError: onError,
      onConnectionError: onConnectionError,
      onOpen: onOpen,
      onClose: onClose,
      lastEventId: lastEventId,
    );
  }

  EventSource<StreamLargeObjectsResponse> streamLargeObjects({
    SseHookOnData<StreamLargeObjectsResponse>? onData,
    SseHookOnError<StreamLargeObjectsResponse>? onError,
    SseHookOnConnectionError<StreamLargeObjectsResponse>? onConnectionError,
    SseHookOnOpen<StreamLargeObjectsResponse>? onOpen,
    SseHookOnClose<StreamLargeObjectsResponse>? onClose,
    String? lastEventId,
  }) {
    return parsedArriSseRequest<StreamLargeObjectsResponse>(
      "$_baseUrl/rpcs/misc-tests/stream-large-objects",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: null,
      parser: (body) => StreamLargeObjectsResponse.fromJson(
        json.decode(body),
      ),
      onData: onData,
      onError: onError,
      onConnectionError: onConnectionError,
      onOpen: onOpen,
      onClose: onClose,
      lastEventId: lastEventId,
    );
  }

  EventSource<ChatMessage> streamMessages(
    ChatMessageParams params, {
    SseHookOnData<ChatMessage>? onData,
    SseHookOnError<ChatMessage>? onError,
    SseHookOnConnectionError<ChatMessage>? onConnectionError,
    SseHookOnOpen<ChatMessage>? onOpen,
    SseHookOnClose<ChatMessage>? onClose,
    String? lastEventId,
  }) {
    return parsedArriSseRequest<ChatMessage>(
      "$_baseUrl/rpcs/misc-tests/stream-messages",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => ChatMessage.fromJson(
        json.decode(body),
      ),
      onData: onData,
      onError: onError,
      onConnectionError: onConnectionError,
      onOpen: onOpen,
      onClose: onClose,
      lastEventId: lastEventId,
    );
  }

  EventSource<ChatMessage> streamTenEventsThenEnd({
    SseHookOnData<ChatMessage>? onData,
    SseHookOnError<ChatMessage>? onError,
    SseHookOnConnectionError<ChatMessage>? onConnectionError,
    SseHookOnOpen<ChatMessage>? onOpen,
    SseHookOnClose<ChatMessage>? onClose,
    String? lastEventId,
  }) {
    return parsedArriSseRequest<ChatMessage>(
      "$_baseUrl/rpcs/misc-tests/stream-ten-events-then-end",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: null,
      parser: (body) => ChatMessage.fromJson(
        json.decode(body),
      ),
      onData: onData,
      onError: onError,
      onConnectionError: onConnectionError,
      onOpen: onOpen,
      onClose: onClose,
      lastEventId: lastEventId,
    );
  }

  EventSource<ChatMessage> streamTenEventsThenError({
    SseHookOnData<ChatMessage>? onData,
    SseHookOnError<ChatMessage>? onError,
    SseHookOnConnectionError<ChatMessage>? onConnectionError,
    SseHookOnOpen<ChatMessage>? onOpen,
    SseHookOnClose<ChatMessage>? onClose,
    String? lastEventId,
  }) {
    return parsedArriSseRequest<ChatMessage>(
      "$_baseUrl/rpcs/misc-tests/stream-ten-events-then-error",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: null,
      parser: (body) => ChatMessage.fromJson(
        json.decode(body),
      ),
      onData: onData,
      onError: onError,
      onConnectionError: onConnectionError,
      onOpen: onOpen,
      onClose: onClose,
      lastEventId: lastEventId,
    );
  }
}

class TestClientPostsService {
  final http.Client? _httpClient;
  final String _baseUrl;
  late final Map<String, String> _headers;
  TestClientPostsService({
    http.Client? httpClient,
    String baseUrl = "",
    Map<String, String> headers = const {},
  })  : _httpClient = httpClient,
        _baseUrl = baseUrl {
    _headers = {"client-version": "10", ...headers};
  }

  Future<Post> getPost(PostParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/posts/get-post",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => Post.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<PostListResponse> getPosts(PostListParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/posts/get-posts",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => PostListResponse.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<LogPostEventResponse> logEvent(PostEvent params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/posts/log-event",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => LogPostEventResponse.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<Post> updatePost(UpdatePostParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/posts/update-post",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => Post.fromJson(
        json.decode(body),
      ),
    );
  }
}

class TestClientVideosService {
  final http.Client? _httpClient;
  final String _baseUrl;
  late final Map<String, String> _headers;
  TestClientVideosService({
    http.Client? httpClient,
    String baseUrl = "",
    Map<String, String> headers = const {},
  })  : _httpClient = httpClient,
        _baseUrl = baseUrl {
    _headers = {"client-version": "10", ...headers};
  }

  Future<Annotation> getAnnotation(AnnotationId params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/videos/get-annotation",
      httpClient: _httpClient,
      method: HttpMethod.get,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => Annotation.fromJson(
        json.decode(body),
      ),
    );
  }

  Future<Annotation> updateAnnotation(UpdateAnnotationParams params) {
    return parsedArriRequest(
      "$_baseUrl/rpcs/videos/update-annotation",
      httpClient: _httpClient,
      method: HttpMethod.post,
      headers: _headers,
      params: params.toJson(),
      parser: (body) => Annotation.fromJson(
        json.decode(body),
      ),
    );
  }
}

class ManuallyAddedModel {
  final String hello;
  const ManuallyAddedModel({
    required this.hello,
  });
  factory ManuallyAddedModel.fromJson(Map<String, dynamic> json) {
    return ManuallyAddedModel(
      hello: typeFromDynamic<String>(json["hello"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "hello": hello,
    };

    return __result;
  }

  ManuallyAddedModel copyWith({
    String? hello,
  }) {
    return ManuallyAddedModel(
      hello: hello ?? this.hello,
    );
  }
}

class AdaptersTypeboxAdapterParams {
  final String string;
  final bool boolean;
  final int integer;
  final double number;
  final AdaptersTypeboxAdapterParamsEnumField enumField;
  final AdaptersTypeboxAdapterParamsObject object;
  final List<bool> array;
  final String? optionalString;
  const AdaptersTypeboxAdapterParams({
    required this.string,
    required this.boolean,
    required this.integer,
    required this.number,
    required this.enumField,
    required this.object,
    required this.array,
    this.optionalString,
  });
  factory AdaptersTypeboxAdapterParams.fromJson(Map<String, dynamic> json) {
    return AdaptersTypeboxAdapterParams(
      string: typeFromDynamic<String>(json["string"], ""),
      boolean: typeFromDynamic<bool>(json["boolean"], false),
      integer: intFromDynamic(json["integer"], 0),
      number: doubleFromDynamic(json["number"], 0),
      enumField:
          AdaptersTypeboxAdapterParamsEnumField.fromJson(json["enumField"]),
      object: AdaptersTypeboxAdapterParamsObject.fromJson(json["object"]),
      array: json["array"] is List
          ?
          // ignore: unnecessary_cast
          (json["array"] as List)
              .map((item) => typeFromDynamic<bool>(item, false))
              .toList() as List<bool>
          : <bool>[],
      optionalString: nullableTypeFromDynamic<String>(json["optionalString"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "integer": integer,
      "number": number,
      "enumField": enumField.value,
      "object": object.toJson(),
      "array": array.map((item) => item).toList(),
    };
    if (optionalString != null) {
      __result["optionalString"] = optionalString;
    }
    return __result;
  }

  AdaptersTypeboxAdapterParams copyWith({
    String? string,
    bool? boolean,
    int? integer,
    double? number,
    AdaptersTypeboxAdapterParamsEnumField? enumField,
    AdaptersTypeboxAdapterParamsObject? object,
    List<bool>? array,
    String? optionalString,
  }) {
    return AdaptersTypeboxAdapterParams(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      integer: integer ?? this.integer,
      number: number ?? this.number,
      enumField: enumField ?? this.enumField,
      object: object ?? this.object,
      array: array ?? this.array,
      optionalString: optionalString ?? this.optionalString,
    );
  }
}

enum AdaptersTypeboxAdapterParamsEnumField
    implements Comparable<AdaptersTypeboxAdapterParamsEnumField> {
  a("A"),
  b("B"),
  c("C");

  const AdaptersTypeboxAdapterParamsEnumField(this.value);
  final String value;

  factory AdaptersTypeboxAdapterParamsEnumField.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return a;
  }

  @override
  compareTo(AdaptersTypeboxAdapterParamsEnumField other) =>
      name.compareTo(other.name);
}

class AdaptersTypeboxAdapterParamsObject {
  final String string;
  const AdaptersTypeboxAdapterParamsObject({
    required this.string,
  });
  factory AdaptersTypeboxAdapterParamsObject.fromJson(
      Map<String, dynamic> json) {
    return AdaptersTypeboxAdapterParamsObject(
      string: typeFromDynamic<String>(json["string"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "string": string,
    };

    return __result;
  }

  AdaptersTypeboxAdapterParamsObject copyWith({
    String? string,
  }) {
    return AdaptersTypeboxAdapterParamsObject(
      string: string ?? this.string,
    );
  }
}

class AdaptersTypeboxAdapterResponse {
  final String message;
  const AdaptersTypeboxAdapterResponse({
    required this.message,
  });
  factory AdaptersTypeboxAdapterResponse.fromJson(Map<String, dynamic> json) {
    return AdaptersTypeboxAdapterResponse(
      message: typeFromDynamic<String>(json["message"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "message": message,
    };

    return __result;
  }

  AdaptersTypeboxAdapterResponse copyWith({
    String? message,
  }) {
    return AdaptersTypeboxAdapterResponse(
      message: message ?? this.message,
    );
  }
}

@deprecated
class DeprecatedRpcParams {
  @deprecated
  final String deprecatedField;
  const DeprecatedRpcParams({
    required this.deprecatedField,
  });
  factory DeprecatedRpcParams.fromJson(Map<String, dynamic> json) {
    return DeprecatedRpcParams(
      deprecatedField: typeFromDynamic<String>(json["deprecatedField"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "deprecatedField": deprecatedField,
    };

    return __result;
  }

  DeprecatedRpcParams copyWith({
    String? deprecatedField,
  }) {
    return DeprecatedRpcParams(
      deprecatedField: deprecatedField ?? this.deprecatedField,
    );
  }
}

class ObjectWithEveryType {
  final dynamic any;
  final bool boolean;
  final String string;
  final DateTime timestamp;
  final double float32;
  final double float64;
  final int int8;
  final int uint8;
  final int int16;
  final int uint16;
  final int int32;
  final int uint32;
  final BigInt int64;
  final BigInt uint64;
  final ObjectWithEveryTypeEnumerator enumerator;
  final List<bool> array;
  final ObjectWithEveryTypeObject object;
  final Map<String, bool> record;
  final ObjectWithEveryTypeDiscriminator discriminator;
  final ObjectWithEveryTypeNestedObject nestedObject;
  final List<List<ObjectWithEveryTypeNestedArrayItemItem>> nestedArray;
  const ObjectWithEveryType({
    required this.any,
    required this.boolean,
    required this.string,
    required this.timestamp,
    required this.float32,
    required this.float64,
    required this.int8,
    required this.uint8,
    required this.int16,
    required this.uint16,
    required this.int32,
    required this.uint32,
    required this.int64,
    required this.uint64,
    required this.enumerator,
    required this.array,
    required this.object,
    required this.record,
    required this.discriminator,
    required this.nestedObject,
    required this.nestedArray,
  });
  factory ObjectWithEveryType.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryType(
      any: json["any"],
      boolean: typeFromDynamic<bool>(json["boolean"], false),
      string: typeFromDynamic<String>(json["string"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      float32: doubleFromDynamic(json["float32"], 0),
      float64: doubleFromDynamic(json["float64"], 0),
      int8: intFromDynamic(json["int8"], 0),
      uint8: intFromDynamic(json["uint8"], 0),
      int16: intFromDynamic(json["int16"], 0),
      uint16: intFromDynamic(json["uint16"], 0),
      int32: intFromDynamic(json["int32"], 0),
      uint32: intFromDynamic(json["uint32"], 0),
      int64: bigIntFromDynamic(json["int64"], BigInt.zero),
      uint64: bigIntFromDynamic(json["uint64"], BigInt.zero),
      enumerator: ObjectWithEveryTypeEnumerator.fromJson(json["enumerator"]),
      array: json["array"] is List
          ?
          // ignore: unnecessary_cast
          (json["array"] as List)
              .map((item) => typeFromDynamic<bool>(item, false))
              .toList() as List<bool>
          : <bool>[],
      object: ObjectWithEveryTypeObject.fromJson(json["object"]),
      record: json["record"] is Map<String, dynamic>
          ? (json["record"] as Map<String, dynamic>).map((key, value) =>
              MapEntry(key, typeFromDynamic<bool>(value, false)))
          : <String, bool>{},
      discriminator:
          ObjectWithEveryTypeDiscriminator.fromJson(json["discriminator"]),
      nestedObject:
          ObjectWithEveryTypeNestedObject.fromJson(json["nestedObject"]),
      nestedArray: json["nestedArray"] is List
          ?
          // ignore: unnecessary_cast
          (json["nestedArray"] as List)
              .map((item) => item is List
                  ?
                  // ignore: unnecessary_cast
                  (item as List)
                      .map((item) =>
                          ObjectWithEveryTypeNestedArrayItemItem.fromJson(item))
                      .toList() as List<ObjectWithEveryTypeNestedArrayItemItem>
                  : <ObjectWithEveryTypeNestedArrayItemItem>[])
              .toList() as List<List<ObjectWithEveryTypeNestedArrayItemItem>>
          : <List<ObjectWithEveryTypeNestedArrayItemItem>>[],
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "any": any,
      "boolean": boolean,
      "string": string,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "float32": float32,
      "float64": float64,
      "int8": int8,
      "uint8": uint8,
      "int16": int16,
      "uint16": uint16,
      "int32": int32,
      "uint32": uint32,
      "int64": int64.toString(),
      "uint64": uint64.toString(),
      "enumerator": enumerator.value,
      "array": array.map((item) => item).toList(),
      "object": object.toJson(),
      "record": record.map((key, value) => MapEntry(key, value)),
      "discriminator": discriminator.toJson(),
      "nestedObject": nestedObject.toJson(),
      "nestedArray": nestedArray
          .map((item) => item.map((item) => item.toJson()).toList())
          .toList(),
    };

    return __result;
  }

  ObjectWithEveryType copyWith({
    dynamic any,
    bool? boolean,
    String? string,
    DateTime? timestamp,
    double? float32,
    double? float64,
    int? int8,
    int? uint8,
    int? int16,
    int? uint16,
    int? int32,
    int? uint32,
    BigInt? int64,
    BigInt? uint64,
    ObjectWithEveryTypeEnumerator? enumerator,
    List<bool>? array,
    ObjectWithEveryTypeObject? object,
    Map<String, bool>? record,
    ObjectWithEveryTypeDiscriminator? discriminator,
    ObjectWithEveryTypeNestedObject? nestedObject,
    List<List<ObjectWithEveryTypeNestedArrayItemItem>>? nestedArray,
  }) {
    return ObjectWithEveryType(
      any: any ?? this.any,
      boolean: boolean ?? this.boolean,
      string: string ?? this.string,
      timestamp: timestamp ?? this.timestamp,
      float32: float32 ?? this.float32,
      float64: float64 ?? this.float64,
      int8: int8 ?? this.int8,
      uint8: uint8 ?? this.uint8,
      int16: int16 ?? this.int16,
      uint16: uint16 ?? this.uint16,
      int32: int32 ?? this.int32,
      uint32: uint32 ?? this.uint32,
      int64: int64 ?? this.int64,
      uint64: uint64 ?? this.uint64,
      enumerator: enumerator ?? this.enumerator,
      array: array ?? this.array,
      object: object ?? this.object,
      record: record ?? this.record,
      discriminator: discriminator ?? this.discriminator,
      nestedObject: nestedObject ?? this.nestedObject,
      nestedArray: nestedArray ?? this.nestedArray,
    );
  }
}

enum ObjectWithEveryTypeEnumerator
    implements Comparable<ObjectWithEveryTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryTypeEnumerator(this.value);
  final String value;

  factory ObjectWithEveryTypeEnumerator.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return a;
  }

  @override
  compareTo(ObjectWithEveryTypeEnumerator other) => name.compareTo(other.name);
}

class ObjectWithEveryTypeObject {
  final String string;
  final bool boolean;
  final DateTime timestamp;
  const ObjectWithEveryTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });
  factory ObjectWithEveryTypeObject.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryTypeObject(
      string: typeFromDynamic<String>(json["string"], ""),
      boolean: typeFromDynamic<bool>(json["boolean"], false),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

sealed class ObjectWithEveryTypeDiscriminator {
  final String type;
  const ObjectWithEveryTypeDiscriminator({
    required this.type,
  });
  factory ObjectWithEveryTypeDiscriminator.fromJson(Map<String, dynamic> json) {
    if (json["type"] is! String) {
      throw Exception(
        "Unable to decode ObjectWithEveryTypeDiscriminator. Expected String from \"type\". Received ${json["type"]}}",
      );
    }
    switch (json["type"]) {
      case "A":
        return ObjectWithEveryTypeDiscriminatorA.fromJson(json);
      case "B":
        return ObjectWithEveryTypeDiscriminatorB.fromJson(json);
    }
    throw Exception(
      "Unable to decode ObjectWithEveryTypeDiscriminator. \"${json["type"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class ObjectWithEveryTypeDiscriminatorA
    implements ObjectWithEveryTypeDiscriminator {
  @override
  final String type = "A";
  final String title;
  const ObjectWithEveryTypeDiscriminatorA({
    required this.title,
  });
  factory ObjectWithEveryTypeDiscriminatorA.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeDiscriminatorA(
      title: typeFromDynamic<String>(json["title"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return __result;
  }

  ObjectWithEveryTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return ObjectWithEveryTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }
}

class ObjectWithEveryTypeDiscriminatorB
    implements ObjectWithEveryTypeDiscriminator {
  @override
  final String type = "B";
  final String title;
  final String description;
  const ObjectWithEveryTypeDiscriminatorB({
    required this.title,
    required this.description,
  });
  factory ObjectWithEveryTypeDiscriminatorB.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeDiscriminatorB(
      title: typeFromDynamic<String>(json["title"], ""),
      description: typeFromDynamic<String>(json["description"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return __result;
  }

  ObjectWithEveryTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return ObjectWithEveryTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }
}

class ObjectWithEveryTypeNestedObject {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryTypeNestedObjectData data;
  const ObjectWithEveryTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryTypeNestedObject.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryTypeNestedObject(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      data: ObjectWithEveryTypeNestedObjectData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return __result;
  }

  ObjectWithEveryTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryTypeNestedObjectData? data,
  }) {
    return ObjectWithEveryTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryTypeNestedObjectData {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryTypeNestedObjectDataData data;
  const ObjectWithEveryTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryTypeNestedObjectData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeNestedObjectData(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      data: ObjectWithEveryTypeNestedObjectDataData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return __result;
  }

  ObjectWithEveryTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryTypeNestedObjectDataData? data,
  }) {
    return ObjectWithEveryTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryTypeNestedObjectDataData {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeNestedObjectDataData(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class ObjectWithEveryTypeNestedArrayItemItem {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryTypeNestedArrayItemItem({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryTypeNestedArrayItemItem.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryTypeNestedArrayItemItem(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryTypeNestedArrayItemItem copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeNestedArrayItemItem(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class ObjectWithEveryNullableType {
  final dynamic any;
  final bool? boolean;
  final String? string;
  final DateTime? timestamp;
  final double? float32;
  final double? float64;
  final int? int8;
  final int? uint8;
  final int? int16;
  final int? uint16;
  final int? int32;
  final int? uint32;
  final BigInt? int64;
  final BigInt? uint64;
  final ObjectWithEveryNullableTypeEnumerator? enumerator;
  final List<bool?>? array;
  final ObjectWithEveryNullableTypeObject? object;
  final Map<String, bool?>? record;
  final ObjectWithEveryNullableTypeDiscriminator? discriminator;
  final ObjectWithEveryNullableTypeNestedObject? nestedObject;
  final List<List<ObjectWithEveryNullableTypeNestedArrayItemItem?>?>?
      nestedArray;
  const ObjectWithEveryNullableType({
    required this.any,
    required this.boolean,
    required this.string,
    required this.timestamp,
    required this.float32,
    required this.float64,
    required this.int8,
    required this.uint8,
    required this.int16,
    required this.uint16,
    required this.int32,
    required this.uint32,
    required this.int64,
    required this.uint64,
    required this.enumerator,
    required this.array,
    required this.object,
    required this.record,
    required this.discriminator,
    required this.nestedObject,
    required this.nestedArray,
  });
  factory ObjectWithEveryNullableType.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryNullableType(
      any: json["any"],
      boolean: nullableTypeFromDynamic<bool>(json["boolean"]),
      string: nullableTypeFromDynamic<String>(json["string"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
      float32: nullableDoubleFromDynamic(json["float32"]),
      float64: nullableDoubleFromDynamic(json["float64"]),
      int8: nullableIntFromDynamic(json["int8"]),
      uint8: nullableIntFromDynamic(json["uint8"]),
      int16: nullableIntFromDynamic(json["int16"]),
      uint16: nullableIntFromDynamic(json["uint16"]),
      int32: nullableIntFromDynamic(json["int32"]),
      uint32: nullableIntFromDynamic(json["uint32"]),
      int64: nullableBigIntFromDynamic(json["int64"]),
      uint64: nullableBigIntFromDynamic(json["uint64"]),
      enumerator: json["enumerator"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeEnumerator.fromJson(json["enumerator"])
          : null,
      array: json["array"] is List
          ?
          // ignore: unnecessary_cast
          (json["array"] as List)
              .map((item) => nullableTypeFromDynamic<bool>(item))
              .toList() as List<bool?>?
          : null,
      object: json["object"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeObject.fromJson(json["object"])
          : null,
      record: json["record"] is Map<String, dynamic>
          ? (json["record"] as Map<String, dynamic>).map((key, value) =>
              MapEntry(key, nullableTypeFromDynamic<bool>(value)))
          : <String, bool?>{},
      discriminator: json["discriminator"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeDiscriminator.fromJson(
              json["discriminator"])
          : null,
      nestedObject: json["nestedObject"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeNestedObject.fromJson(
              json["nestedObject"])
          : null,
      nestedArray: json["nestedArray"] is List
          ?
          // ignore: unnecessary_cast
          (json["nestedArray"] as List)
                  .map((item) => item is List
                      ?
                      // ignore: unnecessary_cast
                      (item as List)
                              .map((item) => item is Map<String, dynamic>
                                  ? ObjectWithEveryNullableTypeNestedArrayItemItem
                                      .fromJson(item)
                                  : null)
                              .toList()
                          as List<ObjectWithEveryNullableTypeNestedArrayItemItem?>?
                      : null)
                  .toList()
              as List<List<ObjectWithEveryNullableTypeNestedArrayItemItem?>?>?
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "any": any,
      "boolean": boolean,
      "string": string,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "float32": float32,
      "float64": float64,
      "int8": int8,
      "uint8": uint8,
      "int16": int16,
      "uint16": uint16,
      "int32": int32,
      "uint32": uint32,
      "int64": int64?.toString(),
      "uint64": uint64?.toString(),
      "enumerator": enumerator?.value,
      "array": array?.map((item) => item).toList(),
      "object": object?.toJson(),
      "record": record?.map((key, value) => MapEntry(key, value)),
      "discriminator": discriminator?.toJson(),
      "nestedObject": nestedObject?.toJson(),
      "nestedArray": nestedArray
          ?.map((item) => item?.map((item) => item?.toJson()).toList())
          .toList(),
    };

    return __result;
  }

  ObjectWithEveryNullableType copyWith({
    dynamic any,
    bool? boolean,
    String? string,
    DateTime? timestamp,
    double? float32,
    double? float64,
    int? int8,
    int? uint8,
    int? int16,
    int? uint16,
    int? int32,
    int? uint32,
    BigInt? int64,
    BigInt? uint64,
    ObjectWithEveryNullableTypeEnumerator? enumerator,
    List<bool?>? array,
    ObjectWithEveryNullableTypeObject? object,
    Map<String, bool?>? record,
    ObjectWithEveryNullableTypeDiscriminator? discriminator,
    ObjectWithEveryNullableTypeNestedObject? nestedObject,
    List<List<ObjectWithEveryNullableTypeNestedArrayItemItem?>?>? nestedArray,
  }) {
    return ObjectWithEveryNullableType(
      any: any ?? this.any,
      boolean: boolean ?? this.boolean,
      string: string ?? this.string,
      timestamp: timestamp ?? this.timestamp,
      float32: float32 ?? this.float32,
      float64: float64 ?? this.float64,
      int8: int8 ?? this.int8,
      uint8: uint8 ?? this.uint8,
      int16: int16 ?? this.int16,
      uint16: uint16 ?? this.uint16,
      int32: int32 ?? this.int32,
      uint32: uint32 ?? this.uint32,
      int64: int64 ?? this.int64,
      uint64: uint64 ?? this.uint64,
      enumerator: enumerator ?? this.enumerator,
      array: array ?? this.array,
      object: object ?? this.object,
      record: record ?? this.record,
      discriminator: discriminator ?? this.discriminator,
      nestedObject: nestedObject ?? this.nestedObject,
      nestedArray: nestedArray ?? this.nestedArray,
    );
  }
}

enum ObjectWithEveryNullableTypeEnumerator
    implements Comparable<ObjectWithEveryNullableTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryNullableTypeEnumerator(this.value);
  final String value;

  factory ObjectWithEveryNullableTypeEnumerator.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return a;
  }

  @override
  compareTo(ObjectWithEveryNullableTypeEnumerator other) =>
      name.compareTo(other.name);
}

class ObjectWithEveryNullableTypeObject {
  final String? string;
  final bool? boolean;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });
  factory ObjectWithEveryNullableTypeObject.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeObject(
      string: nullableTypeFromDynamic<String>(json["string"]),
      boolean: nullableTypeFromDynamic<bool>(json["boolean"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryNullableTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryNullableTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

sealed class ObjectWithEveryNullableTypeDiscriminator {
  final String type;
  const ObjectWithEveryNullableTypeDiscriminator({
    required this.type,
  });
  factory ObjectWithEveryNullableTypeDiscriminator.fromJson(
      Map<String, dynamic> json) {
    if (json["type"] is! String) {
      throw Exception(
        "Unable to decode ObjectWithEveryNullableTypeDiscriminator. Expected String from \"type\". Received ${json["type"]}}",
      );
    }
    switch (json["type"]) {
      case "A":
        return ObjectWithEveryNullableTypeDiscriminatorA.fromJson(json);
      case "B":
        return ObjectWithEveryNullableTypeDiscriminatorB.fromJson(json);
    }
    throw Exception(
      "Unable to decode ObjectWithEveryNullableTypeDiscriminator. \"${json["type"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class ObjectWithEveryNullableTypeDiscriminatorA
    implements ObjectWithEveryNullableTypeDiscriminator {
  @override
  final String type = "A";
  final String? title;
  const ObjectWithEveryNullableTypeDiscriminatorA({
    required this.title,
  });
  factory ObjectWithEveryNullableTypeDiscriminatorA.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeDiscriminatorA(
      title: nullableTypeFromDynamic<String>(json["title"]),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return __result;
  }

  ObjectWithEveryNullableTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return ObjectWithEveryNullableTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }
}

class ObjectWithEveryNullableTypeDiscriminatorB
    implements ObjectWithEveryNullableTypeDiscriminator {
  @override
  final String type = "B";
  final String? title;
  final String? description;
  const ObjectWithEveryNullableTypeDiscriminatorB({
    required this.title,
    required this.description,
  });
  factory ObjectWithEveryNullableTypeDiscriminatorB.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeDiscriminatorB(
      title: nullableTypeFromDynamic<String>(json["title"]),
      description: nullableTypeFromDynamic<String>(json["description"]),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return __result;
  }

  ObjectWithEveryNullableTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return ObjectWithEveryNullableTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }
}

class ObjectWithEveryNullableTypeNestedObject {
  final String? id;
  final DateTime? timestamp;
  final ObjectWithEveryNullableTypeNestedObjectData? data;
  const ObjectWithEveryNullableTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryNullableTypeNestedObject.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeNestedObject(
      id: nullableTypeFromDynamic<String>(json["id"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
      data: json["data"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeNestedObjectData.fromJson(json["data"])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "data": data?.toJson(),
    };

    return __result;
  }

  ObjectWithEveryNullableTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryNullableTypeNestedObjectData? data,
  }) {
    return ObjectWithEveryNullableTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryNullableTypeNestedObjectData {
  final String? id;
  final DateTime? timestamp;
  final ObjectWithEveryNullableTypeNestedObjectDataData? data;
  const ObjectWithEveryNullableTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryNullableTypeNestedObjectData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeNestedObjectData(
      id: nullableTypeFromDynamic<String>(json["id"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
      data: json["data"] is Map<String, dynamic>
          ? ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
              json["data"])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "data": data?.toJson(),
    };

    return __result;
  }

  ObjectWithEveryNullableTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryNullableTypeNestedObjectDataData? data,
  }) {
    return ObjectWithEveryNullableTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryNullableTypeNestedObjectDataData {
  final String? id;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeNestedObjectDataData(
      id: nullableTypeFromDynamic<String>(json["id"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryNullableTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryNullableTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class ObjectWithEveryNullableTypeNestedArrayItemItem {
  final String? id;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeNestedArrayItemItem({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryNullableTypeNestedArrayItemItem.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryNullableTypeNestedArrayItemItem(
      id: nullableTypeFromDynamic<String>(json["id"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryNullableTypeNestedArrayItemItem copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryNullableTypeNestedArrayItemItem(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class ObjectWithEveryOptionalType {
  final dynamic any;
  final bool? boolean;
  final String? string;
  final DateTime? timestamp;
  final double? float32;
  final double? float64;
  final int? int8;
  final int? uint8;
  final int? int16;
  final int? uint16;
  final int? int32;
  final int? uint32;
  final BigInt? int64;
  final BigInt? uint64;
  final ObjectWithEveryOptionalTypeEnumerator? enumerator;
  final List<bool>? array;
  final ObjectWithEveryOptionalTypeObject? object;
  final Map<String, bool>? record;
  final ObjectWithEveryOptionalTypeDiscriminator? discriminator;
  final ObjectWithEveryOptionalTypeNestedObject? nestedObject;
  final List<List<ObjectWithEveryOptionalTypeNestedArrayItemItem>>? nestedArray;
  const ObjectWithEveryOptionalType({
    this.any,
    this.boolean,
    this.string,
    this.timestamp,
    this.float32,
    this.float64,
    this.int8,
    this.uint8,
    this.int16,
    this.uint16,
    this.int32,
    this.uint32,
    this.int64,
    this.uint64,
    this.enumerator,
    this.array,
    this.object,
    this.record,
    this.discriminator,
    this.nestedObject,
    this.nestedArray,
  });
  factory ObjectWithEveryOptionalType.fromJson(Map<String, dynamic> json) {
    return ObjectWithEveryOptionalType(
      any: json["any"],
      boolean: nullableTypeFromDynamic<bool>(json["boolean"]),
      string: nullableTypeFromDynamic<String>(json["string"]),
      timestamp: nullableDateTimeFromDynamic(json["timestamp"]),
      float32: nullableDoubleFromDynamic(json["float32"]),
      float64: nullableDoubleFromDynamic(json["float64"]),
      int8: nullableIntFromDynamic(json["int8"]),
      uint8: nullableIntFromDynamic(json["uint8"]),
      int16: nullableIntFromDynamic(json["int16"]),
      uint16: nullableIntFromDynamic(json["uint16"]),
      int32: nullableIntFromDynamic(json["int32"]),
      uint32: nullableIntFromDynamic(json["uint32"]),
      int64: nullableBigIntFromDynamic(json["int64"]),
      uint64: nullableBigIntFromDynamic(json["uint64"]),
      enumerator: json["enumerator"] is Map<String, dynamic>
          ? ObjectWithEveryOptionalTypeEnumerator.fromJson(json["enumerator"])
          : null,
      array: json["array"] is List
          ?
          // ignore: unnecessary_cast
          (json["array"] as List)
              .map((item) => typeFromDynamic<bool>(item, false))
              .toList() as List<bool>?
          : null,
      object: json["object"] is Map<String, dynamic>
          ? ObjectWithEveryOptionalTypeObject.fromJson(json["object"])
          : null,
      record: json["record"] is Map<String, dynamic>
          ? (json["record"] as Map<String, dynamic>).map((key, value) =>
              MapEntry(key, typeFromDynamic<bool>(value, false)))
          : <String, bool>{},
      discriminator: json["discriminator"] is Map<String, dynamic>
          ? ObjectWithEveryOptionalTypeDiscriminator.fromJson(
              json["discriminator"])
          : null,
      nestedObject: json["nestedObject"] is Map<String, dynamic>
          ? ObjectWithEveryOptionalTypeNestedObject.fromJson(
              json["nestedObject"])
          : null,
      nestedArray: json["nestedArray"] is List
          ?
          // ignore: unnecessary_cast
          (json["nestedArray"] as List)
                  .map((item) => item is List
                      ?
                      // ignore: unnecessary_cast
                      (item as List)
                              .map((item) =>
                                  ObjectWithEveryOptionalTypeNestedArrayItemItem
                                      .fromJson(item))
                              .toList()
                          as List<ObjectWithEveryOptionalTypeNestedArrayItemItem>
                      : <ObjectWithEveryOptionalTypeNestedArrayItemItem>[])
                  .toList()
              as List<List<ObjectWithEveryOptionalTypeNestedArrayItemItem>>?
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{};
    if (any != null) {
      __result["any"] = any;
    }
    if (boolean != null) {
      __result["boolean"] = boolean;
    }
    if (string != null) {
      __result["string"] = string;
    }
    if (timestamp != null) {
      __result["timestamp"] = timestamp?.toUtc().toIso8601String();
    }
    if (float32 != null) {
      __result["float32"] = float32;
    }
    if (float64 != null) {
      __result["float64"] = float64;
    }
    if (int8 != null) {
      __result["int8"] = int8;
    }
    if (uint8 != null) {
      __result["uint8"] = uint8;
    }
    if (int16 != null) {
      __result["int16"] = int16;
    }
    if (uint16 != null) {
      __result["uint16"] = uint16;
    }
    if (int32 != null) {
      __result["int32"] = int32;
    }
    if (uint32 != null) {
      __result["uint32"] = uint32;
    }
    if (int64 != null) {
      __result["int64"] = int64?.toString();
    }
    if (uint64 != null) {
      __result["uint64"] = uint64?.toString();
    }
    if (enumerator != null) {
      __result["enumerator"] = enumerator?.value;
    }
    if (array != null) {
      __result["array"] = array?.map((item) => item).toList();
    }
    if (object != null) {
      __result["object"] = object?.toJson();
    }
    if (record != null) {
      __result["record"] = record?.map((key, value) => MapEntry(key, value));
    }
    if (discriminator != null) {
      __result["discriminator"] = discriminator?.toJson();
    }
    if (nestedObject != null) {
      __result["nestedObject"] = nestedObject?.toJson();
    }
    if (nestedArray != null) {
      __result["nestedArray"] = nestedArray
          ?.map((item) => item.map((item) => item.toJson()).toList())
          .toList();
    }
    return __result;
  }

  ObjectWithEveryOptionalType copyWith({
    dynamic any,
    bool? boolean,
    String? string,
    DateTime? timestamp,
    double? float32,
    double? float64,
    int? int8,
    int? uint8,
    int? int16,
    int? uint16,
    int? int32,
    int? uint32,
    BigInt? int64,
    BigInt? uint64,
    ObjectWithEveryOptionalTypeEnumerator? enumerator,
    List<bool>? array,
    ObjectWithEveryOptionalTypeObject? object,
    Map<String, bool>? record,
    ObjectWithEveryOptionalTypeDiscriminator? discriminator,
    ObjectWithEveryOptionalTypeNestedObject? nestedObject,
    List<List<ObjectWithEveryOptionalTypeNestedArrayItemItem>>? nestedArray,
  }) {
    return ObjectWithEveryOptionalType(
      any: any ?? this.any,
      boolean: boolean ?? this.boolean,
      string: string ?? this.string,
      timestamp: timestamp ?? this.timestamp,
      float32: float32 ?? this.float32,
      float64: float64 ?? this.float64,
      int8: int8 ?? this.int8,
      uint8: uint8 ?? this.uint8,
      int16: int16 ?? this.int16,
      uint16: uint16 ?? this.uint16,
      int32: int32 ?? this.int32,
      uint32: uint32 ?? this.uint32,
      int64: int64 ?? this.int64,
      uint64: uint64 ?? this.uint64,
      enumerator: enumerator ?? this.enumerator,
      array: array ?? this.array,
      object: object ?? this.object,
      record: record ?? this.record,
      discriminator: discriminator ?? this.discriminator,
      nestedObject: nestedObject ?? this.nestedObject,
      nestedArray: nestedArray ?? this.nestedArray,
    );
  }
}

enum ObjectWithEveryOptionalTypeEnumerator
    implements Comparable<ObjectWithEveryOptionalTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryOptionalTypeEnumerator(this.value);
  final String value;

  factory ObjectWithEveryOptionalTypeEnumerator.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return a;
  }

  @override
  compareTo(ObjectWithEveryOptionalTypeEnumerator other) =>
      name.compareTo(other.name);
}

class ObjectWithEveryOptionalTypeObject {
  final String string;
  final bool boolean;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });
  factory ObjectWithEveryOptionalTypeObject.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeObject(
      string: typeFromDynamic<String>(json["string"], ""),
      boolean: typeFromDynamic<bool>(json["boolean"], false),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryOptionalTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

sealed class ObjectWithEveryOptionalTypeDiscriminator {
  final String type;
  const ObjectWithEveryOptionalTypeDiscriminator({
    required this.type,
  });
  factory ObjectWithEveryOptionalTypeDiscriminator.fromJson(
      Map<String, dynamic> json) {
    if (json["type"] is! String) {
      throw Exception(
        "Unable to decode ObjectWithEveryOptionalTypeDiscriminator. Expected String from \"type\". Received ${json["type"]}}",
      );
    }
    switch (json["type"]) {
      case "A":
        return ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(json);
      case "B":
        return ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(json);
    }
    throw Exception(
      "Unable to decode ObjectWithEveryOptionalTypeDiscriminator. \"${json["type"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class ObjectWithEveryOptionalTypeDiscriminatorA
    implements ObjectWithEveryOptionalTypeDiscriminator {
  @override
  final String type = "A";
  final String title;
  const ObjectWithEveryOptionalTypeDiscriminatorA({
    required this.title,
  });
  factory ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeDiscriminatorA(
      title: typeFromDynamic<String>(json["title"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return __result;
  }

  ObjectWithEveryOptionalTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return ObjectWithEveryOptionalTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }
}

class ObjectWithEveryOptionalTypeDiscriminatorB
    implements ObjectWithEveryOptionalTypeDiscriminator {
  @override
  final String type = "B";
  final String title;
  final String description;
  const ObjectWithEveryOptionalTypeDiscriminatorB({
    required this.title,
    required this.description,
  });
  factory ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeDiscriminatorB(
      title: typeFromDynamic<String>(json["title"], ""),
      description: typeFromDynamic<String>(json["description"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return __result;
  }

  ObjectWithEveryOptionalTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return ObjectWithEveryOptionalTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }
}

class ObjectWithEveryOptionalTypeNestedObject {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryOptionalTypeNestedObjectData data;
  const ObjectWithEveryOptionalTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryOptionalTypeNestedObject.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeNestedObject(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      data: ObjectWithEveryOptionalTypeNestedObjectData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return __result;
  }

  ObjectWithEveryOptionalTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryOptionalTypeNestedObjectData? data,
  }) {
    return ObjectWithEveryOptionalTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryOptionalTypeNestedObjectData {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryOptionalTypeNestedObjectDataData data;
  const ObjectWithEveryOptionalTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });
  factory ObjectWithEveryOptionalTypeNestedObjectData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeNestedObjectData(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      data: ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
          json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return __result;
  }

  ObjectWithEveryOptionalTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryOptionalTypeNestedObjectDataData? data,
  }) {
    return ObjectWithEveryOptionalTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class ObjectWithEveryOptionalTypeNestedObjectDataData {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeNestedObjectDataData(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryOptionalTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class ObjectWithEveryOptionalTypeNestedArrayItemItem {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeNestedArrayItemItem({
    required this.id,
    required this.timestamp,
  });
  factory ObjectWithEveryOptionalTypeNestedArrayItemItem.fromJson(
      Map<String, dynamic> json) {
    return ObjectWithEveryOptionalTypeNestedArrayItemItem(
      id: typeFromDynamic<String>(json["id"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return __result;
  }

  ObjectWithEveryOptionalTypeNestedArrayItemItem copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeNestedArrayItemItem(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class AutoReconnectParams {
  final int messageCount;
  const AutoReconnectParams({
    required this.messageCount,
  });
  factory AutoReconnectParams.fromJson(Map<String, dynamic> json) {
    return AutoReconnectParams(
      messageCount: intFromDynamic(json["messageCount"], 0),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "messageCount": messageCount,
    };

    return __result;
  }

  AutoReconnectParams copyWith({
    int? messageCount,
  }) {
    return AutoReconnectParams(
      messageCount: messageCount ?? this.messageCount,
    );
  }
}

class AutoReconnectResponse {
  final int count;
  final String message;
  const AutoReconnectResponse({
    required this.count,
    required this.message,
  });
  factory AutoReconnectResponse.fromJson(Map<String, dynamic> json) {
    return AutoReconnectResponse(
      count: intFromDynamic(json["count"], 0),
      message: typeFromDynamic<String>(json["message"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "count": count,
      "message": message,
    };

    return __result;
  }

  AutoReconnectResponse copyWith({
    int? count,
    String? message,
  }) {
    return AutoReconnectResponse(
      count: count ?? this.count,
      message: message ?? this.message,
    );
  }
}

class StreamConnectionErrorTestParams {
  final int statusCode;
  final String statusMessage;
  const StreamConnectionErrorTestParams({
    required this.statusCode,
    required this.statusMessage,
  });
  factory StreamConnectionErrorTestParams.fromJson(Map<String, dynamic> json) {
    return StreamConnectionErrorTestParams(
      statusCode: intFromDynamic(json["statusCode"], 0),
      statusMessage: typeFromDynamic<String>(json["statusMessage"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "statusCode": statusCode,
      "statusMessage": statusMessage,
    };

    return __result;
  }

  StreamConnectionErrorTestParams copyWith({
    int? statusCode,
    String? statusMessage,
  }) {
    return StreamConnectionErrorTestParams(
      statusCode: statusCode ?? this.statusCode,
      statusMessage: statusMessage ?? this.statusMessage,
    );
  }
}

class StreamConnectionErrorTestResponse {
  final String message;
  const StreamConnectionErrorTestResponse({
    required this.message,
  });
  factory StreamConnectionErrorTestResponse.fromJson(
      Map<String, dynamic> json) {
    return StreamConnectionErrorTestResponse(
      message: typeFromDynamic<String>(json["message"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "message": message,
    };

    return __result;
  }

  StreamConnectionErrorTestResponse copyWith({
    String? message,
  }) {
    return StreamConnectionErrorTestResponse(
      message: message ?? this.message,
    );
  }
}

class StreamLargeObjectsResponse {
  final List<double> numbers;
  final List<StreamLargeObjectsResponseObjectsItem> objects;
  const StreamLargeObjectsResponse({
    required this.numbers,
    required this.objects,
  });
  factory StreamLargeObjectsResponse.fromJson(Map<String, dynamic> json) {
    return StreamLargeObjectsResponse(
      numbers: json["numbers"] is List
          ?
          // ignore: unnecessary_cast
          (json["numbers"] as List)
              .map((item) => doubleFromDynamic(item, 0))
              .toList() as List<double>
          : <double>[],
      objects: json["objects"] is List
          ?
          // ignore: unnecessary_cast
          (json["objects"] as List)
              .map((item) =>
                  StreamLargeObjectsResponseObjectsItem.fromJson(item))
              .toList() as List<StreamLargeObjectsResponseObjectsItem>
          : <StreamLargeObjectsResponseObjectsItem>[],
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "numbers": numbers.map((item) => item).toList(),
      "objects": objects.map((item) => item.toJson()).toList(),
    };

    return __result;
  }

  StreamLargeObjectsResponse copyWith({
    List<double>? numbers,
    List<StreamLargeObjectsResponseObjectsItem>? objects,
  }) {
    return StreamLargeObjectsResponse(
      numbers: numbers ?? this.numbers,
      objects: objects ?? this.objects,
    );
  }
}

class StreamLargeObjectsResponseObjectsItem {
  final String id;
  final String name;
  final String email;
  const StreamLargeObjectsResponseObjectsItem({
    required this.id,
    required this.name,
    required this.email,
  });
  factory StreamLargeObjectsResponseObjectsItem.fromJson(
      Map<String, dynamic> json) {
    return StreamLargeObjectsResponseObjectsItem(
      id: typeFromDynamic<String>(json["id"], ""),
      name: typeFromDynamic<String>(json["name"], ""),
      email: typeFromDynamic<String>(json["email"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "name": name,
      "email": email,
    };

    return __result;
  }

  StreamLargeObjectsResponseObjectsItem copyWith({
    String? id,
    String? name,
    String? email,
  }) {
    return StreamLargeObjectsResponseObjectsItem(
      id: id ?? this.id,
      name: name ?? this.name,
      email: email ?? this.email,
    );
  }
}

class ChatMessageParams {
  final String channelId;
  const ChatMessageParams({
    required this.channelId,
  });
  factory ChatMessageParams.fromJson(Map<String, dynamic> json) {
    return ChatMessageParams(
      channelId: typeFromDynamic<String>(json["channelId"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "channelId": channelId,
    };

    return __result;
  }

  ChatMessageParams copyWith({
    String? channelId,
  }) {
    return ChatMessageParams(
      channelId: channelId ?? this.channelId,
    );
  }
}

sealed class ChatMessage {
  final String messageType;
  const ChatMessage({
    required this.messageType,
  });
  factory ChatMessage.fromJson(Map<String, dynamic> json) {
    if (json["messageType"] is! String) {
      throw Exception(
        "Unable to decode ChatMessage. Expected String from \"messageType\". Received ${json["messageType"]}}",
      );
    }
    switch (json["messageType"]) {
      case "TEXT":
        return ChatMessageText.fromJson(json);
      case "IMAGE":
        return ChatMessageImage.fromJson(json);
      case "URL":
        return ChatMessageUrl.fromJson(json);
    }
    throw Exception(
      "Unable to decode ChatMessage. \"${json["messageType"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class ChatMessageText implements ChatMessage {
  @override
  final String messageType = "TEXT";
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String text;
  const ChatMessageText({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.text,
  });
  factory ChatMessageText.fromJson(Map<String, dynamic> json) {
    return ChatMessageText(
      id: typeFromDynamic<String>(json["id"], ""),
      channelId: typeFromDynamic<String>(json["channelId"], ""),
      userId: typeFromDynamic<String>(json["userId"], ""),
      date: dateTimeFromDynamic(
        json["date"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      text: typeFromDynamic<String>(json["text"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "text": text,
    };

    return __result;
  }

  ChatMessageText copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? text,
  }) {
    return ChatMessageText(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      text: text ?? this.text,
    );
  }
}

class ChatMessageImage implements ChatMessage {
  @override
  final String messageType = "IMAGE";
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String image;
  const ChatMessageImage({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.image,
  });
  factory ChatMessageImage.fromJson(Map<String, dynamic> json) {
    return ChatMessageImage(
      id: typeFromDynamic<String>(json["id"], ""),
      channelId: typeFromDynamic<String>(json["channelId"], ""),
      userId: typeFromDynamic<String>(json["userId"], ""),
      date: dateTimeFromDynamic(
        json["date"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      image: typeFromDynamic<String>(json["image"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "image": image,
    };

    return __result;
  }

  ChatMessageImage copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? image,
  }) {
    return ChatMessageImage(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      image: image ?? this.image,
    );
  }
}

class ChatMessageUrl implements ChatMessage {
  @override
  final String messageType = "URL";
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String url;
  const ChatMessageUrl({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.url,
  });
  factory ChatMessageUrl.fromJson(Map<String, dynamic> json) {
    return ChatMessageUrl(
      id: typeFromDynamic<String>(json["id"], ""),
      channelId: typeFromDynamic<String>(json["channelId"], ""),
      userId: typeFromDynamic<String>(json["userId"], ""),
      date: dateTimeFromDynamic(
        json["date"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      url: typeFromDynamic<String>(json["url"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "url": url,
    };

    return __result;
  }

  ChatMessageUrl copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? url,
  }) {
    return ChatMessageUrl(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      url: url ?? this.url,
    );
  }
}

sealed class WsMessageParams {
  final String type;
  const WsMessageParams({
    required this.type,
  });
  factory WsMessageParams.fromJson(Map<String, dynamic> json) {
    if (json["type"] is! String) {
      throw Exception(
        "Unable to decode WsMessageParams. Expected String from \"type\". Received ${json["type"]}}",
      );
    }
    switch (json["type"]) {
      case "CREATE_ENTITY":
        return WsMessageParamsCreateEntity.fromJson(json);
      case "UPDATE_ENTITY":
        return WsMessageParamsUpdateEntity.fromJson(json);
      case "DISCONNECT":
        return WsMessageParamsDisconnect.fromJson(json);
    }
    throw Exception(
      "Unable to decode WsMessageParams. \"${json["type"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class WsMessageParamsCreateEntity implements WsMessageParams {
  @override
  final String type = "CREATE_ENTITY";
  final String entityId;
  final double x;
  final double y;
  const WsMessageParamsCreateEntity({
    required this.entityId,
    required this.x,
    required this.y,
  });
  factory WsMessageParamsCreateEntity.fromJson(Map<String, dynamic> json) {
    return WsMessageParamsCreateEntity(
      entityId: typeFromDynamic<String>(json["entityId"], ""),
      x: doubleFromDynamic(json["x"], 0),
      y: doubleFromDynamic(json["y"], 0),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "entityId": entityId,
      "x": x,
      "y": y,
    };

    return __result;
  }

  WsMessageParamsCreateEntity copyWith({
    String? entityId,
    double? x,
    double? y,
  }) {
    return WsMessageParamsCreateEntity(
      entityId: entityId ?? this.entityId,
      x: x ?? this.x,
      y: y ?? this.y,
    );
  }
}

class WsMessageParamsUpdateEntity implements WsMessageParams {
  @override
  final String type = "UPDATE_ENTITY";
  final String entityId;
  final double x;
  final double y;
  const WsMessageParamsUpdateEntity({
    required this.entityId,
    required this.x,
    required this.y,
  });
  factory WsMessageParamsUpdateEntity.fromJson(Map<String, dynamic> json) {
    return WsMessageParamsUpdateEntity(
      entityId: typeFromDynamic<String>(json["entityId"], ""),
      x: doubleFromDynamic(json["x"], 0),
      y: doubleFromDynamic(json["y"], 0),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "entityId": entityId,
      "x": x,
      "y": y,
    };

    return __result;
  }

  WsMessageParamsUpdateEntity copyWith({
    String? entityId,
    double? x,
    double? y,
  }) {
    return WsMessageParamsUpdateEntity(
      entityId: entityId ?? this.entityId,
      x: x ?? this.x,
      y: y ?? this.y,
    );
  }
}

class WsMessageParamsDisconnect implements WsMessageParams {
  @override
  final String type = "DISCONNECT";
  final String reason;
  const WsMessageParamsDisconnect({
    required this.reason,
  });
  factory WsMessageParamsDisconnect.fromJson(Map<String, dynamic> json) {
    return WsMessageParamsDisconnect(
      reason: typeFromDynamic<String>(json["reason"], ""),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "reason": reason,
    };

    return __result;
  }

  WsMessageParamsDisconnect copyWith({
    String? reason,
  }) {
    return WsMessageParamsDisconnect(
      reason: reason ?? this.reason,
    );
  }
}

sealed class WsMessageResponse {
  final String type;
  const WsMessageResponse({
    required this.type,
  });
  factory WsMessageResponse.fromJson(Map<String, dynamic> json) {
    if (json["type"] is! String) {
      throw Exception(
        "Unable to decode WsMessageResponse. Expected String from \"type\". Received ${json["type"]}}",
      );
    }
    switch (json["type"]) {
      case "ENTITY_CREATED":
        return WsMessageResponseEntityCreated.fromJson(json);
      case "ENTITY_UPDATED":
        return WsMessageResponseEntityUpdated.fromJson(json);
    }
    throw Exception(
      "Unable to decode WsMessageResponse. \"${json["type"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class WsMessageResponseEntityCreated implements WsMessageResponse {
  @override
  final String type = "ENTITY_CREATED";
  final String entityId;
  final double x;
  final double y;
  const WsMessageResponseEntityCreated({
    required this.entityId,
    required this.x,
    required this.y,
  });
  factory WsMessageResponseEntityCreated.fromJson(Map<String, dynamic> json) {
    return WsMessageResponseEntityCreated(
      entityId: typeFromDynamic<String>(json["entityId"], ""),
      x: doubleFromDynamic(json["x"], 0),
      y: doubleFromDynamic(json["y"], 0),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "entityId": entityId,
      "x": x,
      "y": y,
    };

    return __result;
  }

  WsMessageResponseEntityCreated copyWith({
    String? entityId,
    double? x,
    double? y,
  }) {
    return WsMessageResponseEntityCreated(
      entityId: entityId ?? this.entityId,
      x: x ?? this.x,
      y: y ?? this.y,
    );
  }
}

class WsMessageResponseEntityUpdated implements WsMessageResponse {
  @override
  final String type = "ENTITY_UPDATED";
  final String entityId;
  final double x;
  final double y;
  const WsMessageResponseEntityUpdated({
    required this.entityId,
    required this.x,
    required this.y,
  });
  factory WsMessageResponseEntityUpdated.fromJson(Map<String, dynamic> json) {
    return WsMessageResponseEntityUpdated(
      entityId: typeFromDynamic<String>(json["entityId"], ""),
      x: doubleFromDynamic(json["x"], 0),
      y: doubleFromDynamic(json["y"], 0),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "type": type,
      "entityId": entityId,
      "x": x,
      "y": y,
    };

    return __result;
  }

  WsMessageResponseEntityUpdated copyWith({
    String? entityId,
    double? x,
    double? y,
  }) {
    return WsMessageResponseEntityUpdated(
      entityId: entityId ?? this.entityId,
      x: x ?? this.x,
      y: y ?? this.y,
    );
  }
}

class PostParams {
  final String postId;
  const PostParams({
    required this.postId,
  });
  factory PostParams.fromJson(Map<String, dynamic> json) {
    return PostParams(
      postId: typeFromDynamic<String>(json["postId"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "postId": postId,
    };

    return __result;
  }

  PostParams copyWith({
    String? postId,
  }) {
    return PostParams(
      postId: postId ?? this.postId,
    );
  }
}

class Post {
  final String id;
  final String title;
  final PostType type;
  final String? description;
  final String content;
  final List<String> tags;
  final String authorId;
  final Author author;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Post({
    required this.id,
    required this.title,
    required this.type,
    required this.description,
    required this.content,
    required this.tags,
    required this.authorId,
    required this.author,
    required this.createdAt,
    required this.updatedAt,
  });
  factory Post.fromJson(Map<String, dynamic> json) {
    return Post(
      id: typeFromDynamic<String>(json["id"], ""),
      title: typeFromDynamic<String>(json["title"], ""),
      type: PostType.fromJson(json["type"]),
      description: nullableTypeFromDynamic<String>(json["description"]),
      content: typeFromDynamic<String>(json["content"], ""),
      tags: json["tags"] is List
          ?
          // ignore: unnecessary_cast
          (json["tags"] as List)
              .map((item) => typeFromDynamic<String>(item, ""))
              .toList() as List<String>
          : <String>[],
      authorId: typeFromDynamic<String>(json["authorId"], ""),
      author: Author.fromJson(json["author"]),
      createdAt: dateTimeFromDynamic(
        json["createdAt"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      updatedAt: dateTimeFromDynamic(
        json["updatedAt"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "title": title,
      "type": type.value,
      "description": description,
      "content": content,
      "tags": tags.map((item) => item).toList(),
      "authorId": authorId,
      "author": author.toJson(),
      "createdAt": createdAt.toUtc().toIso8601String(),
      "updatedAt": updatedAt.toUtc().toIso8601String(),
    };

    return __result;
  }

  Post copyWith({
    String? id,
    String? title,
    PostType? type,
    String? description,
    String? content,
    List<String>? tags,
    String? authorId,
    Author? author,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      type: type ?? this.type,
      description: description ?? this.description,
      content: content ?? this.content,
      tags: tags ?? this.tags,
      authorId: authorId ?? this.authorId,
      author: author ?? this.author,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

enum PostType implements Comparable<PostType> {
  text("text"),
  image("image"),
  video("video");

  const PostType(this.value);
  final String value;

  factory PostType.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return text;
  }

  @override
  compareTo(PostType other) => name.compareTo(other.name);
}

class Author {
  final String id;
  final String name;
  final String? bio;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Author({
    required this.id,
    required this.name,
    required this.bio,
    required this.createdAt,
    required this.updatedAt,
  });
  factory Author.fromJson(Map<String, dynamic> json) {
    return Author(
      id: typeFromDynamic<String>(json["id"], ""),
      name: typeFromDynamic<String>(json["name"], ""),
      bio: nullableTypeFromDynamic<String>(json["bio"]),
      createdAt: dateTimeFromDynamic(
        json["createdAt"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      updatedAt: dateTimeFromDynamic(
        json["updatedAt"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "name": name,
      "bio": bio,
      "createdAt": createdAt.toUtc().toIso8601String(),
      "updatedAt": updatedAt.toUtc().toIso8601String(),
    };

    return __result;
  }

  Author copyWith({
    String? id,
    String? name,
    String? bio,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return Author(
      id: id ?? this.id,
      name: name ?? this.name,
      bio: bio ?? this.bio,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

class PostListParams {
  final int limit;
  final PostType? type;
  const PostListParams({
    required this.limit,
    this.type,
  });
  factory PostListParams.fromJson(Map<String, dynamic> json) {
    return PostListParams(
      limit: intFromDynamic(json["limit"], 0),
      type: json["type"] is Map<String, dynamic>
          ? PostType.fromJson(json["type"])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "limit": limit,
    };
    if (type != null) {
      __result["type"] = type?.value;
    }
    return __result;
  }

  PostListParams copyWith({
    int? limit,
    PostType? type,
  }) {
    return PostListParams(
      limit: limit ?? this.limit,
      type: type ?? this.type,
    );
  }
}

class PostListResponse {
  final int total;
  final List<Post> items;
  const PostListResponse({
    required this.total,
    required this.items,
  });
  factory PostListResponse.fromJson(Map<String, dynamic> json) {
    return PostListResponse(
      total: intFromDynamic(json["total"], 0),
      items: json["items"] is List
          ?
          // ignore: unnecessary_cast
          (json["items"] as List).map((item) => Post.fromJson(item)).toList()
              as List<Post>
          : <Post>[],
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "total": total,
      "items": items.map((item) => item.toJson()).toList(),
    };

    return __result;
  }

  PostListResponse copyWith({
    int? total,
    List<Post>? items,
  }) {
    return PostListResponse(
      total: total ?? this.total,
      items: items ?? this.items,
    );
  }
}

sealed class PostEvent {
  final String eventType;
  const PostEvent({
    required this.eventType,
  });
  factory PostEvent.fromJson(Map<String, dynamic> json) {
    if (json["eventType"] is! String) {
      throw Exception(
        "Unable to decode PostEvent. Expected String from \"eventType\". Received ${json["eventType"]}}",
      );
    }
    switch (json["eventType"]) {
      case "POST_CREATED":
        return PostEventPostCreated.fromJson(json);
      case "POST_DELETED":
        return PostEventPostDeleted.fromJson(json);
      case "POST_UPDATED":
        return PostEventPostUpdated.fromJson(json);
      case "POST_LIKED":
        return PostEventPostLiked.fromJson(json);
      case "POST_COMMENTED":
        return PostEventPostCommented.fromJson(json);
    }
    throw Exception(
      "Unable to decode PostEvent. \"${json["eventType"]}\" doesn't match any of the accepted discriminator values.",
    );
  }
  Map<String, dynamic> toJson();
}

class PostEventPostCreated implements PostEvent {
  @override
  final String eventType = "POST_CREATED";
  final String postId;
  final DateTime timestamp;
  const PostEventPostCreated({
    required this.postId,
    required this.timestamp,
  });
  factory PostEventPostCreated.fromJson(Map<String, dynamic> json) {
    return PostEventPostCreated(
      postId: typeFromDynamic<String>(json["postId"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "eventType": eventType,
      "postId": postId,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return __result;
  }

  PostEventPostCreated copyWith({
    String? postId,
    DateTime? timestamp,
  }) {
    return PostEventPostCreated(
      postId: postId ?? this.postId,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class PostEventPostDeleted implements PostEvent {
  @override
  final String eventType = "POST_DELETED";
  final String postId;
  final DateTime timestamp;
  const PostEventPostDeleted({
    required this.postId,
    required this.timestamp,
  });
  factory PostEventPostDeleted.fromJson(Map<String, dynamic> json) {
    return PostEventPostDeleted(
      postId: typeFromDynamic<String>(json["postId"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "eventType": eventType,
      "postId": postId,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return __result;
  }

  PostEventPostDeleted copyWith({
    String? postId,
    DateTime? timestamp,
  }) {
    return PostEventPostDeleted(
      postId: postId ?? this.postId,
      timestamp: timestamp ?? this.timestamp,
    );
  }
}

class PostEventPostUpdated implements PostEvent {
  @override
  final String eventType = "POST_UPDATED";
  final String postId;
  final DateTime timestamp;
  final PostEventPostUpdatedData data;
  const PostEventPostUpdated({
    required this.postId,
    required this.timestamp,
    required this.data,
  });
  factory PostEventPostUpdated.fromJson(Map<String, dynamic> json) {
    return PostEventPostUpdated(
      postId: typeFromDynamic<String>(json["postId"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      data: PostEventPostUpdatedData.fromJson(json["data"]),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "eventType": eventType,
      "postId": postId,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return __result;
  }

  PostEventPostUpdated copyWith({
    String? postId,
    DateTime? timestamp,
    PostEventPostUpdatedData? data,
  }) {
    return PostEventPostUpdated(
      postId: postId ?? this.postId,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }
}

class PostEventPostUpdatedData {
  final String? id;
  final String? title;
  final PostType? type;
  final String? description;
  final String? content;
  final List<String>? tags;
  final String? authorId;
  final Author? author;
  final DateTime? createdAt;
  final DateTime? updatedAt;
  const PostEventPostUpdatedData({
    this.id,
    this.title,
    this.type,
    this.description,
    this.content,
    this.tags,
    this.authorId,
    this.author,
    this.createdAt,
    this.updatedAt,
  });
  factory PostEventPostUpdatedData.fromJson(Map<String, dynamic> json) {
    return PostEventPostUpdatedData(
      id: nullableTypeFromDynamic<String>(json["id"]),
      title: nullableTypeFromDynamic<String>(json["title"]),
      type: json["type"] is Map<String, dynamic>
          ? PostType.fromJson(json["type"])
          : null,
      description: nullableTypeFromDynamic<String>(json["description"]),
      content: nullableTypeFromDynamic<String>(json["content"]),
      tags: json["tags"] is List
          ?
          // ignore: unnecessary_cast
          (json["tags"] as List)
              .map((item) => typeFromDynamic<String>(item, ""))
              .toList() as List<String>?
          : null,
      authorId: nullableTypeFromDynamic<String>(json["authorId"]),
      author: json["author"] is Map<String, dynamic>
          ? Author.fromJson(json["author"])
          : null,
      createdAt: nullableDateTimeFromDynamic(json["createdAt"]),
      updatedAt: nullableDateTimeFromDynamic(json["updatedAt"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{};
    if (id != null) {
      __result["id"] = id;
    }
    if (title != null) {
      __result["title"] = title;
    }
    if (type != null) {
      __result["type"] = type?.value;
    }
    if (description != null) {
      __result["description"] = description;
    }
    if (content != null) {
      __result["content"] = content;
    }
    if (tags != null) {
      __result["tags"] = tags?.map((item) => item).toList();
    }
    if (authorId != null) {
      __result["authorId"] = authorId;
    }
    if (author != null) {
      __result["author"] = author?.toJson();
    }
    if (createdAt != null) {
      __result["createdAt"] = createdAt?.toUtc().toIso8601String();
    }
    if (updatedAt != null) {
      __result["updatedAt"] = updatedAt?.toUtc().toIso8601String();
    }
    return __result;
  }

  PostEventPostUpdatedData copyWith({
    String? id,
    String? title,
    PostType? type,
    String? description,
    String? content,
    List<String>? tags,
    String? authorId,
    Author? author,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return PostEventPostUpdatedData(
      id: id ?? this.id,
      title: title ?? this.title,
      type: type ?? this.type,
      description: description ?? this.description,
      content: content ?? this.content,
      tags: tags ?? this.tags,
      authorId: authorId ?? this.authorId,
      author: author ?? this.author,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

class PostEventPostLiked implements PostEvent {
  @override
  final String eventType = "POST_LIKED";
  final String postId;
  final DateTime timestamp;
  final String postLikeId;
  final int postLikeCount;
  const PostEventPostLiked({
    required this.postId,
    required this.timestamp,
    required this.postLikeId,
    required this.postLikeCount,
  });
  factory PostEventPostLiked.fromJson(Map<String, dynamic> json) {
    return PostEventPostLiked(
      postId: typeFromDynamic<String>(json["postId"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      postLikeId: typeFromDynamic<String>(json["postLikeId"], ""),
      postLikeCount: intFromDynamic(json["postLikeCount"], 0),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "eventType": eventType,
      "postId": postId,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "postLikeId": postLikeId,
      "postLikeCount": postLikeCount,
    };

    return __result;
  }

  PostEventPostLiked copyWith({
    String? postId,
    DateTime? timestamp,
    String? postLikeId,
    int? postLikeCount,
  }) {
    return PostEventPostLiked(
      postId: postId ?? this.postId,
      timestamp: timestamp ?? this.timestamp,
      postLikeId: postLikeId ?? this.postLikeId,
      postLikeCount: postLikeCount ?? this.postLikeCount,
    );
  }
}

class PostEventPostCommented implements PostEvent {
  @override
  final String eventType = "POST_COMMENTED";
  final String postId;
  final DateTime timestamp;
  final String commentId;
  final String commentText;
  final int commentCount;
  const PostEventPostCommented({
    required this.postId,
    required this.timestamp,
    required this.commentId,
    required this.commentText,
    required this.commentCount,
  });
  factory PostEventPostCommented.fromJson(Map<String, dynamic> json) {
    return PostEventPostCommented(
      postId: typeFromDynamic<String>(json["postId"], ""),
      timestamp: dateTimeFromDynamic(
        json["timestamp"],
        DateTime.fromMillisecondsSinceEpoch(0),
      ),
      commentId: typeFromDynamic<String>(json["commentId"], ""),
      commentText: typeFromDynamic<String>(json["commentText"], ""),
      commentCount: intFromDynamic(json["commentCount"], 0),
    );
  }
  @override
  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "eventType": eventType,
      "postId": postId,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "commentId": commentId,
      "commentText": commentText,
      "commentCount": commentCount,
    };

    return __result;
  }

  PostEventPostCommented copyWith({
    String? postId,
    DateTime? timestamp,
    String? commentId,
    String? commentText,
    int? commentCount,
  }) {
    return PostEventPostCommented(
      postId: postId ?? this.postId,
      timestamp: timestamp ?? this.timestamp,
      commentId: commentId ?? this.commentId,
      commentText: commentText ?? this.commentText,
      commentCount: commentCount ?? this.commentCount,
    );
  }
}

class LogPostEventResponse {
  final bool success;
  final String message;
  const LogPostEventResponse({
    required this.success,
    required this.message,
  });
  factory LogPostEventResponse.fromJson(Map<String, dynamic> json) {
    return LogPostEventResponse(
      success: typeFromDynamic<bool>(json["success"], false),
      message: typeFromDynamic<String>(json["message"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "success": success,
      "message": message,
    };

    return __result;
  }

  LogPostEventResponse copyWith({
    bool? success,
    String? message,
  }) {
    return LogPostEventResponse(
      success: success ?? this.success,
      message: message ?? this.message,
    );
  }
}

class UpdatePostParams {
  final String postId;
  final UpdatePostParamsData data;
  const UpdatePostParams({
    required this.postId,
    required this.data,
  });
  factory UpdatePostParams.fromJson(Map<String, dynamic> json) {
    return UpdatePostParams(
      postId: typeFromDynamic<String>(json["postId"], ""),
      data: UpdatePostParamsData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "postId": postId,
      "data": data.toJson(),
    };

    return __result;
  }

  UpdatePostParams copyWith({
    String? postId,
    UpdatePostParamsData? data,
  }) {
    return UpdatePostParams(
      postId: postId ?? this.postId,
      data: data ?? this.data,
    );
  }
}

class UpdatePostParamsData {
  final String? title;
  final String? description;
  final String? content;
  final List<String>? tags;
  const UpdatePostParamsData({
    this.title,
    this.description,
    this.content,
    this.tags,
  });
  factory UpdatePostParamsData.fromJson(Map<String, dynamic> json) {
    return UpdatePostParamsData(
      title: nullableTypeFromDynamic<String>(json["title"]),
      description: nullableTypeFromDynamic<String>(json["description"]),
      content: nullableTypeFromDynamic<String>(json["content"]),
      tags: json["tags"] is List
          ?
          // ignore: unnecessary_cast
          (json["tags"] as List)
              .map((item) => typeFromDynamic<String>(item, ""))
              .toList() as List<String>?
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{};
    if (title != null) {
      __result["title"] = title;
    }
    if (description != null) {
      __result["description"] = description;
    }
    if (content != null) {
      __result["content"] = content;
    }
    if (tags != null) {
      __result["tags"] = tags?.map((item) => item).toList();
    }
    return __result;
  }

  UpdatePostParamsData copyWith({
    String? title,
    String? description,
    String? content,
    List<String>? tags,
  }) {
    return UpdatePostParamsData(
      title: title ?? this.title,
      description: description ?? this.description,
      content: content ?? this.content,
      tags: tags ?? this.tags,
    );
  }
}

class AnnotationId {
  final String id;
  final String version;
  const AnnotationId({
    required this.id,
    required this.version,
  });
  factory AnnotationId.fromJson(Map<String, dynamic> json) {
    return AnnotationId(
      id: typeFromDynamic<String>(json["id"], ""),
      version: typeFromDynamic<String>(json["version"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "id": id,
      "version": version,
    };

    return __result;
  }

  AnnotationId copyWith({
    String? id,
    String? version,
  }) {
    return AnnotationId(
      id: id ?? this.id,
      version: version ?? this.version,
    );
  }
}

class Annotation {
  final AnnotationId annotationId;
  final AssociatedId associatedId;
  final AnnotationAnnotationType annotationType;
  final int annotationTypeVersion;
  final dynamic metadata;
  final AnnotationBoxTypeRange boxTypeRange;
  const Annotation({
    required this.annotationId,
    required this.associatedId,
    required this.annotationType,
    required this.annotationTypeVersion,
    required this.metadata,
    required this.boxTypeRange,
  });
  factory Annotation.fromJson(Map<String, dynamic> json) {
    return Annotation(
      annotationId: AnnotationId.fromJson(json["annotation_id"]),
      associatedId: AssociatedId.fromJson(json["associated_id"]),
      annotationType:
          AnnotationAnnotationType.fromJson(json["annotation_type"]),
      annotationTypeVersion: intFromDynamic(json["annotation_type_version"], 0),
      metadata: json["metadata"],
      boxTypeRange: AnnotationBoxTypeRange.fromJson(json["box_type_range"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "annotation_id": annotationId.toJson(),
      "associated_id": associatedId.toJson(),
      "annotation_type": annotationType.value,
      "annotation_type_version": annotationTypeVersion,
      "metadata": metadata,
      "box_type_range": boxTypeRange.toJson(),
    };

    return __result;
  }

  Annotation copyWith({
    AnnotationId? annotationId,
    AssociatedId? associatedId,
    AnnotationAnnotationType? annotationType,
    int? annotationTypeVersion,
    dynamic metadata,
    AnnotationBoxTypeRange? boxTypeRange,
  }) {
    return Annotation(
      annotationId: annotationId ?? this.annotationId,
      associatedId: associatedId ?? this.associatedId,
      annotationType: annotationType ?? this.annotationType,
      annotationTypeVersion:
          annotationTypeVersion ?? this.annotationTypeVersion,
      metadata: metadata ?? this.metadata,
      boxTypeRange: boxTypeRange ?? this.boxTypeRange,
    );
  }
}

class AssociatedId {
  final AnnotationAssociatedIdEntityType entityType;
  final String id;
  const AssociatedId({
    required this.entityType,
    required this.id,
  });
  factory AssociatedId.fromJson(Map<String, dynamic> json) {
    return AssociatedId(
      entityType:
          AnnotationAssociatedIdEntityType.fromJson(json["entity_type"]),
      id: typeFromDynamic<String>(json["id"], ""),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "entity_type": entityType.value,
      "id": id,
    };

    return __result;
  }

  AssociatedId copyWith({
    AnnotationAssociatedIdEntityType? entityType,
    String? id,
  }) {
    return AssociatedId(
      entityType: entityType ?? this.entityType,
      id: id ?? this.id,
    );
  }
}

enum AnnotationAssociatedIdEntityType
    implements Comparable<AnnotationAssociatedIdEntityType> {
  movieId("MOVIE_ID"),
  showId("SHOW_ID");

  const AnnotationAssociatedIdEntityType(this.value);
  final String value;

  factory AnnotationAssociatedIdEntityType.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return movieId;
  }

  @override
  compareTo(AnnotationAssociatedIdEntityType other) =>
      name.compareTo(other.name);
}

enum AnnotationAnnotationType implements Comparable<AnnotationAnnotationType> {
  annotationBoundingbox("ANNOTATION_BOUNDINGBOX");

  const AnnotationAnnotationType(this.value);
  final String value;

  factory AnnotationAnnotationType.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return annotationBoundingbox;
  }

  @override
  compareTo(AnnotationAnnotationType other) => name.compareTo(other.name);
}

class AnnotationBoxTypeRange {
  final BigInt startTimeInNanoSec;
  final BigInt endTimeInNanoSec;
  const AnnotationBoxTypeRange({
    required this.startTimeInNanoSec,
    required this.endTimeInNanoSec,
  });
  factory AnnotationBoxTypeRange.fromJson(Map<String, dynamic> json) {
    return AnnotationBoxTypeRange(
      startTimeInNanoSec:
          bigIntFromDynamic(json["start_time_in_nano_sec"], BigInt.zero),
      endTimeInNanoSec:
          bigIntFromDynamic(json["end_time_in_nano_sec"], BigInt.zero),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "start_time_in_nano_sec": startTimeInNanoSec.toString(),
      "end_time_in_nano_sec": endTimeInNanoSec.toString(),
    };

    return __result;
  }

  AnnotationBoxTypeRange copyWith({
    BigInt? startTimeInNanoSec,
    BigInt? endTimeInNanoSec,
  }) {
    return AnnotationBoxTypeRange(
      startTimeInNanoSec: startTimeInNanoSec ?? this.startTimeInNanoSec,
      endTimeInNanoSec: endTimeInNanoSec ?? this.endTimeInNanoSec,
    );
  }
}

class UpdateAnnotationParams {
  final String annotationId;
  final String annotationIdVersion;
  final UpdateAnnotationData data;
  const UpdateAnnotationParams({
    required this.annotationId,
    required this.annotationIdVersion,
    required this.data,
  });
  factory UpdateAnnotationParams.fromJson(Map<String, dynamic> json) {
    return UpdateAnnotationParams(
      annotationId: typeFromDynamic<String>(json["annotation_id"], ""),
      annotationIdVersion:
          typeFromDynamic<String>(json["annotation_id_version"], ""),
      data: UpdateAnnotationData.fromJson(json["data"]),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "annotation_id": annotationId,
      "annotation_id_version": annotationIdVersion,
      "data": data.toJson(),
    };

    return __result;
  }

  UpdateAnnotationParams copyWith({
    String? annotationId,
    String? annotationIdVersion,
    UpdateAnnotationData? data,
  }) {
    return UpdateAnnotationParams(
      annotationId: annotationId ?? this.annotationId,
      annotationIdVersion: annotationIdVersion ?? this.annotationIdVersion,
      data: data ?? this.data,
    );
  }
}

class UpdateAnnotationData {
  final AssociatedId? associatedId;
  final UpdateAnnotationParamsDataAnnotationType? annotationType;
  final int? annotationTypeVersion;
  final dynamic metadata;
  final UpdateAnnotationDataBoxTypeRange? boxTypeRange;
  const UpdateAnnotationData({
    this.associatedId,
    this.annotationType,
    this.annotationTypeVersion,
    this.metadata,
    this.boxTypeRange,
  });
  factory UpdateAnnotationData.fromJson(Map<String, dynamic> json) {
    return UpdateAnnotationData(
      associatedId: json["associated_id"] is Map<String, dynamic>
          ? AssociatedId.fromJson(json["associated_id"])
          : null,
      annotationType: json["annotation_type"] is Map<String, dynamic>
          ? UpdateAnnotationParamsDataAnnotationType.fromJson(
              json["annotation_type"])
          : null,
      annotationTypeVersion:
          nullableIntFromDynamic(json["annotation_type_version"]),
      metadata: json["metadata"],
      boxTypeRange: json["box_type_range"] is Map<String, dynamic>
          ? UpdateAnnotationDataBoxTypeRange.fromJson(json["box_type_range"])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{};
    if (associatedId != null) {
      __result["associated_id"] = associatedId?.toJson();
    }
    if (annotationType != null) {
      __result["annotation_type"] = annotationType?.value;
    }
    if (annotationTypeVersion != null) {
      __result["annotation_type_version"] = annotationTypeVersion;
    }
    if (metadata != null) {
      __result["metadata"] = metadata;
    }
    if (boxTypeRange != null) {
      __result["box_type_range"] = boxTypeRange?.toJson();
    }
    return __result;
  }

  UpdateAnnotationData copyWith({
    AssociatedId? associatedId,
    UpdateAnnotationParamsDataAnnotationType? annotationType,
    int? annotationTypeVersion,
    dynamic metadata,
    UpdateAnnotationDataBoxTypeRange? boxTypeRange,
  }) {
    return UpdateAnnotationData(
      associatedId: associatedId ?? this.associatedId,
      annotationType: annotationType ?? this.annotationType,
      annotationTypeVersion:
          annotationTypeVersion ?? this.annotationTypeVersion,
      metadata: metadata ?? this.metadata,
      boxTypeRange: boxTypeRange ?? this.boxTypeRange,
    );
  }
}

enum UpdateAnnotationParamsDataAnnotationType
    implements Comparable<UpdateAnnotationParamsDataAnnotationType> {
  annotationBoundingbox("ANNOTATION_BOUNDINGBOX");

  const UpdateAnnotationParamsDataAnnotationType(this.value);
  final String value;

  factory UpdateAnnotationParamsDataAnnotationType.fromJson(dynamic json) {
    for (final v in values) {
      if (v.value == json) {
        return v;
      }
    }
    return annotationBoundingbox;
  }

  @override
  compareTo(UpdateAnnotationParamsDataAnnotationType other) =>
      name.compareTo(other.name);
}

class UpdateAnnotationDataBoxTypeRange {
  final BigInt startTimeInNanoSec;
  final BigInt endTimeInNanoSec;
  const UpdateAnnotationDataBoxTypeRange({
    required this.startTimeInNanoSec,
    required this.endTimeInNanoSec,
  });
  factory UpdateAnnotationDataBoxTypeRange.fromJson(Map<String, dynamic> json) {
    return UpdateAnnotationDataBoxTypeRange(
      startTimeInNanoSec:
          bigIntFromDynamic(json["start_time_in_nano_sec"], BigInt.zero),
      endTimeInNanoSec:
          bigIntFromDynamic(json["end_time_in_nano_sec"], BigInt.zero),
    );
  }

  Map<String, dynamic> toJson() {
    final __result = <String, dynamic>{
      "start_time_in_nano_sec": startTimeInNanoSec.toString(),
      "end_time_in_nano_sec": endTimeInNanoSec.toString(),
    };

    return __result;
  }

  UpdateAnnotationDataBoxTypeRange copyWith({
    BigInt? startTimeInNanoSec,
    BigInt? endTimeInNanoSec,
  }) {
    return UpdateAnnotationDataBoxTypeRange(
      startTimeInNanoSec: startTimeInNanoSec ?? this.startTimeInNanoSec,
      endTimeInNanoSec: endTimeInNanoSec ?? this.endTimeInNanoSec,
    );
  }
}
